
Classes -- Sınıflar


data abstraction -- veri soyutlama

problem domainde ki varlıkları. Programalma dilinde yazılımsal olarak temsil etmektir.


user defined type

ikiside sınıf anlamına gelmektedir

class
struct


class definition -- tanımı
class declaration --- bildirimi

//boş sınıflar

class Myclass{

};

struct Mydata {

};


---------------------------

//class Tag
class Myclass{
    //bildirimler
    //memberlar
};




class'ın memberları 3 kategoride olabilir


1- data member -- veri ogeleri
   a- non-static data member
   b- static data members

2- member functions -- üye fonksiyonlar
   a- non-static member functions
     1-non-const member functions
     2- const member functions
   b- static member functions

3- member type -- type members - nested types



Ornek

//class Tag
class Myclass{
    int x, y;
    static double dval;
    void func();
    static int foo();
    typedef int Word;
    enum class Color{White, Black};
};


***************************************************


scope --kapsam

c de scope kavramı

file scope
block scope
function prototype scope
function scope

C++ de scope kavramı

namespace scope
class scope
block scope
function prototype scope
function scope


*************************************************


name lookup ---> isim arama

context-control

access control -- erişim kontrolu




*************************************************

class scope ta bir isim hangi durumlarda aranır

a- isim nokta operatörünün (member selection - dot operator)
   sagında kullanılmış ise

b- isim ok operatörünün (member selection - arrow operator)
   sagında kullanılmış ise

c- isim :: çözünürlük operatörünün (member selection - scope resolution operator)
   sagında kullanılmış ise

ornek

clas Myclass{
  int y;
};

Myclass myclass;

myclass.y;
myclass->y;
myclass::y;


----------------------------------------

sınıflara erişimler (access specifier) için 3 tanım

public member
private member
protected member

bunların hepsi anahtar sözcük



#include <iostream>

using namespace std;

class Myclass{

public:
    //burası public memberlar

private:
    //burası private memberlar

protected:
    //burası protected memberlar

public:
    //burası public memberlar

};



int main()
{
    cout << "Hello World!" << endl;
    return 0;
}

/*********************************************/
/*********************************************/




class Myclass{
  //membler private alanda kabul edilir
};


struct Myclass{
  //membler public alanda kabul edilir
};



class Myclass{

    int x; // private alanda

public:


};

------------------------------------------------

public
   kısım olan isimler erişimi herekse açıktır

private
  clinetlara kapalı isimler ama sınıf kendisi kendi içinde kullanabileceği isimler

protected
  inheritance (miras kalıtım) oldugu yerlerde sınıfın memberlarına erişim izni vardır
  eger kalıtım yok ise private özelliğine sahip olmus olur




#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;

};



int main()
{
    Myclass myclass;

    myclass.x;
    return 0;
}

/*********************************************/
/*********************************************/


soru gecerlimi -- Hayır

aynı scope aynı isim tanımlaması var

public ve private protected scope deil alan bildiri sadece


class Myclass{
public:
    int x;

private:
    int x();
    int y;

};


************************************************************

class veri elemanları


#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;
    double z;

};



int main()
{
    cout << "sizeof (Myclass) : " << sizeof (Myclass) << endl;
    return 0;
}

/*********************************************/
/*********************************************/

member function

//member function
class Myclass{
public:
    void func(int);
};



fonksiyon clasın dısın bildirilirse su isimleri alır

//global function
//free function
//stand-alone function

int foo(void);


/*****************************************/

Nedemek sınıfın üye fonksiyonu

fonksiyon özelliklerine sahip fakat sadece class scope da yer alması lazım


#include <iostream>

using namespace std;

//member function
class Myclass{
public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;

    m1.func(33);

    Myclass *m2 = new Myclass();

    m2->func(55);

    return 0;
}

/*********************************************/
/*********************************************/


neden private ile dışarıdan erişim yok

1- dışarıdan sınıfın kullanacak client sınıfın data memberlarının ne oldugunu bilmak zorunda değil
2- sınıfın data memberlarını client kodların erişimine çarsak kontrol elden gider



#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;
    Myclass *m2 = &m1;

    //her iki durumdada  m1'in func'ı cagrılır
    m1.func(3);
    m2->func(4);


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func();
};


int main()
{
    //bu fonksiyonı böyle cagırmak için Myclass nesnesi olması lazım
    Myclass::func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:
    void func();
};

void func(int);


//aynı siim tanımlamalar gecerlidir
//farklı scope oldugu için

//function overloading degildir scopelar farklı oldugu için

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:

    //overload edeilirim
    void func();
    void func(int);
    void func(int, int);
    void func(double);
};


int main()
{

    Data mydata;

    mydata.func();
    mydata.func(2);
    mydata.func(2, 5);
    mydata.func(2u); //sentaks hatası olur

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

class Data{
private:
    void func(int);

public:
    void func(double);
};


int main()
{

    Data mydata;

    //mydata.func(12.56); // gecerli
    //mydata.func(12); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/





//gecerlimi? Evet

int func(int);
int func(int);


//gecerlimi? Hayır

class Data{
public:
  void func(int);
  void func(int);
}


/*********************************************/
/*********************************************/

sınıfın üye fonksiyonları storage'a dahil değildir

#include <iostream>

using namespace std;

//soru
class Data{
public:
  void func(int);
  void foo(int);

private:
  int x, y;
};


int main()
{

    cout << "sizeof(Data) : " << sizeof (Data) << endl;

    return 0;
}

/*********************************************/
/*********************************************/


Myclass.hpp   --> class definition
Myclass.cpp   --> class declaration


#include <iostream>

using namespace std;

//.hpp
class Myclass {
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp

void Myclass::func(){
    //3
    if(1){
        //2
        if(1){
            //1
            //a  --> isim kullansaydım burada
            //1- ilk önce uye fonksiyonun içinde arar
            //2- class scope içinde arar
            //3- global alanda arar
        }
    }
}


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

int x = 20;

int main()
{
    int x = 10;

    cout << "x = " << x << endl;
    cout << "::x = " << ::x << endl;

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

int mx = 25;

//.cpp
void Myclass::func()
{
    int mx = 10;

    mx = 12; // yerel

    Myclass::mx = 22; // class mx

    ++::mx;

}

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp
void Myclass::func()
{
    mx = 12;

}

int main()
{
    Myclass m1, m2;

    //
    m1.func(); // burada mx, m1in mx'i
    m2.func(); // burada mx, m2 in mx'i


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo(int);

private:
    int mx, my;
};

void foo()
{
    //
}

//.cpp
void Myclass::func()
{
    foo(); //sentaks hatası
    ::foo(); // global fonksiyona erişirim çözünürlük operatoru ile

}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx, my;
};

//ben write - setter görevi görür
void foo(struct Data *p);

//ben alrım seni  oynama yapmam sende okuma - getter görevi görevi
void foo(const struct Data *p);


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //bunlara böyle hangisinini getter hengisinin setter oldugunu anlayamıyorum
    void func();
    void foo();
};

//.cpp


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp

void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();

    //iki ayrı fonksiyon olarak gecerlidir
    //const overloading
    void foo();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo(){
    mx = 10;
}

void Myclass::foo() const{
    mx = 12;
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

const üye fonksiyonları sınıfın nonstatic data type'larını değiştirmez


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    Myclass a;
    a.mx = 22;

    mx = 22; //    sentaks hatası
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp


int main()
{
    Myclass m1;
    //const Myclass m2;

    m1.foo();
    m1.func();
    m2.foo();
    m2.func(); // sentaks hatası

    /*
     * const T* ----> T* donusum yok
     * T* ------> const T* donusum var
     *
     */


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;
    void fuu()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    foo();
    //T*  ---> const T* donusum var
}

void Myclass::foo() const{
    func();// sentaks hatası
    //const T* ---> T* donusum yok
    fuu();
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


Üye fonksiyonları ve const overloading

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //const overloading
    void func();
    void func()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass::func()" << endl;
}

void Myclass::func() const{
    cout << "Myclass::func() const" << endl;
}


int main()
{
    Myclass m1;
    m1.func();

    //const Myclass m2;
    m2.func(); // const olan cagrılacaktı

    return 0;
}

/*********************************************/
/*********************************************/


this anahtar sözcüğüne ---- this pointer

this anahtar sözcüğü yanlızcana sınıfların
non-static üye fonksiyonları içinde kullanılır.



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    this; // nesnenin adresi
    *this; // nesnenşn kendisi

    mx = 10;// bunuda yazabiliriz
    this->mx = 20; // bunuda
    //ikiside aynı mx

    //iki foo da aynı
    //hiç bir fark yok
    foo();
    this->foo();

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    int mx = 10;

    //şimdi iki mx farklı biri local biri class data member
    mx = 20;
    this->mx = 30;
    Myclass::mx; // class scotaki mx

    (*this).mx = 34;

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

template<typename T>
struct ValCat {
    constexpr static const char *pstr {"PR value"};
};

template<typename T>
struct ValCat <T &>{
    constexpr static const char *pstr {"L value"};
};

template<typename T>
struct ValCat <T &&>{
    constexpr static const char *pstr {"X value"};
};

#define vcat(exp)  (std::cout<< "value category of \"" #exp "\" is : " << ValCat<decltype((exp))>::pstr << "\n");


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    vcat(this); /// r value expression
    vcat(*this);// l value expre
}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";
    foo();
}

void Myclass::foo(){
    cout << "Myclass sinifinin foo islevi cagrildi\n";
    cout << "this : " << this << "\n";
}

int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

void gf(Myclass *p){
    cout << "global gf islevi cagrildi  p : " << p << "\n";
}


void gf1(Myclass &p){
    cout << "global gf1 islevi cagrildi  p : " << &p << "\n";
}

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";

    //işte böyle global foksiyonlarda kullancak isek
    //this pointer kullanılır
    gf(this);
    gf1(*this);
}


int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass &f1();
    Myclass &f2();
    Myclass &f3();
    Myclass &f4();

private:
    int mx, my;
};


//.cpp
Myclass &Myclass::f1(){
    return *this;
}


int main()
{
    Myclass m1;
    m1.f1().f2().f3().f4();


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

int main()
{
    int x = 4;
    double d = 5.5;
    bool flag = false;


    cout << x << d << flag;
    //operator overloading
    //ileride


    //operator overloading olmasaydı
    //*this sayesinde bunu böyle kullanabiliyoruz
    cout.operator<<(x).operator<<(d).operator<<(flag);


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

Myclass g;

//.cpp
void Myclass::func(){
    *this = g; // gecerli
}

void Myclass::foo() const{
    *this = g; // const this pointer oldguu için gecersiz
    this->mx = 20; // gecersiz
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass *f1();
    Myclass &f2();

    Myclass *f3()const;
    Myclass &f4()const;

    const Myclass *f5()const;
    const Myclass &f6()const;

private:
    int mx, my;
};

Myclass *Myclass::f1(){
    return this;
}

Myclass &Myclass::f2(){
    return *this;
}

Myclass *Myclass::f3()const{
    return this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}

//geri donusun const olması lazımki gecerli olsun
Myclass &Myclass::f4()const{
    return *this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}


const Myclass *Myclass::f5()const{
    return this;
    //const T*  ----> const T*
}

const Myclass &Myclass::f6()const{
    return *this;
}

int main()
{
    Myclass m1;
    m1.f1();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();

private:
    int mx, my;
};

Myclass gm;

void Myclass::func(){
    this = &gm; // sentaks hatası
    //this R value expr dir
    //this pointer kendisi const dur bu yüzden gecersizdir
}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

Inline fonksiyonlar


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int); // inline buradaa olabilir

private:
    int mx, my;
};

inline int Myclass::func(int c){
    return c;
}



int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int c){
        return c;
    }

private:
    int mx, my;
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

//implicity inline fonksiyon
constexpr int func(int x)
{
    return x;
}



/*********************************************/
/*********************************************/

neler inline olaarak tanımlanır


sınıfın

  nonstatic member function
  const
  non const

static member function


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    static int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    friend int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


constructor / destructor

special member functions


constructor ismi sınıfın ismi ile aynı olmak zorunda
ctor geri donus diye bir kavramı yok
ctor uye fonksiyon olamaz
global veya sınıfın static uye fonksiyonu olamaz
ctor overload edilemez
ctor sınıfın public veya private fonksiyonu olabilir




class Myclass{

public:
     Myclass();
};




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
     Myclass();
     Myclass(int);
     Myclass(double);
     Myclass(int, int);
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
private:
    Myclass();

public:
    // Myclass();

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass();
    void func();

};


int main()
{
    Myclass m;
    m.func();
    m.Myclass(); // sentaks hatası ctor cagrılmaz boyle

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass()const; // ctor const fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    static Myclass(); // ctor static fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass(){
        //inline olarak header içinde tanımlayabilirim
    }

};


//.cpp inline oalrak tanımladım
Myclass::Myclass(){
    //inline olarak
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


default ctor

parametresi yoktur
yada parametresi var ama varsayılan argüman alıyor ise hepsi

default constructor == varsayilan kurucu işlev




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    //Myclass();
    Myclass(int x = 0);

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

//derleyici bizim sınıfn default ctor yazar
class Myclass{

public:


};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


#include <iostream>

using namespace std;


//.hpp

//derleyici artık senın ıcın ctor yazmaz
class Myclass{

public:
    Myclass(int);

};


int main()
{
    Myclass m; //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

destructor


sınıfın nonstatic uye fonksiyon
ismi sınıgın ismi ile aynı ~ (tilda karateri olması lazım)  ~Myclass()
geri donus degeri kavramı yok
dtor overload edilmez
dtor parametresi yoktur olamaz
dtor const olmaz
dtor static ve global olamaz



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{
    Myclass m;

    m.~Myclass(); // dtor cagra bilirim

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(int x, int y); //ctor
    //defautl olarak ctor olmak zorunda değil

    //ama default olarak dtor olmak zorunda

};


int main()
{
    Myclass m(2, 3);

    m.~Myclass();

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

//global nesneler main baslamdan once hayata gelir

Myclass m;


int main()
{
    cout << "mian basladi\n";

    cout << "&m : " << &m << endl;

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}


void func(){
    static int cnt = 0;

    cout << "func islebine yapilan  " << ++cnt << ". cagri\n";

    static Myclass m;
}


int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        func();
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        static Myclass m;
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    {
        Myclass m;
        cout << "main devam ediyor 1\n";
    }

    cout << "main devam ediyor 2\n";

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    if(1){
        Myclass m1;
        if(2){
            Myclass m2;
        }
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[10];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    static int x = 0;
    cout << x++ << " ";
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[50];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    auto p = new Myclass;

    cout << "main devam ediyor 1\n";
    cout << "main devam ediyor 2\n";

    //delete p;

    cout << "main devam ediyor 3\n";
    cout << "main devam ediyor 4\n";
    delete p;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass *p = &m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    auto &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass &r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    //copy ctor cagrılıyor
    //ileriki derlerde cevabımızı alacaz
    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass m2{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır


    Myclass a[10]; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass b[10]{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass mx{}; //nesne tanımı
    Myclass my(); //bir fonksiyon bildirimidir dikkat


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m; //sentaks hatası
    Myclass m1(2); //parametreli ctor cagrılır // direct initilazation


    Myclass m2{22}; // paramterli ctor cagır // uniform initilazation
    //modern C++ -- C++11


    Myclass m3 = 30; // copy initilization -- ctor argüman olarak gönderilir

    return 0;
}

/*********************************************/
/*********************************************/

explicit ctor

genelde tek aprametreli ctorlar olur


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    explicit Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m = 3; //copy init.. sentaks hatsı olacak
    //ileride görecez


    return 0;
}

/*********************************************/
/*********************************************/

ctor overloading



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass (int) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(double x){
        cout << "Myclass (double) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(int, int){
        cout << "Myclass (int, int) ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1{1.3};
    Myclass m2{22};
    Myclass m3{2, 3};
    Myclass m4{2.0f}; //
    //Myclass m5{2u}; // sentaks hatası



    return 0;
}

/*********************************************/
/*********************************************/


constructor initializer list // güncel ismi
member initializer list (M.I.L syntax) //eski isimlendirme



non-static data memberlara ilk deger verme sentaksı


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int x, y;
    double dval;

};

//.cpp
Myclass::Myclass()
{
    x = 10; //ilk deger verme olmaz, atama olur
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int &r;
    const int x;

};

int g = 10;

//.cpp
Myclass::Myclass()
{
    r = g; //sentaks hatası ilk deger vermiş olmyız

    x = 5; //sentaks hatası ilk deger vermiş olmyız
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/


initializer_list --> C++ standard list sınıfıdır -- sınıf türü


constructor initializer list ile karıstımraylım


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10), my(20), mz(30) //constructor initializer list ** M.I.L
{
    cout << mx  << " " << my  << " " << mz << "\n";
}


int main()
{

    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10) //constructor initializer list ** M.I.L
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx{10}, my{}, mz{20} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        for(int i = 0; i < 10; ++i)
            cout << a[i] << "  ";
        cout << "\n";
    }

private:
    int a[10];

};


//.cpp
Myclass::Myclass() : a{1, 2, 3, 4, 5}
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

int f1(){return 1;}
int f2(){return 2;}
int f3(){return 3;}


//.cpp
Myclass::Myclass() : mx{f1()}, my{f2()}, mz{f3()} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    //Myclass(int a, int b) : mx{a}, my{b}
    Myclass(int a, int b) : mx{a}, my{b}{} // böyle yazmam lazım

    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

//.cpp


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


delete  anahtar sözcük

modern C++ ile fonksiyon silme aracı eklendi

fonksiyonu delete edebiliriz ama cagrı yapamayız



#include <iostream>

using namespace std;

void func(int x, int y) = delete;

int main()
{
    func(1, 2); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//3 tane overload fonksiyon var delete edilende buna dahildir
void func(int);
void func(double) = delete;
void func(int *);

int main()
{
    func(1);
    func(2.3); // sentaks hatası cagrı yapamadıgından

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//Mulakat sorusu
//bir fonksiyonun sadece int argumanlarla cagrılmasına olanak veren bir yapı olusturun

void func(int);

template<typename  T>
void func(T x) = delete;

int main()
{
    func(2);
    func(3.); // sentaks hatası
    func(2.F); // sentkas hatsı
    func(3U); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/


default //C++11

bir sınıfın üye fonksiyonunu default edilmesi
yanlızca sınıfınn üye fonksiyonlarını default edebilirim


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default; // derleyici bu fonksiyonu benim içiin yaz
    ~Myclass() = default;
};

int main()
{

    return 0;
}


/*********************************************/
/*********************************************/

C++11

default member initialization
in-class initialization


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    //T mx = expr;
    //T mx{expr};
    //T mx(expr) // bunda sentaks hatası
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    int my{20}; // hatta fonksiyon cagrısı ilede ilk deger verebilirim
    //int mz(30); // sentaks hatası

    int ma[5] = {1, 2, 3, 4, 5};
    int mb[] = {1, 2, 3, 4, 5}; // gecersiz dizi boyutu vermek zorundayiz
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


int mg;

//hpp
class Myclass{
public:

private:
    int *p = &mg;
    int &r = mg;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*
    Myclass()
    {
        cout << "default ctor\n";
    }*/

    Myclass() = default;


private:
    int mx = 10, my = 20;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*Myclass()
    {

    }*/

    Myclass() = default;

    void print()const{
        cout <<"mx = " << mx << "\n";
        cout <<"my = " << my << "\n";
    }


private:
    int mx = 10, my = 20;
};

int main()
{
     Myclass m;
     m.print();

    return 0;
}

/*********************************************/
/*********************************************/

C++11

mutable  anahtar sözcüğü  ---> değiştirilebilir demek



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    void func()const
    {
        ++count;
    }

private:
    mutable int count;
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


not declared  ---- user declared --- implicity declared


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass(int);
    //burada default ctor yoktur -- not declared durum

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


user declared

 defined
 defaulted
 deleted


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    //Myclass(); //user declared -- defined
    //Myclass(){}; //user declared
    //Myclass() = default; -- defaulted
    Myclass() = delete; //--deleted

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



implicity declared

2 ayrılır

defaulted
deleted





#include <iostream>

using namespace std;

//hpp
class Member{
public:
    Member(int, int);

};

class Myclass{

private:
    Member mx;
};

int main()
{
    Myclass m; //implicity deleted default

    return 0;
}

/*********************************************/
/*********************************************/

copy constructor --- kopyalayan kurucu işlev


x ve y T sınıfı turunden nesneler

T x = y;

copy ctor durumlar

Myclass m2 = m1;
Myclass m2(m1);
Myclass m2{m1};



void func(Myclass m)

Myclass mx;
func(mx); // m nesenesi hayata gelir iken mx nesnesi için copy ctor cagıralacak ve hayata gelecek


Myclass g;

Myclass func()
{

   return g;

}

*****************************************************


derleyici tarafından yazılan copy ctor

1- sınıfın nonstatic, public üye fonksiyonudur
2- inline olaarak tanımlanmış kabul edilir
3- şu imzaya sahiptir

   Myclass(const Myclass &r);

   Myclass x = y;



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : a{other.a}, b{other.b}
    {

    }

private:
    int a;
    double b;

};


int main()
{
    Myclass m1;

    ///
    Myclass m2 = m1;


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : mx{other.mx}, md{other.md}
    {
        cout << "Myclass copy ctor\n";
    }

    void print()const
    {
        cout << "mx  = " << mx << " md = " << md << "\n";
    }

    void set(int x, double d){
        mx = x;
        md = d;
    }

private:
    int mx = 10;
    double  md = 2.3;

};


int main()
{
    Myclass m1;
    m1.print();
    m1.set(22, 1.2);
    m1.print();


    Myclass m2 = m1;
    m2.print();
    m2.set(33, 5.5);
    m2.print();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    Myclass m2 = m1; // m2 icin copy ctor cagrılacak
    cout << "&m2    :  " << &m2 << endl;
    /*
    Myclass m3(m1); // m3 icin copy ctor cagrılacak
    Myclass m4{m1};// m4 icin copy ctor cagrılacak
    auto m5{m1};  // m5 icin copy ctor cagrılacak
    */

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};

void func(Myclass mf)
{
    cout << "func islevi cagrildi\n";
}


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    func(m1);
    cout << "main devam ediyor\n";

    _getch();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "constructur this : " << this << "\n";
        cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep
    MyString(const MyString &other) : mlen{other.mlen}
    {
        cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "the address of allocated block : " << (void *) mp << "\n";
        cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }


    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString ms("Orhan OZTURK");
    std::cout << "length ::  " << ms.length() << "\n";
    ms.print();
    func(ms);
    _getch();

    //derleyici yazar ise shalow copy ctor
    //aynı veriyi kullan demek

    //burada yapmamız gerekn iki tane farklı yer olmaası gerekli
    //bu sebepten copy ctor bizim yazmamız lazım

    ms.print();



    return 0;
}

/*********************************************/
/*********************************************/





































































































































































































































































































































































































































































































































