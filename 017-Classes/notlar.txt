
Classes -- Sınıflar


data abstraction -- veri soyutlama

problem domainde ki varlıkları. Programalma dilinde yazılımsal olarak temsil etmektir.


user defined type

ikiside sınıf anlamına gelmektedir

class
struct


class definition -- tanımı
class declaration --- bildirimi

//boş sınıflar

class Myclass{

};

struct Mydata {

};


---------------------------

//class Tag
class Myclass{
    //bildirimler
    //memberlar
};




class'ın memberları 3 kategoride olabilir


1- data member -- veri ogeleri
   a- non-static data member
   b- static data members

2- member functions -- üye fonksiyonlar
   a- non-static member functions
     1-non-const member functions
     2- const member functions
   b- static member functions

3- member type -- type members - nested types



Ornek

//class Tag
class Myclass{
    int x, y;
    static double dval;
    void func();
    static int foo();
    typedef int Word;
    enum class Color{White, Black};
};


***************************************************


scope --kapsam

c de scope kavramı

file scope
block scope
function prototype scope
function scope

C++ de scope kavramı

namespace scope
class scope
block scope
function prototype scope
function scope


*************************************************


name lookup ---> isim arama

context-control

access control -- erişim kontrolu




*************************************************

class scope ta bir isim hangi durumlarda aranır

a- isim nokta operatörünün (member selection - dot operator)
   sagında kullanılmış ise

b- isim ok operatörünün (member selection - arrow operator)
   sagında kullanılmış ise

c- isim :: çözünürlük operatörünün (member selection - scope resolution operator)
   sagında kullanılmış ise

ornek

clas Myclass{
  int y;
};

Myclass myclass;

myclass.y;
myclass->y;
myclass::y;


----------------------------------------

sınıflara erişimler (access specifier) için 3 tanım

public member
private member
protected member

bunların hepsi anahtar sözcük



#include <iostream>

using namespace std;

class Myclass{

public:
    //burası public memberlar

private:
    //burası private memberlar

protected:
    //burası protected memberlar

public:
    //burası public memberlar

};



int main()
{
    cout << "Hello World!" << endl;
    return 0;
}

/*********************************************/
/*********************************************/




class Myclass{
  //membler private alanda kabul edilir
};


struct Myclass{
  //membler public alanda kabul edilir
};



class Myclass{

    int x; // private alanda

public:


};

------------------------------------------------

public
   kısım olan isimler erişimi herekse açıktır

private
  clinetlara kapalı isimler ama sınıf kendisi kendi içinde kullanabileceği isimler

protected
  inheritance (miras kalıtım) oldugu yerlerde sınıfın memberlarına erişim izni vardır
  eger kalıtım yok ise private özelliğine sahip olmus olur




#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;

};



int main()
{
    Myclass myclass;

    myclass.x;
    return 0;
}

/*********************************************/
/*********************************************/


soru gecerlimi -- Hayır

aynı scope aynı isim tanımlaması var

public ve private protected scope deil alan bildiri sadece


class Myclass{
public:
    int x;

private:
    int x();
    int y;

};


************************************************************

class veri elemanları


#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;
    double z;

};



int main()
{
    cout << "sizeof (Myclass) : " << sizeof (Myclass) << endl;
    return 0;
}

/*********************************************/
/*********************************************/

member function

//member function
class Myclass{
public:
    void func(int);
};



fonksiyon clasın dısın bildirilirse su isimleri alır

//global function
//free function
//stand-alone function

int foo(void);


/*****************************************/

Nedemek sınıfın üye fonksiyonu

fonksiyon özelliklerine sahip fakat sadece class scope da yer alması lazım


#include <iostream>

using namespace std;

//member function
class Myclass{
public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;

    m1.func(33);

    Myclass *m2 = new Myclass();

    m2->func(55);

    return 0;
}

/*********************************************/
/*********************************************/


neden private ile dışarıdan erişim yok

1- dışarıdan sınıfın kullanacak client sınıfın data memberlarının ne oldugunu bilmak zorunda değil
2- sınıfın data memberlarını client kodların erişimine çarsak kontrol elden gider



#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;
    Myclass *m2 = &m1;

    //her iki durumdada  m1'in func'ı cagrılır
    m1.func(3);
    m2->func(4);


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func();
};


int main()
{
    //bu fonksiyonı böyle cagırmak için Myclass nesnesi olması lazım
    Myclass::func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:
    void func();
};

void func(int);


//aynı siim tanımlamalar gecerlidir
//farklı scope oldugu için

//function overloading degildir scopelar farklı oldugu için

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:

    //overload edeilirim
    void func();
    void func(int);
    void func(int, int);
    void func(double);
};


int main()
{

    Data mydata;

    mydata.func();
    mydata.func(2);
    mydata.func(2, 5);
    mydata.func(2u); //sentaks hatası olur

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

class Data{
private:
    void func(int);

public:
    void func(double);
};


int main()
{

    Data mydata;

    //mydata.func(12.56); // gecerli
    //mydata.func(12); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/





//gecerlimi? Evet

int func(int);
int func(int);


//gecerlimi? Hayır

class Data{
public:
  void func(int);
  void func(int);
}


/*********************************************/
/*********************************************/

sınıfın üye fonksiyonları storage'a dahil değildir

#include <iostream>

using namespace std;

//soru
class Data{
public:
  void func(int);
  void foo(int);

private:
  int x, y;
};


int main()
{

    cout << "sizeof(Data) : " << sizeof (Data) << endl;

    return 0;
}

/*********************************************/
/*********************************************/


Myclass.hpp   --> class definition
Myclass.cpp   --> class declaration


#include <iostream>

using namespace std;

//.hpp
class Myclass {
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp

void Myclass::func(){
    //3
    if(1){
        //2
        if(1){
            //1
            //a  --> isim kullansaydım burada
            //1- ilk önce uye fonksiyonun içinde arar
            //2- class scope içinde arar
            //3- global alanda arar
        }
    }
}


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

int x = 20;

int main()
{
    int x = 10;

    cout << "x = " << x << endl;
    cout << "::x = " << ::x << endl;

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

int mx = 25;

//.cpp
void Myclass::func()
{
    int mx = 10;

    mx = 12; // yerel

    Myclass::mx = 22; // class mx

    ++::mx;

}

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp
void Myclass::func()
{
    mx = 12;

}

int main()
{
    Myclass m1, m2;

    //
    m1.func(); // burada mx, m1in mx'i
    m2.func(); // burada mx, m2 in mx'i


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo(int);

private:
    int mx, my;
};

void foo()
{
    //
}

//.cpp
void Myclass::func()
{
    foo(); //sentaks hatası
    ::foo(); // global fonksiyona erişirim çözünürlük operatoru ile

}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx, my;
};

//ben write - setter görevi görür
void foo(struct Data *p);

//ben alrım seni  oynama yapmam sende okuma - getter görevi görevi
void foo(const struct Data *p);


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //bunlara böyle hangisinini getter hengisinin setter oldugunu anlayamıyorum
    void func();
    void foo();
};

//.cpp


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp

void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();

    //iki ayrı fonksiyon olarak gecerlidir
    //const overloading
    void foo();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo(){
    mx = 10;
}

void Myclass::foo() const{
    mx = 12;
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

const üye fonksiyonları sınıfın nonstatic data type'larını değiştirmez


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    Myclass a;
    a.mx = 22;

    mx = 22; //    sentaks hatası
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp


int main()
{
    Myclass m1;
    //const Myclass m2;

    m1.foo();
    m1.func();
    m2.foo();
    m2.func(); // sentaks hatası

    /*
     * const T* ----> T* donusum yok
     * T* ------> const T* donusum var
     *
     */


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;
    void fuu()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    foo();
    //T*  ---> const T* donusum var
}

void Myclass::foo() const{
    func();// sentaks hatası
    //const T* ---> T* donusum yok
    fuu();
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


Üye fonksiyonları ve const overloading

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //const overloading
    void func();
    void func()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass::func()" << endl;
}

void Myclass::func() const{
    cout << "Myclass::func() const" << endl;
}


int main()
{
    Myclass m1;
    m1.func();

    //const Myclass m2;
    m2.func(); // const olan cagrılacaktı

    return 0;
}

/*********************************************/
/*********************************************/


this anahtar sözcüğüne ---- this pointer

this anahtar sözcüğü yanlızcana sınıfların
non-static üye fonksiyonları içinde kullanılır.



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    this; // nesnenin adresi
    *this; // nesnenşn kendisi

    mx = 10;// bunuda yazabiliriz
    this->mx = 20; // bunuda
    //ikiside aynı mx

    //iki foo da aynı
    //hiç bir fark yok
    foo();
    this->foo();

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    int mx = 10;

    //şimdi iki mx farklı biri local biri class data member
    mx = 20;
    this->mx = 30;
    Myclass::mx; // class scotaki mx

    (*this).mx = 34;

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

template<typename T>
struct ValCat {
    constexpr static const char *pstr {"PR value"};
};

template<typename T>
struct ValCat <T &>{
    constexpr static const char *pstr {"L value"};
};

template<typename T>
struct ValCat <T &&>{
    constexpr static const char *pstr {"X value"};
};

#define vcat(exp)  (std::cout<< "value category of \"" #exp "\" is : " << ValCat<decltype((exp))>::pstr << "\n");


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    vcat(this); /// r value expression
    vcat(*this);// l value expre
}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";
    foo();
}

void Myclass::foo(){
    cout << "Myclass sinifinin foo islevi cagrildi\n";
    cout << "this : " << this << "\n";
}

int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

void gf(Myclass *p){
    cout << "global gf islevi cagrildi  p : " << p << "\n";
}


void gf1(Myclass &p){
    cout << "global gf1 islevi cagrildi  p : " << &p << "\n";
}

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";

    //işte böyle global foksiyonlarda kullancak isek
    //this pointer kullanılır
    gf(this);
    gf1(*this);
}


int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass &f1();
    Myclass &f2();
    Myclass &f3();
    Myclass &f4();

private:
    int mx, my;
};


//.cpp
Myclass &Myclass::f1(){
    return *this;
}


int main()
{
    Myclass m1;
    m1.f1().f2().f3().f4();


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

int main()
{
    int x = 4;
    double d = 5.5;
    bool flag = false;


    cout << x << d << flag;
    //operator overloading
    //ileride


    //operator overloading olmasaydı
    //*this sayesinde bunu böyle kullanabiliyoruz
    cout.operator<<(x).operator<<(d).operator<<(flag);


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

Myclass g;

//.cpp
void Myclass::func(){
    *this = g; // gecerli
}

void Myclass::foo() const{
    *this = g; // const this pointer oldguu için gecersiz
    this->mx = 20; // gecersiz
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass *f1();
    Myclass &f2();

    Myclass *f3()const;
    Myclass &f4()const;

    const Myclass *f5()const;
    const Myclass &f6()const;

private:
    int mx, my;
};

Myclass *Myclass::f1(){
    return this;
}

Myclass &Myclass::f2(){
    return *this;
}

Myclass *Myclass::f3()const{
    return this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}

//geri donusun const olması lazımki gecerli olsun
Myclass &Myclass::f4()const{
    return *this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}


const Myclass *Myclass::f5()const{
    return this;
    //const T*  ----> const T*
}

const Myclass &Myclass::f6()const{
    return *this;
}

int main()
{
    Myclass m1;
    m1.f1();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();

private:
    int mx, my;
};

Myclass gm;

void Myclass::func(){
    this = &gm; // sentaks hatası
    //this R value expr dir
    //this pointer kendisi const dur bu yüzden gecersizdir
}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

Inline fonksiyonlar


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int); // inline buradaa olabilir

private:
    int mx, my;
};

inline int Myclass::func(int c){
    return c;
}



int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int c){
        return c;
    }

private:
    int mx, my;
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

//implicity inline fonksiyon
constexpr int func(int x)
{
    return x;
}



/*********************************************/
/*********************************************/

neler inline olaarak tanımlanır


sınıfın

  nonstatic member function
  const
  non const

static member function


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    static int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    friend int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


constructor / destructor

special member functions


constructor ismi sınıfın ismi ile aynı olmak zorunda
ctor geri donus diye bir kavramı yok
ctor uye fonksiyon olamaz
global veya sınıfın static uye fonksiyonu olamaz
ctor overload edilemez
ctor sınıfın public veya private fonksiyonu olabilir




class Myclass{

public:
     Myclass();
};




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
     Myclass();
     Myclass(int);
     Myclass(double);
     Myclass(int, int);
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
private:
    Myclass();

public:
    // Myclass();

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass();
    void func();

};


int main()
{
    Myclass m;
    m.func();
    m.Myclass(); // sentaks hatası ctor cagrılmaz boyle

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass()const; // ctor const fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    static Myclass(); // ctor static fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass(){
        //inline olarak header içinde tanımlayabilirim
    }

};


//.cpp inline oalrak tanımladım
Myclass::Myclass(){
    //inline olarak
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


default ctor

parametresi yoktur
yada parametresi var ama varsayılan argüman alıyor ise hepsi

default constructor == varsayilan kurucu işlev




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    //Myclass();
    Myclass(int x = 0);

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

//derleyici bizim sınıfn default ctor yazar
class Myclass{

public:


};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


#include <iostream>

using namespace std;


//.hpp

//derleyici artık senın ıcın ctor yazmaz
class Myclass{

public:
    Myclass(int);

};


int main()
{
    Myclass m; //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

destructor


sınıfın nonstatic uye fonksiyon
ismi sınıgın ismi ile aynı ~ (tilda karateri olması lazım)  ~Myclass()
geri donus degeri kavramı yok
dtor overload edilmez
dtor parametresi yoktur olamaz
dtor const olmaz
dtor static ve global olamaz



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{
    Myclass m;

    m.~Myclass(); // dtor cagra bilirim

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(int x, int y); //ctor
    //defautl olarak ctor olmak zorunda değil

    //ama default olarak dtor olmak zorunda

};


int main()
{
    Myclass m(2, 3);

    m.~Myclass();

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

//global nesneler main baslamdan once hayata gelir

Myclass m;


int main()
{
    cout << "mian basladi\n";

    cout << "&m : " << &m << endl;

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}


void func(){
    static int cnt = 0;

    cout << "func islebine yapilan  " << ++cnt << ". cagri\n";

    static Myclass m;
}


int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        func();
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        static Myclass m;
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    {
        Myclass m;
        cout << "main devam ediyor 1\n";
    }

    cout << "main devam ediyor 2\n";

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    if(1){
        Myclass m1;
        if(2){
            Myclass m2;
        }
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[10];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    static int x = 0;
    cout << x++ << " ";
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[50];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    auto p = new Myclass;

    cout << "main devam ediyor 1\n";
    cout << "main devam ediyor 2\n";

    //delete p;

    cout << "main devam ediyor 3\n";
    cout << "main devam ediyor 4\n";
    delete p;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass *p = &m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    auto &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass &r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    //copy ctor cagrılıyor
    //ileriki derlerde cevabımızı alacaz
    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass m2{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır


    Myclass a[10]; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass b[10]{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass mx{}; //nesne tanımı
    Myclass my(); //bir fonksiyon bildirimidir dikkat


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m; //sentaks hatası
    Myclass m1(2); //parametreli ctor cagrılır // direct initilazation


    Myclass m2{22}; // paramterli ctor cagır // uniform initilazation
    //modern C++ -- C++11


    Myclass m3 = 30; // copy initilization -- ctor argüman olarak gönderilir

    return 0;
}

/*********************************************/
/*********************************************/

explicit ctor

genelde tek aprametreli ctorlar olur


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    explicit Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m = 3; //copy init.. sentaks hatsı olacak
    //ileride görecez


    return 0;
}

/*********************************************/
/*********************************************/

ctor overloading



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass (int) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(double x){
        cout << "Myclass (double) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(int, int){
        cout << "Myclass (int, int) ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1{1.3};
    Myclass m2{22};
    Myclass m3{2, 3};
    Myclass m4{2.0f}; //
    //Myclass m5{2u}; // sentaks hatası



    return 0;
}

/*********************************************/
/*********************************************/


constructor initializer list // güncel ismi
member initializer list (M.I.L syntax) //eski isimlendirme



non-static data memberlara ilk deger verme sentaksı


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int x, y;
    double dval;

};

//.cpp
Myclass::Myclass()
{
    x = 10; //ilk deger verme olmaz, atama olur
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int &r;
    const int x;

};

int g = 10;

//.cpp
Myclass::Myclass()
{
    r = g; //sentaks hatası ilk deger vermiş olmyız

    x = 5; //sentaks hatası ilk deger vermiş olmyız
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/


initializer_list --> C++ standard list sınıfıdır -- sınıf türü


constructor initializer list ile karıstımraylım


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10), my(20), mz(30) //constructor initializer list ** M.I.L
{
    cout << mx  << " " << my  << " " << mz << "\n";
}


int main()
{

    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10) //constructor initializer list ** M.I.L
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx{10}, my{}, mz{20} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        for(int i = 0; i < 10; ++i)
            cout << a[i] << "  ";
        cout << "\n";
    }

private:
    int a[10];

};


//.cpp
Myclass::Myclass() : a{1, 2, 3, 4, 5}
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

int f1(){return 1;}
int f2(){return 2;}
int f3(){return 3;}


//.cpp
Myclass::Myclass() : mx{f1()}, my{f2()}, mz{f3()} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    //Myclass(int a, int b) : mx{a}, my{b}
    Myclass(int a, int b) : mx{a}, my{b}{} // böyle yazmam lazım

    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

//.cpp


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


delete  anahtar sözcük

modern C++ ile fonksiyon silme aracı eklendi

fonksiyonu delete edebiliriz ama cagrı yapamayız



#include <iostream>

using namespace std;

void func(int x, int y) = delete;

int main()
{
    func(1, 2); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//3 tane overload fonksiyon var delete edilende buna dahildir
void func(int);
void func(double) = delete;
void func(int *);

int main()
{
    func(1);
    func(2.3); // sentaks hatası cagrı yapamadıgından

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//Mulakat sorusu
//bir fonksiyonun sadece int argumanlarla cagrılmasına olanak veren bir yapı olusturun

void func(int);

template<typename  T>
void func(T x) = delete;

int main()
{
    func(2);
    func(3.); // sentaks hatası
    func(2.F); // sentkas hatsı
    func(3U); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/


default //C++11

bir sınıfın üye fonksiyonunu default edilmesi
yanlızca sınıfınn üye fonksiyonlarını default edebilirim


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default; // derleyici bu fonksiyonu benim içiin yaz
    ~Myclass() = default;
};

int main()
{

    return 0;
}


/*********************************************/
/*********************************************/

C++11

default member initialization
in-class initialization


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    //T mx = expr;
    //T mx{expr};
    //T mx(expr) // bunda sentaks hatası
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    int my{20}; // hatta fonksiyon cagrısı ilede ilk deger verebilirim
    //int mz(30); // sentaks hatası

    int ma[5] = {1, 2, 3, 4, 5};
    int mb[] = {1, 2, 3, 4, 5}; // gecersiz dizi boyutu vermek zorundayiz
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


int mg;

//hpp
class Myclass{
public:

private:
    int *p = &mg;
    int &r = mg;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*
    Myclass()
    {
        cout << "default ctor\n";
    }*/

    Myclass() = default;


private:
    int mx = 10, my = 20;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*Myclass()
    {

    }*/

    Myclass() = default;

    void print()const{
        cout <<"mx = " << mx << "\n";
        cout <<"my = " << my << "\n";
    }


private:
    int mx = 10, my = 20;
};

int main()
{
     Myclass m;
     m.print();

    return 0;
}

/*********************************************/
/*********************************************/

C++11

mutable  anahtar sözcüğü  ---> değiştirilebilir demek



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    void func()const
    {
        ++count;
    }

private:
    mutable int count;
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


not declared  ---- user declared --- implicity declared


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass(int);
    //burada default ctor yoktur -- not declared durum

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


user declared

 defined
 defaulted
 deleted


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    //Myclass(); //user declared -- defined
    //Myclass(){}; //user declared
    //Myclass() = default; -- defaulted
    Myclass() = delete; //--deleted

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



implicity declared

2 ayrılır

defaulted
deleted





#include <iostream>

using namespace std;

//hpp
class Member{
public:
    Member(int, int);

};

class Myclass{

private:
    Member mx;
};

int main()
{
    Myclass m; //implicity deleted default

    return 0;
}

/*********************************************/
/*********************************************/

copy constructor --- kopyalayan kurucu işlev


x ve y T sınıfı turunden nesneler

T x = y;

copy ctor durumlar

Myclass m2 = m1;
Myclass m2(m1);
Myclass m2{m1};



void func(Myclass m)

Myclass mx;
func(mx); // m nesenesi hayata gelir iken mx nesnesi için copy ctor cagıralacak ve hayata gelecek


Myclass g;

Myclass func()
{

   return g;

}

*****************************************************


derleyici tarafından yazılan copy ctor

1- sınıfın nonstatic, public üye fonksiyonudur
2- inline olaarak tanımlanmış kabul edilir
3- şu imzaya sahiptir

   Myclass(const Myclass &r);

   Myclass x = y;



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : a{other.a}, b{other.b}
    {

    }

private:
    int a;
    double b;

};


int main()
{
    Myclass m1;

    ///
    Myclass m2 = m1;


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : mx{other.mx}, md{other.md}
    {
        cout << "Myclass copy ctor\n";
    }

    void print()const
    {
        cout << "mx  = " << mx << " md = " << md << "\n";
    }

    void set(int x, double d){
        mx = x;
        md = d;
    }

private:
    int mx = 10;
    double  md = 2.3;

};


int main()
{
    Myclass m1;
    m1.print();
    m1.set(22, 1.2);
    m1.print();


    Myclass m2 = m1;
    m2.print();
    m2.set(33, 5.5);
    m2.print();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    Myclass m2 = m1; // m2 icin copy ctor cagrılacak
    cout << "&m2    :  " << &m2 << endl;
    /*
    Myclass m3(m1); // m3 icin copy ctor cagrılacak
    Myclass m4{m1};// m4 icin copy ctor cagrılacak
    auto m5{m1};  // m5 icin copy ctor cagrılacak
    */

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};

void func(Myclass mf)
{
    cout << "func islevi cagrildi\n";
}


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    func(m1);
    cout << "main devam ediyor\n";

    _getch();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "constructur this : " << this << "\n";
        cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "the address of allocated block : " << (void *) mp << "\n";
        cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }


    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString ms("Orhan OZTURK");
    std::cout << "length ::  " << ms.length() << "\n";
    ms.print();
    func(ms);
    _getch();

    //derleyici yazar ise shalow copy ctor
    //aynı veriyi kullan demek

    //burada yapmamız gerekn iki tane farklı yer olmaası gerekli
    //bu sebepten copy ctor bizim yazmamız lazım

    ms.print();



    return 0;
}

/*********************************************/
/*********************************************/


 assignment operator function ---> eski ismi buydu
 copy assignment function ==> yeni

 T x;
 T y;

  x = y;  --> copy assignment function cagrılıyor

derleyici bizim için  public inline static fonksiyon olarak yazar


Derleyicinin yazdıgı copy assignment function


class Myclass{
 T t;
 U u;

public:
    Myclass &operator=(const Myclass &other)
    {
       t = other.t;
       u = other.u;


       return *this;
    }
}

 m1 = m2;

arka tarafta donen olay bu

 m1.operator=(m2);



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    void func()
    {
        cout << "Myclass::func() this = " << this << "\n";
    }
};

int main()
{
    Myclass x, y;
    cout << "&x = " << &x << "\n";

    //x = y;  // copy assignment func.

    x.operator=(y).func();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
public:
    Counter() = default;
    Counter(int x) : mx{x}{}

    void print()const{
        cout << "mx = " << mx << "\n";
    }

    void set(int val)
    {
        mx = val;
    }

private:
    int mx = 0;
};


int main()
{
    Counter c1 { 123 };
    Counter c2 { 566 };

    c1.print();
    c2.print();

    //c1 = c2;
    //c1.operator=(c2);

    (c1 = c2).print();
    c1.print();

    c1.operator=(c2).print();



    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
public:
    Counter() = default;
    Counter(int x) : mx{x}{}

    void print()const{
        cout << "mx = " << mx << "\n";
    }

    void set(int val)
    {
        mx = val;
    }

    Counter &operator=(const Counter &other)
    {
        cout << "operator=(const Clunter &) called this : " << this << "\n";
        cout << "&other    =    " << &other << "\n";

        mx = other.mx;

        return *this;
    }

private:
    int mx = 0;
};


int main()
{
    Counter c1, c2, c3, c4;
    Counter c5 { 566 };

    //c1 = c2 = c3 = c4 = c5;

    c1.operator=(c2.operator=(c3.operator=(c4.operator=(c5))));


    c1.print();
    c2.print();
    c3.print();
    c4.print();
    c5.print();


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "constructur this : " << this << "\n";
        //cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        //cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }

    //copy assasignment func
    //deep copy
    MyString &operator=(const MyString &other)
    {
        if(this == &other)
            return *this;

        free(mp); // kendisne atama yapilan nesne önce kendi kaynagını geri vermeli
        mlen = other.mlen;

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);

        return *this;
    }

    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString s1("Orhan OZTURK");
    s1.print();

    s1 = s1; // kendisine atama  == self-assignment

    s1.print();

    _getch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    ~Myclass();
    Myclass(const Myclass &other);
    Myclass &operator=(const Myclass &other);
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


RAII


Big three (buyuk uclu)

Destructor  --- alinan yerleri yerleri geri verme
Copy constructur  --- kaynak kopyalama ama deep copy ihtiyac var
assignment op. function  -- kaynak kopyalama ama deep copy ihtiyac var


Big Five

move ctor
move assasignment


/*********************************************/

move semantics --- taşıma semantiği

move ctor

kopyalanacak nesnenin hayatının bitmek üzere oldugundan emin oldgumuzda
move ctor ve ya copy işin içine girer

yaptıgı şey diger nesnenin kaynağını çalmak

R value oldugunda devreye girer move semantics

-------------

move assignment da

aynı sekilde move ctor gibi

kopyalanacak nesnenin hayatının bitmek üzere oldugundan emin oldgumuzda
move copy işin içine girer

yaptıgı şey diger nesnenin kaynağını çalmak ama çalmadan öncec kendi kaynagını geri verir



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass(const Myclass &other);  // copy ctor Lvalue larda cagrılcak
    Myclass(Myclass &&); //move ctor PR ve X value için cagrılacak

    Myclass &operator=(const Myclass &other); //copy assignment Lvalue olması lazım
    Myclass &operator=(Myclass &&); //move assignment PR ve X value ile cagrılacak
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

class Myclass{};

void func(const Myclass &r) //lvalue
{
    cout << "func(const Myclass &)\n";
}

void func(Myclass &&r) // rvalue
{
    cout << "func(Myclass &&)\n";
}

int main()
{

    Myclass m;

    func(m);

    func(move(m)); // Rvalue

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &)
    {
        cout << "copy ctor\n";
    }

    Myclass(Myclass &&)
    {
        cout << "move ctor\n";
    }
};


int main()
{

    Myclass m1;

    //Myclass m2 {m1};
    Myclass m3 { move(m1)}; //bilerek isteyerek hayatını calıyorum m1'in

    return 0;
}

/*********************************************/
/*********************************************/

derleyici nasıl yazıyor

class Myclass {
public:
 Myclass(Myclass &&other) : mt(move(other.mt)), mu(move(other.mu))
 {}

 Myclass &operator=(Myclass &&other)
 {
   mt = std::move(other.mt);
   mu = std::move(other.mu);
 }

private:
 T mt;
 U mu;
};



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "constructur this : " << this << "\n";
        //cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        //cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }

    //move ctor
    //tasıyan krucu ıslev
    MyString(MyString &&other) : mlen{other.mlen}, mp{other.mp}
    {
       cout << "move ctor\n";
       other.mp =nullptr;
    }

    //copy assasignment func
    //deep copy
    MyString &operator=(const MyString &other)
    {
        if(this == &other)
            return *this;

        free(mp); // kendisne atama yapilan nesne önce kendi kaynagını geri vermeli
        mlen = other.mlen;

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);

        return *this;
    }


    //move assignment
    MyString &operator=(MyString &&other)
    {
        cout << "move assignment\n";

        if(this == &other)
            return *this;

        mlen = other.mlen;

        std::free(mp);
        mp = other.mp;
        other.mp = nullptr;

        return *this;
    }

    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString s1("Orhan OZTURK");
    s1.print();

    MyString s2{ std::move(s1)}; //move ctor
    MyString s3{"OZturk"};

    s2.print();

    s3 = move(s2);

    s3.print();

    return 0;
}

/*********************************************/
/*********************************************/


Modern C++ ile gelen önemli kural


not declared

user declared
   user declared --> defined
   user declared --> defaulted
   user declared --> deleted

implicity declared
   implicity declared  --> defaulted
   implicity declared  --> deleted


eger derleyici görevi gereği dilin kurallarına görevi
bir sınıfn özel bir uye fonksiyonu yazıyor ise (defualt ediyor ise)
yani bu fonksiyon (implicity declared) ise


derleyici bu kodu yazması gerektigi gibi yazarken
 dilin kuralları cignemiyor ise
  derleyici sentaks hatası vermez

yazacagı fonksiyonu delete eder.





#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Member{
public:
    Member(int);
};


class Myclass{

    //derleyici yeni standarlara  göre default ctor soyle yapıyor
    //Myclass() = delete;

private:
    Member mx;
};


int main()
{
    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Member{
private:
    Member();
public:

};


class Myclass{

    //derleyici yeni standarlara  göre default ctor soyle yapıyor
    //Myclass() = delete;

private:
    Member mx;
};


int main()
{
    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/

destructor yazmam gerekiyor ise

big 3
destructor
copy ctor
copy assasignment

big 5
move ctor
move assignment



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    Myclass(const Myclass &other) = delete;
    Myclass &operator=(const Myclass &other) = delete;

    //move func. açık ise
    //kopyalamaya kapalı taşımaya açık


private:

};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Member{
private:
    Member(Member &&){}

public:
    Member(){}
    Member(const Member &) {cout<<"Member copy ctor\n";}
};

class A{
    Member m;
    //move delete edilyor
};


int main()
{
    A a1;
    A a2(move(a1));

    return 0;
}

/*********************************************/
/*********************************************/

geçici nesenler --- temporary objects
conversion cunstructor
dinamik ömürlü nesneler


/*********************************************/

geçici nesenler --- temporary objects

oyle nesnesenler ki kodada belirli bir isimleri yok
bu nesnelerin ifadeleri yürütülmesinden sonra jayatları biter


örnek

   Myclass(); // bu bir geçici nesne default ctor ile olsuturlan
   Myclass(12, 22); //parametreli geçici nesne


geçici nesne olsuturan ifadeler R value Pr value expression dir



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(const Myclass &r)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    func(Myclass(2)); //tempraro object

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(const Myclass &r)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    Myclass m{2};

    func(m); //lvalue expr

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    Myclass m{2};

    func(Myclass(3));

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    func(Myclass{});

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }

};

void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladi\n";

    if(true){
        //life extension
        const Myclass &r = Myclass{12};
        cout << "Main devam ediyor 1\n";
        cout << "Main devam ediyor 2\n";
    }

    cout << "Main devam ediyor 3\n";

    return 0;
}

/*********************************************/
/*********************************************/

convertion constructor --- dönüştüren krucu işlev





#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
};

int main()
{
    Data mydata;

    mydata = 10;  //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
    Data(int);
};

int main()
{
    Data mydata;

    mydata = 10;

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
    Data(int);
};

int main()
{
    Data mydata;

    mydata = 10;

    //dereleyici sözde bir kod yazar bizim içn
    //geçici nesene olusturur
    //Data(10);// seklinde
    //ve derleyici söyle kod uretir
    mydata.operator=(Data(10));

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
private:
    int cnt;
public:
    Counter(): cnt{0}
    {
        cout << "default ctor this : " << this << "\n";
    }

    Counter(int val): cnt{val}
    {
        cout << "Counter int ctor val : " << val << "  this : " << this << "\n";
    }

    ~Counter()
    {
        cout << "Counter dtor this : " << this << "\n";
    }

    Counter &operator=(const Counter &other)
    {
        cout << "copy assignment this : " << this << " &other" << &other << "\n";
        cnt = other.cnt;

        return *this;
    }

};

int main()
{

    Counter c;

    c = 234; //Counter{234};

    //c.operator=(Counter(234));

    cout << "main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{

    Myclass m;

    m = 13; //Myclass{13}

    int ival = 10;
    func(ival);
    foo(ival);
    fuu(ival); //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

explicit anahtar sözcüğü

explicit ctor
bu ctor tür dönüşümü için kullanılabilir
ama bu dönüşüm tür donusturme operatoru ile yapılırsa


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{

    Myclass m;

    m = 13; //sentaks hatası explicit den

    int ival = 10;
    func(ival);//sentaks hatası explicit den
    foo(ival);//sentaks hatası explicit den


    return 0;
}

/*********************************************/
/*********************************************/







#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{
    Myclass m;

    m = static_cast<Myclass>(13); //Myclass{13}

    int ival = 10;
    func(static_cast<Myclass>(ival));
    foo(static_cast<Myclass>(ival));


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int); //explicit anahtar sözcüğü sadece hpp dosyasında kullanılır
};

//cpp


int main()
{

    Myclass m = 10;//copy ctor artık sentaks hatsı explicit oldugu



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int); //explicit anahtar sözcüğü sadece hpp dosyasında kullanılır

};

//cpp
Myclass::Myclass(int)
{
    //
}

int main()
{

    Myclass m = 10;//copy ctor artık sentaks hatsı explicit oldugu



    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx = 0, my = 0;
public:
    Myclass() = default;
    Myclass(int a, int b) : mx{a}, my{b}{}
    void print()const
    {
        cout << "mx = " << mx << " my = " << my << "\n";
    }
};


int main()
{
    //birden fazla parametrede olunca ortülü dönüşüm salanır
    //parametreli ctor explicit yapar isek sentaks hatası alırız

    Myclass m;

    m = {12, 17};

    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();

};

Myclass func()
{
    ///

    return {};
}

int main()
{

    Myclass m = {};


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    explicit Myclass(int)
    {
        cout << "Myclass int\n";
    }

    Myclass(double)
    {
        cout << "Myclass double\n";
    }
};

int main()
{

   int ival = 10;

   //Myclass m(ival); //ınt ctor cagrılır

   Myclass m = ival; ///double ctor cagrılır

    return 0;
}

/*********************************************/
/*********************************************/

Copy elision -- copy elimination

derleyici durumdan vazife çıkartarak
copyalama yapamadan kod üretir


söyle de denir

mandatory copy elision



#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }

};

void func(Myclass mx)
{
    cout << "func cagrildi\n";
}

int main()
{
  //C++11 ile eklenmiştir
    cout << "Main basladi\n";

    //Myclass m;

    //func(Myclass{});
    func(Myclass{10});

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other) = delete;


};

void func(Myclass mx)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladi\n";

    //Myclass m;

    //func(Myclass{});
    func(Myclass{10});

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }


};

//RVO => return value optimization
//C++11 ile mandatory copy elision

Myclass foo()
{
    return Myclass{10};
    //mx bu nesnenin yerine geçiyormuş gibi düşünün
}

int main()
{
    cout << "Main basladi\n";

    Myclass mx = foo();

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }

    void set1(int x)
    {
        //
    }

    void set2(int x)
    {
        //
    }
};

//RVO => return value optimization
//C++11 ile mandatory copy elision

//NRVO => named return value optimization
//yazacagımız bir cok fonksiyon bu kategoriye giriyor
//C++17 ile mandatory copy elision
Myclass foo()
{
    cout << "foo agrildi\n";
    Myclass m;

    cout << "foo devam ediyor\n";
    m.set1(22);
    m.set2(33);

    cout << "foo sona eriyor\n";

    return m;
}

int main()
{
    cout << "Main basladi\n";

    Myclass mx = foo();

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

dinamik omurlu nesneler uzerıne konusacaz
sınıfın static veri elemanları ve uye fonksiyonları



/*********************************************/


sınıfın static veri elemanları ve uye fonksiyonları

data members
   static
   nonstatic

member functions
  static
  nonstatic
     const
     nonconst

type members

--------------------------------------


sınıfın static veri elemanları


sınıfın static veri elemanları sınıfın kendisis ile ilgilidir



#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx, my, m1, m2;
    char str[12];
    double dval;

};

int main()
{
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx, my;
    double dval;
    static int sy;
    static int m1;
    static int sa[100];

};

int main()
{
//sınıfın static nesneleri boyutu arttırmaz
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri ogleri sıınıfın ıcınde bıldırılır ama tanımlanmaz
//bu veri elemanlarının cpp dosyasında ayrıca tanımlanmaları gereklidir

class Myclass{
public:
   static int mx;

};

//cpp


int main()
{
    Myclass::mx = 10; //sentaks hatası


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri ogleri sıınıfın ıcınde bıldırılır ama tanımlanmaz
//bu veri elemanlarının cpp dosyasında ayrıca tanımlanmaları gereklidir

class Myclass{
public:
   static int mx;

};

//cpp
//int Myclass::mx; //ilk degerinin böyle tnaımlaarım
//int Myclass::mx{}; //value init. edebilirim
//int Myclass::mx(); //sentaks hatası -- fonksiyon olarak gorur
//int Myclass::mx = 10; //gecerli
int Myclass::mx{10}; //gecerli
//int Myclass::mx(10); //gecerli

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri elemanları incomplete type olabilir

class Orhn;

class Myclass{
public:
   static Orhn mx; //mx incomplete type

};

//cpp

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
   Myclass m; //sentaks hatası -- cunku sizeof degerini derleyici bilmek sorunda

};

//cpp

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//sınıfın kendi türünden statik veri elemanı olabilirmi
//evet olabılır

//hpp
class Myclass{
public:
    static Myclass m; //gecerli --siof etkilenmedigi için

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static unsigned char buffer[]; //gecerli, eger static olmaydı gecersiz boyut bilgisinin verilmesi lazım

};

//cpp
//unsigned char Myclass::buffer[] = {'a', 'b'};
unsigned char Myclass::buffer[5];

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static int mx;
};

//cpp
int Myclass::mx{};

int main()
{
    cout << "Myclass::mx : " << Myclass::mx << "\n";

    Myclass::mx = 12;

    cout << "Myclass::mx : " << Myclass::mx << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    int x = 10;
    static int sx;
};

//cpp
int Myclass::sx{};

int main()
{
    Myclass m;

    m.x = 10; //gecerli
    m.sx = 12; //gecerli

    Myclass *p{&m};
    Myclass &r{m};

    p->sx = 22; //gecerli
    r.sx = 13; //gecerli

    //böyle kodlarla statik veri elemanlarını ulasmanız ve oynamanız tavsıye etmem

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static int x;
    static int sx;
};

//cpp
int x = 10; // bu x sınıfın static elemanı deglidir global degısken
int Myclass::x = 99;

int Myclass::sx = x;

int main()
{
    cout << "Myclass::sx : " << Myclass::sx << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


sınıfın
   const ve integral type (tamsayı türlerinden ) static
   veri öglerine sınıf içinde ilk deger verilebilir
   Bu durumda bu eri ögleri cpp dosyasında ayrıca tanımlanmasına gerek kalmaz
   tanımlandı olarak kabul edilir



#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    const static int x = 10; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const int x = 10; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const double x = 10.0; //gecerli degil (integral type) tam sayı olmadıgı için

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const bool flag = true; //gecerli, boolda bir tam sayi türü

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    const static int sx = 12;
    constexpr static int sy = 12;
    const static double sd = 1.2; //sentaks hatası
    constexpr static double st = 1.2; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <string>
#include <numeric>
#include <ios>

using namespace std;


//hpp


int main()
{
    //static constexpt oalrak std kutuphanede cokca tnaım mevcut
    ios::boolalpha;
    ios::badbit;

    string::npos;

    numeric_limits<int>::digits;

    return 0;
}

/*********************************************/
/*********************************************/

 sınıfın static uye fonksiyonları
 static member functions

sınıfın static uye fonksiyonları this pointer'a sahip olmayan
yani bir instance'ın adresini gizlice almazlar
dolasıyla dogrudan bir instance icin (sınıfın nesnesi icin) vagrılmayan
sınıfnn geneli icin bir takım fayda saglaycak uye fonksiyonlardır




#include <iostream>

using namespace std;


//hpp
class Myclass{

public:
    void func(int, int);
};

int main()
{
    Myclass m;

    m.func(1, 2);// m nın adresi gizli oalrak func2a gidiyodu

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{

public:
    static int func(int); //bunun this poniterı yok
    //public ve private olaiblir
};

int main()
{
    Myclass m;

    Myclass::func(12); //bu sekılde cagrılır

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x)
    {
        return x+x;
    }
};

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x);
};

//cpp
//cpp dosyasında static keyword kullanılmayacak yoksa sentaks hatası
int Myclass::func(int x)
{
    return x+x;
}

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x);
};

//cpp
#define STATIC


STATIC int Myclass::func(int x)
{
    return x+x;
}

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{
private:
    int mx;

public:
    static void foo(int x)
    {
        mx = 10; //sentaks hatası
        //this pointer almadgı icin
        //sınıfn mx goremıyecek
        //bu namelookup hatası degil
        //derleyici hangi mx diye soruyor
    }

    int fuu()
    {
        mx = 10;
        this->mx = 10;
    }

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{
private:
    int mx;
    static int val;

public:
    static void foo(int x)
    {
        //mx = 10; //sentaks hatası
        val = 10; //gecerli
        //yada
        Myclass::val = 12;

    }

    void fuu()
    {
        mx = 10;
        Myclass::val = 12;
    }

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    void foo(int x)
    {
        //non static uye fonk.
        //iki sekilde cagırabilirim

        func();
        this->func();
    }

    void func()
    {

    }


};

//cpp

int main()
{
    Myclass m;

    m.foo(2);

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    static void foo(int x)
    {
        //non static uye fonk.
        //iki sekilde cagıramam
        //cunku this pointer yok

        //func();
        //this->func();

        //static uye fonksiyonu icinde static uye fonksiyonu cagırabilirim
        fuu();
    }

    void func()
    {

    }

    static void fuu()
    {

    }


};

//cpp

int main()
{
    Myclass m;

    m.foo(2);

    return 0;
}

/*********************************************/
/*********************************************/


Sınıfın static uye fonksiyonları dogrudan ismiyle
   sınıfın static veri elemnalarıı kullanabılır
   sınıfın statıc uye fonksiyonlarını cagarailir



Sınıfın static uye fonksiyonları dogrudan ismiyle
   sınıfın nonstatic veri elemnalarıı kullanamaz
   sınıfın nonstatıc uye fonksiyonlarını cagaramaz

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//soru 1 tahmin yurutun

//hpp
class Myclass{
    //sınıfın uye fonksiyonu const olabilirmi

    //Hayır sentaks hatası
    static void func()const
    {

    }

    /*
    void foo(const Myclass *this)const
    {

    }
    */

};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//soru 1 tahmin yurutun

//hpp
class Myclass{
private:
    int mx;

public:
    //olabilir
    static void func(Myclass &r)
    {
        r.mx = 10;
    }

    static void foo(Myclass *r)
    {
        r->mx =12;
    }

    static void foo(const Myclass *r)
    {
        //r->mx =12;
    }

    static void foo(const Myclass &r)
    {

    }



};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 2

//hpp
class Myclass{
private:
    static int mx;
    int my;

public:
    void func()const
    {
        mx = 10; //gecerli
        //my = 12;
    }
};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 3

//hpp
class Myclass{
private:
    static int mx;

public:
    //function overloading mi degilm i

    //EVET function  overloading burada var
    void func();
    static void func(int);

};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 3

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
};


//cpp

int main()
{
    Myclass m;

    m.func(11); //programcı boyle cagırd statıc oldugun bilmeden
    //sentaks hatası degil
    //ama cagrının m ile lakası yok

    Myclass::func(11); //bunla alakası yok yukarıdakı cagırını

    //iki turlude cagrılabılır
    //nesnee ile cagırmak sadece bir namelookup amacı ile kullanılır
    //sentaks hatası yok


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
    void func();

};


//cpp

int main()
{
    Myclass mx;

    mx.func(12); //static func.
    mx.func(); //non static func.



    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
    void func();

    void foo() //non static
    {
        func();
        func(12);
    }

};


//cpp

int main()
{
    Myclass m;

    m.foo();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//C++17

//hpp
class Myclass{
private:
    inline static int mx = 10;
    //derleyici bunu bir çok dosyasında olmasına karsı bir tane görecek
    //ve header dosyasında boyle tanımlamamıza izin verecek
};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//C++17

//hpp
class Date{
    static const int daytabs[];

public:
    static Date RandomDate(){
        daytabs[2];
        //acces erişimi oldugu için
    }
};

//bu statik veri elemanını direk olarak kullanabilirmi
Date RandomDate()
{
    daystabs[1];
    //acces erişim yok
}

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//iki tane ctor tanımlamak istiyor
//bunun için fabrika fonksiyonu yazarız

//burada derleyici bizim için default ctor olsutur

//hpp
class Complex{
private:
    Complex(double r, double i, int);
    Complex(double distance, double angle);

public:
    static Complex createCartesian(double r, int i)
    {
        return Complex(r, i, 0);
    }

    static Complex createPolar(double distance, double angle)
    {
        return Complex(distance, angle);
    }
};


//cpp

int main()
{
    auto c1 = Complex::createCartesian(2.1, 22);
    auto c2 = Complex::createPolar(1.2, 44);

    return 0;
}

/*********************************************/
/*********************************************/


singleton oruntusu
design pattern

pattern dilden bagımsızdır

object oriented design pattern

bu konu aslında şehir planlama dan gelir
ilk defa orada kullanılmıstır

bazı problem ortay cıkması ile aynı problemleri
czmek için bazı kalıplar üretilmiştir

bunlara design pattern denilmiştir

olusturdukları tasarım kalıpları sistematik sekilde dokumante etmişler


Gamma
Vilissides
Johnson
Helm


bunlara 4 kafadar olarak isimlendirmişler

Gang of four olarak isimlendirilir


23 tasarım kalibi vardır
GOF pattern debir


---------

baslangıc için daha raht veeglenceli kitap,
Head first design patterns
eric freeman

-----

modern C++ design
Andrei Alexandres

---------------------------------------------------


singleton pattern

bir sınıfın turunden tek bir nesne olacak
ve bu nesneye global acces soz konusu olacak


singleton pattern uygulamını birden fazla yöntemi var




#include <iostream>

using namespace std;


//hpp
class Singleton{
public:
    static Singleton *getInstance();

    //kopyalamaya karsı kapalı
    Singleton(const Singleton &) = delete;
    Singleton &operator=(const Singleton &) = delete;

    void func();
    void foo();

private:
    static Singleton *mp;
    Singleton();

};

//cpp
Singleton *Singleton::mp = nullptr;
Singleton *Singleton::getInstance()
{
    if(!mp)
        mp = new Singleton;
    return mp;
}


int main()
{
    auto ps = Singleton::getInstance();

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//scott meyers singleton pattern implemention

//kitap
//scott meyers Effective modern C++ = 11 ve 14 mevcut


//hpp
class Singleton{
private:
    Singleton();

public:
    static Singleton &getInstance()
    {
        static Singleton s; // fonksiyon ilk cagrıldıgında hayata gelir tekrar tekrar hayat gelmez
        //aynı nesne sürekli olarak geri döndürülücek

        return s;
    }

};

//cpp


int main()
{
    auto &s = Singleton::getInstance();

    auto &s1 = Singleton::getInstance();

    return 0;
}

/*********************************************/
/*********************************************/


mülakat sorusu

öyle bir sınıf olsuturun ki
sınıfın hayatta olan nesnelerin sayisini geri verecek
hayatta kalan veya hayatta olan nesnelerin sayısını sınıf bilecek






#include <iostream>
#include <string>

using namespace std;


//hpp
class Fighter{
public:
    Fighter()
    {
        ++ms_live_count;
        ++ms_total_count;
    }
    Fighter(std::string name, int age) : m_name{std::move(name)}, m_age{age}
    {
        ++ms_live_count;
        ++ms_total_count;
    }

    ~Fighter()
    {
        --ms_live_count;
    }

    Fighter(const Fighter &) = delete;
    Fighter &operator=(const Fighter &) = delete;

    int Age()const
    {
        return m_age;
    }

    std::string Name()const
    {
        return m_name;
    }

    void kill();
    void run();

    static int get_live_count();
    static int get_total_count();

private:
    static int ms_live_count;
    static int ms_total_count;

    std::string m_name = "isimsiz";
    int m_age = 0;

};

//cpp
#define STATIC

int Fighter::ms_live_count{};
int Fighter::ms_total_count{};

STATIC int Fighter::get_live_count()
{
    return ms_live_count;
}

STATIC int Fighter::get_total_count()
{
    return ms_total_count;
}



int main()
{
    cout << "Hayatta olan savasci sayisi : " << Fighter::get_live_count() << "\n";
    Fighter f1{"Orhan", 30};
    Fighter f2{"Ahmet", 22};

    cout << "Hayatta olan savasci sayisi : " << Fighter::get_live_count() << "\n";

    if(1)
    {
        auto pf1 = new Fighter { "Aleattin", 55};
        auto pf2 = new Fighter { "Seda", 21};

        cout << "Hayatta " << Fighter::get_live_count() << "  savasci var\n";
        cout << "Hayata gelmis toplam savasci sayisi  " << Fighter::get_total_count() << "\n";

        delete pf1;
        delete pf2;
    }

    cout <<  "\n";
    cout << "Hayatta " << Fighter::get_live_count() << "  savasci var\n";
    cout << "Hayata gelmis toplam savasci sayisi  " << Fighter::get_total_count() << "\n";

    /*
    Fighter x{f1};
    Fighter y{f2};
    */

    return 0;
}

/*********************************************/
/*********************************************/


scope leakage

void func()
{
  int x = foo();
  if(x > 10){

  }

  x //yanlıslıkla


}


C++17 ile
core syntax etkilenyen yeni bir if eklendi


if with initializer dir


#include <iostream>
#include <string>

using namespace std;

int func(int);

int main()
{
    //C++17
    if(auto y = 2; y > 10)
    {
        func(y);
    }
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <string>

using namespace std;

int func(int);

int main()
{
    //eskiden beri gelen bir özellik
    if(int y = 5)
    {
        func(y);
    }
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;


//hpp
class Fighter{
public:
    Fighter()
    {
        msvec.push_back(this);
    }

    Fighter(std::string name, int age) : m_name{std::move(name)}, m_age{age}
    {
        msvec.push_back(this);
    }

    ~Fighter()
    {
        /*
        auto iter = std::find(msvec.begin(), msvec.end(), this);

        if(iter != msvec.end())
            msvec.erase(iter);
        else
            std::cerr << "hata : arana deger bulunamadi\n";
        */

        //C++17 if with initilizer...
        if(auto iter = std::find(msvec.begin(), msvec.end(), this); iter != msvec.end())
            msvec.erase(iter);
        else
            std::cerr << "hata : arana deger bulunamadi\n";
    }

    Fighter(const Fighter &) = delete;
    Fighter &operator=(const Fighter &) = delete;

    void ask_help()
    {
        //range for loop
        //C++11 ile geldi

        cout << "Dusmanlar beni oldurecek\n";
        for(auto f : msvec){
              if(f != this)
                  cout << f->m_name << " ";
        }

        cout << "\nYardima kosun!!!!\n";

    }

    int Age()const
    {
        return m_age;
    }

    std::string Name()const
    {
        return m_name;
    }

    void kill();
    void run();

private:

    std::string m_name = "isimsiz";
    int m_age = 0;
    static std::vector<Fighter *> msvec;

};


//cpp
std::vector<Fighter*> Fighter::msvec{};


int main()
{
    Fighter f1{ "alican", 12};
    Fighter f2{ "kemal", 21};
    Fighter f3{ "hacer", 13};
    Fighter f4{ "muhammet", 55};

    auto pf1 = new Fighter { "hasan", 45};
    auto pf2 = new Fighter { "salih", 23};
    auto pf3 = new Fighter { "irem", 16};

    delete pf2;
    delete pf1;

    f1.ask_help();
    //alican, kemal, hacer, muhammet .... yardıma kosun ... dusmnalar beni oldurecek



    return 0;
}


/***************************************************/
/***************************************************/


 new operator
 array new operator
 delete
 array delete


new operator

tek bir nesne olusturan operator new dir

C++ da new opratoru soyle

void *operator new(size_t n)

operator new fonksiyonu ile yer elde etmede başarılı olursa

malloc ta oldugu gibi elde edilen adresi dönecek

başarısız olur ise exception handking mekanizması devre girer
bad alacotion mesajı verir


new operator yaptıgı sey arka trafta

new Point(1, 2, 3)

((Point *)(operator new(sizeof(Point)))->Point(1, 2, 3);


bu sayede dinamik omurlu nesneler olusturmus oluruz


#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p1 = new Point(2, 3, 5);
    Point *p2{ new Point(3, 6, 7) };

    auto *p3 = new Point();

    delete p;
    delete p1;

    return 0;
}



/***************************************************/
/***************************************************/

operator delete isimli fonksiyon


void operator delete(void *vp);

delete dinamik omurlu nesnelerin bellek bloklarını geri vermesini saglar
ve sınıfın destructorını cagırır


delete p

p->~Point();


1. eger nesne delete edilmez ise

 a- destructor cagrılmaz
 b- operator delete işlevi cagrılmaz

resource leak -- kaynak sızıntısı yasanır


2. dinamik omurlu ve hayatı bıten nesneyi gösteren poıinter dangling hale gelmiş olur






#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p2 = p;

    cout << "p : " << p << "\n";
    p->print();

    delete p;

    p->print();  //dangling pointer


    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p2 = p;  //copy ctor

    p2 = p;//copy assigment

    cout << "p : " << p << "\n";
    p->print();

    delete p;

    p2->print();  //dangling pointer -- tanımsız davranış olmus olur
    p->print();  //dangling pointer



    return 0;
}



/***************************************************/
/***************************************************/


array new
bir degil birden fazla nesne yi hayata getirmek için kullanılır





#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    int n;

    cout << "kac nesne : ";
    cin >> n;

    Point *p = new Point[n];

    //delete p; // tanımsız davranıs olur


    //array delete
    delete[]p;

    return 0;
}



/***************************************************/
/***************************************************/


smart pointer ve unique_ptr  devreye giriyor

delete kullanmadan belleklerini geri vermenizi saglar


bulundukları baslık dosyası

<memory>


modern C++ en onemli ögelerinden



#include <iostream>
#include "point.hpp"
#include <memory>

using namespace std;

int main()
{
    unique_ptr<Point> p{new Point(1, 2, 3)};
    p->print();
    p->set(2, 3 , 5);
    p->print();

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>
#include "point.hpp"
#include <memory>

using namespace std;

int main()
{
    unique_ptr<Point> p{new Point(1, 2, 3)};
    p->print();
    p->set(2, 3 , 5);
    p->print();

   // auto p2 = p; // copy ctor delete edilmiş

    auto p4 = move(p); // artık kaynagını p4 verildi p nin

    p4->print();

    return 0;
}



/***************************************************/
/***************************************************/

operator overloading  --- operator yüklemesi


bir sınıfın nesnesi bir operatorun operandı olmus ise
derleyici duurumdan vazife çıkartarak bunu fonksiyona cevirir

neden böyle bir araç var
programcının işini kolaylastırmak ıcın



run time maliyeti yok problem yasamayız
cunku bu işlem ceviri surecinde gercekleşir




#include <iostream>
#include <string>


using namespace std;

int main()
{
    string s1 {"Orhan"};
    string s2 {"Ozturk"};

    auto s3 = s1 + s2; //toplama operatorunu kullanıyorum

    if(s1 == s2){

    }

    return 0;
}



/***************************************************/
/***************************************************/


operator fonksiyonu

1- global operator function
2- member operator function
   non-static member function -- olmak zorunda

olablir



her operator overload edilemez


nokta operaotru
sizeof operatoru
:: scope resolution
.* operatoru
? : operatoru
typeid operatoru overload edilemez


overload edilebilne  operatorlerden bazıları

*
->
&
[]
()
tür donusturme
....




operator fonksiyonu nasıl tnaıumlanmalı

operator fonksiyonu ismi "operator" leyword taşıyacak bundan sonra hangi operator
overload ediliyor ise yazılacak

operator!
operator<

-------------------------

varsayilan argüman almazlar (default argüman)

sadece bir istisna hariç
function call () overload eden fonksiyon dışındaki hiç bir operator fonksiyonu
varsayılan argüman alamaz



----------------------------------------------------

#include <iostream>

using namespace std;

class Myclass{

};

//!x;


bool operator!(Myclass m);

//bir tane parametresi olmaz zorunda dır ! operatorunun

bool operator!(); //sentaks hatası
bool operator!(Myclass m1, Myclass m2); //sentaks hatası


int main()
{
    Myclass m;

    !m;

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator!()const;  //
    bool operator!(Myclass m)const;  // sentaks hatası
};

//!x;






int main()
{
    Myclass m;

    !m;

    return 0;
}



/***************************************************/
/***************************************************/


global fonksiyon olarak overload edilen unary operatorler tek parametre alacak
üye fonksiyon olarak overload edilen unary operatorler parametre almayacak

-----------------------------------------------------

#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator>(Myclass m1);
    bool operator>(Myclass m1, Myclass m2); //sentaks hatsı

};


bool operator>(Myclass m1); //sentaks hatası

bool operator>(Myclass m1, Myclass m2);




int main()
{
    Myclass m1, m2;

    auto m3 = m1 > m2;

    return 0;
}



/***************************************************/
/***************************************************/


global fonksiyon olarak overload edilen binary operatorler iki parametre alacak
üye fonksiyon olarak overload edilen binary operatorler bir parametre alacak


----------------------------------------------------------

bazır operatorlar bir veya iki operand alabilir


*x
x*y

+a
a+b

-b
a-b

&a
a&b



#include <iostream>

using namespace std;

class Myclass{
public:
    int &operator*(); //ıcerık operatoru
    //dereferens

};



class Matrix{
public:
    Matrix operator*(const Matrix &); // carpma operatoru

};



int main()
{
    Myclass m1, m2;

    *m1;

    Matrix mt1, mt2;

    auto mt3 = mt1 * mt2;

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Myclass{
public:


};

int &operator*(Myclass m); //ıcerık operatoru
//dereferens


class Matrix{
public:


};

Matrix operator*(const Matrix &, const Matrix &); // carpma operatoru



int main()
{
    Myclass m1, m2;

    *m1;

    Matrix mt1, mt2;

    auto mt3 = mt1 * mt2;

    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass operator*(Myclass)const;
    Myclass operator+(Myclass)const;
    Myclass operator-(Myclass)const;
    bool operator<(Myclass)const;

};


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1*m2 + m3 < m4;

    return 0;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass operator*(Myclass)const;
    Myclass operator+(Myclass)const;
    Myclass operator-(Myclass)const;
    bool operator<(Myclass)const;

};


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1 * m2 + m3 < m4;

    //derleyici

    //öncelik yönü
    //aslında soyle olcak derleyci tarafından

    fg = m1.operator*(m2).operator+(m3).operator<(m4);

    return 0;
}



/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

class Myclass{
public:


};

//global fonksiyonlar const olamaz

Myclass operator*(Myclass, Myclass);
Myclass operator+(Myclass, Myclass);
Myclass operator-(Myclass, Myclass);
bool operator<(Myclass, Myclass);


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1 * m2 + m3 < m4;

    //derleyici

    //öncelik yönü
    //aslında soyle olcak derleyci tarafından

    fg = operator<(operator+(operator*(m1,m2),m3),m4);

    return 0;
}



/***************************************************/
/***************************************************/




class ostream{
public:
  ostream &operator<<(int);
  ostream &operator<<(double);
  ostream &operator<<(long);


};

std::ostream &operator<<(std::ostream &, const std::string &s);


cout <<

-------------------------------------------


#include <iostream>

using namespace std;

class Counter{
public:
    Counter operator+(int)const;
};




int main()
{
    Counter c;

    auto cx = c + 5;  // 5 + c
    cx = c.operator+(5);
    cx = 5 + c; //sentaks hatası



    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Counter{
public:
    //Counter operator+(int)const;
};


Counter operator+(Counter, int);
Counter operator+(int, Counter);

int main()
{
    Counter c;

    auto cx = c + 5;  // 5 + c
    //cx = c.operator+(5);
    cx = 5 + c; //sentaks hatası



    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator<(const Myclass &other)const
    {
        cout << "Myclass::operator<(const Myclass &other)\n";
        cout << "this  :  " << this << "\n";
        cout << "&other =  " << &other << "\n";

        return true;
    }
};


int main()
{

    Myclass mx, my;

    cout << "&mx : " << &mx << "\n";
    cout << "&my : " << &my << "\n";

    bool b = mx < my;

    cout << "b = " << b << "\n";



    return 0;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:

};


bool operator<(const Myclass &a, const Myclass &b)
{
    cout << "global operator\n";
    cout << "&a  :  " << &a << "\n";
    cout << "&b =  " << &b << "\n";

    return true;
}

int main()
{

    Myclass mx, my;

    cout << "&mx : " << &mx << "\n";
    cout << "&my : " << &my << "\n";

    bool b = mx < my;

    cout << "b = " << b << "\n";



    return 0;
}



/***************************************************/
/***************************************************/


friend kaldık































































































































































































































































































































































































