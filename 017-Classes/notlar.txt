
Classes -- Sınıflar


data abstraction -- veri soyutlama

problem domainde ki varlıkları. Programalma dilinde yazılımsal olarak temsil etmektir.


user defined type

ikiside sınıf anlamına gelmektedir

class
struct


class definition -- tanımı
class declaration --- bildirimi

//boş sınıflar

class Myclass{

};

struct Mydata {

};


---------------------------

//class Tag
class Myclass{
    //bildirimler
    //memberlar
};




class'ın memberları 3 kategoride olabilir


1- data member -- veri ogeleri
   a- non-static data member
   b- static data members

2- member functions -- üye fonksiyonlar
   a- non-static member functions
     1-non-const member functions
     2- const member functions
   b- static member functions

3- member type -- type members - nested types



Ornek

//class Tag
class Myclass{
    int x, y;
    static double dval;
    void func();
    static int foo();
    typedef int Word;
    enum class Color{White, Black};
};


***************************************************


scope --kapsam

c de scope kavramı

file scope
block scope
function prototype scope
function scope

C++ de scope kavramı

namespace scope
class scope
block scope
function prototype scope
function scope


*************************************************


name lookup ---> isim arama

context-control

access control -- erişim kontrolu




*************************************************

class scope ta bir isim hangi durumlarda aranır

a- isim nokta operatörünün (member selection - dot operator)
   sagında kullanılmış ise

b- isim ok operatörünün (member selection - arrow operator)
   sagında kullanılmış ise

c- isim :: çözünürlük operatörünün (member selection - scope resolution operator)
   sagında kullanılmış ise

ornek

clas Myclass{
  int y;
};

Myclass myclass;

myclass.y;
myclass->y;
myclass::y;


----------------------------------------

sınıflara erişimler (access specifier) için 3 tanım

public member
private member
protected member

bunların hepsi anahtar sözcük



#include <iostream>

using namespace std;

class Myclass{

public:
    //burası public memberlar

private:
    //burası private memberlar

protected:
    //burası protected memberlar

public:
    //burası public memberlar

};



int main()
{
    cout << "Hello World!" << endl;
    return 0;
}

/*********************************************/
/*********************************************/




class Myclass{
  //membler private alanda kabul edilir
};


struct Myclass{
  //membler public alanda kabul edilir
};



class Myclass{

    int x; // private alanda

public:


};

------------------------------------------------

public
   kısım olan isimler erişimi herekse açıktır

private
  clinetlara kapalı isimler ama sınıf kendisi kendi içinde kullanabileceği isimler

protected
  inheritance (miras kalıtım) oldugu yerlerde sınıfın memberlarına erişim izni vardır
  eger kalıtım yok ise private özelliğine sahip olmus olur




#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;

};



int main()
{
    Myclass myclass;

    myclass.x;
    return 0;
}

/*********************************************/
/*********************************************/


soru gecerlimi -- Hayır

aynı scope aynı isim tanımlaması var

public ve private protected scope deil alan bildiri sadece


class Myclass{
public:
    int x;

private:
    int x();
    int y;

};


************************************************************

class veri elemanları


#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;
    double z;

};



int main()
{
    cout << "sizeof (Myclass) : " << sizeof (Myclass) << endl;
    return 0;
}

/*********************************************/
/*********************************************/

member function

//member function
class Myclass{
public:
    void func(int);
};



fonksiyon clasın dısın bildirilirse su isimleri alır

//global function
//free function
//stand-alone function

int foo(void);


/*****************************************/

Nedemek sınıfın üye fonksiyonu

fonksiyon özelliklerine sahip fakat sadece class scope da yer alması lazım


#include <iostream>

using namespace std;

//member function
class Myclass{
public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;

    m1.func(33);

    Myclass *m2 = new Myclass();

    m2->func(55);

    return 0;
}

/*********************************************/
/*********************************************/


neden private ile dışarıdan erişim yok

1- dışarıdan sınıfın kullanacak client sınıfın data memberlarının ne oldugunu bilmak zorunda değil
2- sınıfın data memberlarını client kodların erişimine çarsak kontrol elden gider



#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;
    Myclass *m2 = &m1;

    //her iki durumdada  m1'in func'ı cagrılır
    m1.func(3);
    m2->func(4);


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func();
};


int main()
{
    //bu fonksiyonı böyle cagırmak için Myclass nesnesi olması lazım
    Myclass::func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:
    void func();
};

void func(int);


//aynı siim tanımlamalar gecerlidir
//farklı scope oldugu için

//function overloading degildir scopelar farklı oldugu için

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:

    //overload edeilirim
    void func();
    void func(int);
    void func(int, int);
    void func(double);
};


int main()
{

    Data mydata;

    mydata.func();
    mydata.func(2);
    mydata.func(2, 5);
    mydata.func(2u); //sentaks hatası olur

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

class Data{
private:
    void func(int);

public:
    void func(double);
};


int main()
{

    Data mydata;

    //mydata.func(12.56); // gecerli
    //mydata.func(12); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/





//gecerlimi? Evet

int func(int);
int func(int);


//gecerlimi? Hayır

class Data{
public:
  void func(int);
  void func(int);
}


/*********************************************/
/*********************************************/

sınıfın üye fonksiyonları storage'a dahil değildir

#include <iostream>

using namespace std;

//soru
class Data{
public:
  void func(int);
  void foo(int);

private:
  int x, y;
};


int main()
{

    cout << "sizeof(Data) : " << sizeof (Data) << endl;

    return 0;
}

/*********************************************/
/*********************************************/


Myclass.hpp   --> class definition
Myclass.cpp   --> class declaration


#include <iostream>

using namespace std;

//.hpp
class Myclass {
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp

void Myclass::func(){
    //3
    if(1){
        //2
        if(1){
            //1
            //a  --> isim kullansaydım burada
            //1- ilk önce uye fonksiyonun içinde arar
            //2- class scope içinde arar
            //3- global alanda arar
        }
    }
}


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

int x = 20;

int main()
{
    int x = 10;

    cout << "x = " << x << endl;
    cout << "::x = " << ::x << endl;

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

int mx = 25;

//.cpp
void Myclass::func()
{
    int mx = 10;

    mx = 12; // yerel

    Myclass::mx = 22; // class mx

    ++::mx;

}

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp
void Myclass::func()
{
    mx = 12;

}

int main()
{
    Myclass m1, m2;

    //
    m1.func(); // burada mx, m1in mx'i
    m2.func(); // burada mx, m2 in mx'i


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo(int);

private:
    int mx, my;
};

void foo()
{
    //
}

//.cpp
void Myclass::func()
{
    foo(); //sentaks hatası
    ::foo(); // global fonksiyona erişirim çözünürlük operatoru ile

}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx, my;
};

//ben write - setter görevi görür
void foo(struct Data *p);

//ben alrım seni  oynama yapmam sende okuma - getter görevi görevi
void foo(const struct Data *p);


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //bunlara böyle hangisinini getter hengisinin setter oldugunu anlayamıyorum
    void func();
    void foo();
};

//.cpp


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp

void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();

    //iki ayrı fonksiyon olarak gecerlidir
    //const overloading
    void foo();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo(){
    mx = 10;
}

void Myclass::foo() const{
    mx = 12;
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

const üye fonksiyonları sınıfın nonstatic data type'larını değiştirmez


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    Myclass a;
    a.mx = 22;

    mx = 22; //    sentaks hatası
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp


int main()
{
    Myclass m1;
    //const Myclass m2;

    m1.foo();
    m1.func();
    m2.foo();
    m2.func(); // sentaks hatası

    /*
     * const T* ----> T* donusum yok
     * T* ------> const T* donusum var
     *
     */


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;
    void fuu()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    foo();
    //T*  ---> const T* donusum var
}

void Myclass::foo() const{
    func();// sentaks hatası
    //const T* ---> T* donusum yok
    fuu();
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


Üye fonksiyonları ve const overloading

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //const overloading
    void func();
    void func()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass::func()" << endl;
}

void Myclass::func() const{
    cout << "Myclass::func() const" << endl;
}


int main()
{
    Myclass m1;
    m1.func();

    //const Myclass m2;
    m2.func(); // const olan cagrılacaktı

    return 0;
}

/*********************************************/
/*********************************************/


this anahtar sözcüğüne ---- this pointer

this anahtar sözcüğü yanlızcana sınıfların
non-static üye fonksiyonları içinde kullanılır.



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    this; // nesnenin adresi
    *this; // nesnenşn kendisi

    mx = 10;// bunuda yazabiliriz
    this->mx = 20; // bunuda
    //ikiside aynı mx

    //iki foo da aynı
    //hiç bir fark yok
    foo();
    this->foo();

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    int mx = 10;

    //şimdi iki mx farklı biri local biri class data member
    mx = 20;
    this->mx = 30;
    Myclass::mx; // class scotaki mx

    (*this).mx = 34;

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

template<typename T>
struct ValCat {
    constexpr static const char *pstr {"PR value"};
};

template<typename T>
struct ValCat <T &>{
    constexpr static const char *pstr {"L value"};
};

template<typename T>
struct ValCat <T &&>{
    constexpr static const char *pstr {"X value"};
};

#define vcat(exp)  (std::cout<< "value category of \"" #exp "\" is : " << ValCat<decltype((exp))>::pstr << "\n");


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    vcat(this); /// r value expression
    vcat(*this);// l value expre
}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";
    foo();
}

void Myclass::foo(){
    cout << "Myclass sinifinin foo islevi cagrildi\n";
    cout << "this : " << this << "\n";
}

int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

void gf(Myclass *p){
    cout << "global gf islevi cagrildi  p : " << p << "\n";
}


void gf1(Myclass &p){
    cout << "global gf1 islevi cagrildi  p : " << &p << "\n";
}

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";

    //işte böyle global foksiyonlarda kullancak isek
    //this pointer kullanılır
    gf(this);
    gf1(*this);
}


int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass &f1();
    Myclass &f2();
    Myclass &f3();
    Myclass &f4();

private:
    int mx, my;
};


//.cpp
Myclass &Myclass::f1(){
    return *this;
}


int main()
{
    Myclass m1;
    m1.f1().f2().f3().f4();


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

int main()
{
    int x = 4;
    double d = 5.5;
    bool flag = false;


    cout << x << d << flag;
    //operator overloading
    //ileride


    //operator overloading olmasaydı
    //*this sayesinde bunu böyle kullanabiliyoruz
    cout.operator<<(x).operator<<(d).operator<<(flag);


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

Myclass g;

//.cpp
void Myclass::func(){
    *this = g; // gecerli
}

void Myclass::foo() const{
    *this = g; // const this pointer oldguu için gecersiz
    this->mx = 20; // gecersiz
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass *f1();
    Myclass &f2();

    Myclass *f3()const;
    Myclass &f4()const;

    const Myclass *f5()const;
    const Myclass &f6()const;

private:
    int mx, my;
};

Myclass *Myclass::f1(){
    return this;
}

Myclass &Myclass::f2(){
    return *this;
}

Myclass *Myclass::f3()const{
    return this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}

//geri donusun const olması lazımki gecerli olsun
Myclass &Myclass::f4()const{
    return *this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}


const Myclass *Myclass::f5()const{
    return this;
    //const T*  ----> const T*
}

const Myclass &Myclass::f6()const{
    return *this;
}

int main()
{
    Myclass m1;
    m1.f1();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();

private:
    int mx, my;
};

Myclass gm;

void Myclass::func(){
    this = &gm; // sentaks hatası
    //this R value expr dir
    //this pointer kendisi const dur bu yüzden gecersizdir
}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/










