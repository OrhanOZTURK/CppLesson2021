
Classes -- Sınıflar


data abstraction -- veri soyutlama

problem domainde ki varlıkları. Programalma dilinde yazılımsal olarak temsil etmektir.


user defined type

ikiside sınıf anlamına gelmektedir

class
struct


class definition -- tanımı
class declaration --- bildirimi

//boş sınıflar

class Myclass{

};

struct Mydata {

};


---------------------------

//class Tag
class Myclass{
    //bildirimler
    //memberlar
};




class'ın memberları 3 kategoride olabilir


1- data member -- veri ogeleri
   a- non-static data member
   b- static data members

2- member functions -- üye fonksiyonlar
   a- non-static member functions
     1-non-const member functions
     2- const member functions
   b- static member functions

3- member type -- type members - nested types



Ornek

//class Tag
class Myclass{
    int x, y;
    static double dval;
    void func();
    static int foo();
    typedef int Word;
    enum class Color{White, Black};
};


***************************************************


scope --kapsam

c de scope kavramı

file scope
block scope
function prototype scope
function scope

C++ de scope kavramı

namespace scope
class scope
block scope
function prototype scope
function scope


*************************************************


name lookup ---> isim arama

context-control

access control -- erişim kontrolu




*************************************************

class scope ta bir isim hangi durumlarda aranır

a- isim nokta operatörünün (member selection - dot operator)
   sagında kullanılmış ise

b- isim ok operatörünün (member selection - arrow operator)
   sagında kullanılmış ise

c- isim :: çözünürlük operatörünün (member selection - scope resolution operator)
   sagında kullanılmış ise

ornek

clas Myclass{
  int y;
};

Myclass myclass;

myclass.y;
myclass->y;
myclass::y;


----------------------------------------

sınıflara erişimler (access specifier) için 3 tanım

public member
private member
protected member

bunların hepsi anahtar sözcük



#include <iostream>

using namespace std;

class Myclass{

public:
    //burası public memberlar

private:
    //burası private memberlar

protected:
    //burası protected memberlar

public:
    //burası public memberlar

};



int main()
{
    cout << "Hello World!" << endl;
    return 0;
}

/*********************************************/
/*********************************************/




class Myclass{
  //membler private alanda kabul edilir
};


struct Myclass{
  //membler public alanda kabul edilir
};



class Myclass{

    int x; // private alanda

public:


};

------------------------------------------------

public
   kısım olan isimler erişimi herekse açıktır

private
  clinetlara kapalı isimler ama sınıf kendisi kendi içinde kullanabileceği isimler

protected
  inheritance (miras kalıtım) oldugu yerlerde sınıfın memberlarına erişim izni vardır
  eger kalıtım yok ise private özelliğine sahip olmus olur




#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;

};



int main()
{
    Myclass myclass;

    myclass.x;
    return 0;
}

/*********************************************/
/*********************************************/


soru gecerlimi -- Hayır

aynı scope aynı isim tanımlaması var

public ve private protected scope deil alan bildiri sadece


class Myclass{
public:
    int x;

private:
    int x();
    int y;

};


************************************************************

class veri elemanları


#include <iostream>

using namespace std;

class Myclass{
public:
    int x;

private:
    int y;
    double z;

};



int main()
{
    cout << "sizeof (Myclass) : " << sizeof (Myclass) << endl;
    return 0;
}

/*********************************************/
/*********************************************/

member function

//member function
class Myclass{
public:
    void func(int);
};



fonksiyon clasın dısın bildirilirse su isimleri alır

//global function
//free function
//stand-alone function

int foo(void);


/*****************************************/

Nedemek sınıfın üye fonksiyonu

fonksiyon özelliklerine sahip fakat sadece class scope da yer alması lazım


#include <iostream>

using namespace std;

//member function
class Myclass{
public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;

    m1.func(33);

    Myclass *m2 = new Myclass();

    m2->func(55);

    return 0;
}

/*********************************************/
/*********************************************/


neden private ile dışarıdan erişim yok

1- dışarıdan sınıfın kullanacak client sınıfın data memberlarının ne oldugunu bilmak zorunda değil
2- sınıfın data memberlarını client kodların erişimine çarsak kontrol elden gider



#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func(int);
};


int main()
{
    Myclass m1;
    Myclass *m2 = &m1;

    //her iki durumdada  m1'in func'ı cagrılır
    m1.func(3);
    m2->func(4);


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:

    //non static function
    void func();
};


int main()
{
    //bu fonksiyonı böyle cagırmak için Myclass nesnesi olması lazım
    Myclass::func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//member function
class Myclass{
private:
    int x, y, z;

public:
    void func();
};

void func(int);


//aynı siim tanımlamalar gecerlidir
//farklı scope oldugu için

//function overloading degildir scopelar farklı oldugu için

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:

    //overload edeilirim
    void func();
    void func(int);
    void func(int, int);
    void func(double);
};


int main()
{

    Data mydata;

    mydata.func();
    mydata.func(2);
    mydata.func(2, 5);
    mydata.func(2u); //sentaks hatası olur

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

class Data{
private:
    void func(int);

public:
    void func(double);
};


int main()
{

    Data mydata;

    //mydata.func(12.56); // gecerli
    //mydata.func(12); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/





//gecerlimi? Evet

int func(int);
int func(int);


//gecerlimi? Hayır

class Data{
public:
  void func(int);
  void func(int);
}


/*********************************************/
/*********************************************/

sınıfın üye fonksiyonları storage'a dahil değildir

#include <iostream>

using namespace std;

//soru
class Data{
public:
  void func(int);
  void foo(int);

private:
  int x, y;
};


int main()
{

    cout << "sizeof(Data) : " << sizeof (Data) << endl;

    return 0;
}

/*********************************************/
/*********************************************/


Myclass.hpp   --> class definition
Myclass.cpp   --> class declaration


#include <iostream>

using namespace std;

//.hpp
class Myclass {
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp

void Myclass::func(){
    //3
    if(1){
        //2
        if(1){
            //1
            //a  --> isim kullansaydım burada
            //1- ilk önce uye fonksiyonun içinde arar
            //2- class scope içinde arar
            //3- global alanda arar
        }
    }
}


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

int x = 20;

int main()
{
    int x = 10;

    cout << "x = " << x << endl;
    cout << "::x = " << ::x << endl;

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

int mx = 25;

//.cpp
void Myclass::func()
{
    int mx = 10;

    mx = 12; // yerel

    Myclass::mx = 22; // class mx

    ++::mx;

}

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};


//.cpp
void Myclass::func()
{
    mx = 12;

}

int main()
{
    Myclass m1, m2;

    //
    m1.func(); // burada mx, m1in mx'i
    m2.func(); // burada mx, m2 in mx'i


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//name resulotion

//.hpp
class Myclass{
public:
    void func();
    void foo(int);

private:
    int mx, my;
};

void foo()
{
    //
}

//.cpp
void Myclass::func()
{
    foo(); //sentaks hatası
    ::foo(); // global fonksiyona erişirim çözünürlük operatoru ile

}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx, my;
};

//ben write - setter görevi görür
void foo(struct Data *p);

//ben alrım seni  oynama yapmam sende okuma - getter görevi görevi
void foo(const struct Data *p);


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //bunlara böyle hangisinini getter hengisinin setter oldugunu anlayamıyorum
    void func();
    void foo();
};

//.cpp


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp

void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo() const;
    //foo sınıf nesnlerinde değişiklik olmaz

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    mx = 13;
}

void Myclass::func(){
    mx = 12;
}


int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();

    //iki ayrı fonksiyon olarak gecerlidir
    //const overloading
    void foo();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo(){
    mx = 10;
}

void Myclass::foo() const{
    mx = 12;
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

const üye fonksiyonları sınıfın nonstatic data type'larını değiştirmez


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp
void Myclass::foo() const{
    Myclass a;
    a.mx = 22;

    mx = 22; //    sentaks hatası
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

//.cpp


int main()
{
    Myclass m1;
    //const Myclass m2;

    m1.foo();
    m1.func();
    m2.foo();
    m2.func(); // sentaks hatası

    /*
     * const T* ----> T* donusum yok
     * T* ------> const T* donusum var
     *
     */


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo()const;
    void fuu()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    foo();
    //T*  ---> const T* donusum var
}

void Myclass::foo() const{
    func();// sentaks hatası
    //const T* ---> T* donusum yok
    fuu();
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


Üye fonksiyonları ve const overloading

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    //const overloading
    void func();
    void func()const;

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass::func()" << endl;
}

void Myclass::func() const{
    cout << "Myclass::func() const" << endl;
}


int main()
{
    Myclass m1;
    m1.func();

    //const Myclass m2;
    m2.func(); // const olan cagrılacaktı

    return 0;
}

/*********************************************/
/*********************************************/


this anahtar sözcüğüne ---- this pointer

this anahtar sözcüğü yanlızcana sınıfların
non-static üye fonksiyonları içinde kullanılır.



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    this; // nesnenin adresi
    *this; // nesnenşn kendisi

    mx = 10;// bunuda yazabiliriz
    this->mx = 20; // bunuda
    //ikiside aynı mx

    //iki foo da aynı
    //hiç bir fark yok
    foo();
    this->foo();

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    int mx = 10;

    //şimdi iki mx farklı biri local biri class data member
    mx = 20;
    this->mx = 30;
    Myclass::mx; // class scotaki mx

    (*this).mx = 34;

}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

template<typename T>
struct ValCat {
    constexpr static const char *pstr {"PR value"};
};

template<typename T>
struct ValCat <T &>{
    constexpr static const char *pstr {"L value"};
};

template<typename T>
struct ValCat <T &&>{
    constexpr static const char *pstr {"X value"};
};

#define vcat(exp)  (std::cout<< "value category of \"" #exp "\" is : " << ValCat<decltype((exp))>::pstr << "\n");


//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    vcat(this); /// r value expression
    vcat(*this);// l value expre
}

int main()
{
    Myclass m1;
    m1.func();

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";
    foo();
}

void Myclass::foo(){
    cout << "Myclass sinifinin foo islevi cagrildi\n";
    cout << "this : " << this << "\n";
}

int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo();

private:
    int mx, my;
};

void gf(Myclass *p){
    cout << "global gf islevi cagrildi  p : " << p << "\n";
}


void gf1(Myclass &p){
    cout << "global gf1 islevi cagrildi  p : " << &p << "\n";
}

//.cpp
void Myclass::func(){
    cout << "Myclass sinifinin func islevi cagrildi\n";
    cout <<"this : " << this << "\n";

    //işte böyle global foksiyonlarda kullancak isek
    //this pointer kullanılır
    gf(this);
    gf1(*this);
}


int main()
{
    Myclass m1;
    m1.func();

    cout << "&m1 :  " << &m1 << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass &f1();
    Myclass &f2();
    Myclass &f3();
    Myclass &f4();

private:
    int mx, my;
};


//.cpp
Myclass &Myclass::f1(){
    return *this;
}


int main()
{
    Myclass m1;
    m1.f1().f2().f3().f4();


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

int main()
{
    int x = 4;
    double d = 5.5;
    bool flag = false;


    cout << x << d << flag;
    //operator overloading
    //ileride


    //operator overloading olmasaydı
    //*this sayesinde bunu böyle kullanabiliyoruz
    cout.operator<<(x).operator<<(d).operator<<(flag);


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();
    void foo()const;

private:
    int mx, my;
};

Myclass g;

//.cpp
void Myclass::func(){
    *this = g; // gecerli
}

void Myclass::foo() const{
    *this = g; // const this pointer oldguu için gecersiz
    this->mx = 20; // gecersiz
}

int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass *f1();
    Myclass &f2();

    Myclass *f3()const;
    Myclass &f4()const;

    const Myclass *f5()const;
    const Myclass &f6()const;

private:
    int mx, my;
};

Myclass *Myclass::f1(){
    return this;
}

Myclass &Myclass::f2(){
    return *this;
}

Myclass *Myclass::f3()const{
    return this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}

//geri donusun const olması lazımki gecerli olsun
Myclass &Myclass::f4()const{
    return *this;
    //const T*  ----> T* converte zorluyoruz ama yok donusum
}


const Myclass *Myclass::f5()const{
    return this;
    //const T*  ----> const T*
}

const Myclass &Myclass::f6()const{
    return *this;
}

int main()
{
    Myclass m1;
    m1.f1();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    void func();

private:
    int mx, my;
};

Myclass gm;

void Myclass::func(){
    this = &gm; // sentaks hatası
    //this R value expr dir
    //this pointer kendisi const dur bu yüzden gecersizdir
}

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

Inline fonksiyonlar


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int); // inline buradaa olabilir

private:
    int mx, my;
};

inline int Myclass::func(int c){
    return c;
}



int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    inline int func(int c){
        return c;
    }

private:
    int mx, my;
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

//implicity inline fonksiyon
constexpr int func(int x)
{
    return x;
}



/*********************************************/
/*********************************************/

neler inline olaarak tanımlanır


sınıfın

  nonstatic member function
  const
  non const

static member function


#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    static int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
public:
    friend int func(int c){ // inline
        return c;
    }
};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


constructor / destructor

special member functions


constructor ismi sınıfın ismi ile aynı olmak zorunda
ctor geri donus diye bir kavramı yok
ctor uye fonksiyon olamaz
global veya sınıfın static uye fonksiyonu olamaz
ctor overload edilemez
ctor sınıfın public veya private fonksiyonu olabilir




class Myclass{

public:
     Myclass();
};




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
     Myclass();
     Myclass(int);
     Myclass(double);
     Myclass(int, int);
};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{
private:
    Myclass();

public:
    // Myclass();

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass();
    void func();

};


int main()
{
    Myclass m;
    m.func();
    m.Myclass(); // sentaks hatası ctor cagrılmaz boyle

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass()const; // ctor const fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    static Myclass(); // ctor static fonksiyon olamaz

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    Myclass(){
        //inline olarak header içinde tanımlayabilirim
    }

};


//.cpp inline oalrak tanımladım
Myclass::Myclass(){
    //inline olarak
}


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


default ctor

parametresi yoktur
yada parametresi var ama varsayılan argüman alıyor ise hepsi

default constructor == varsayilan kurucu işlev




#include <iostream>

using namespace std;


//.hpp
class Myclass{

public:
    //Myclass();
    Myclass(int x = 0);

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

//derleyici bizim sınıfn default ctor yazar
class Myclass{

public:


};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


#include <iostream>

using namespace std;


//.hpp

//derleyici artık senın ıcın ctor yazmaz
class Myclass{

public:
    Myclass(int);

};


int main()
{
    Myclass m; //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

destructor


sınıfın nonstatic uye fonksiyon
ismi sınıgın ismi ile aynı ~ (tilda karateri olması lazım)  ~Myclass()
geri donus degeri kavramı yok
dtor overload edilmez
dtor parametresi yoktur olamaz
dtor const olmaz
dtor static ve global olamaz



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor

};


int main()
{
    Myclass m;

    m.~Myclass(); // dtor cagra bilirim

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(int x, int y); //ctor
    //defautl olarak ctor olmak zorunda değil

    //ama default olarak dtor olmak zorunda

};


int main()
{
    Myclass m(2, 3);

    m.~Myclass();

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

//global nesneler main baslamdan once hayata gelir

Myclass m;


int main()
{
    cout << "mian basladi\n";

    cout << "&m : " << &m << endl;

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}


void func(){
    static int cnt = 0;

    cout << "func islebine yapilan  " << ++cnt << ". cagri\n";

    static Myclass m;
}


int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        func();
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";

    for (int i = 0; i < 10; ++i ) {
        static Myclass m;
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    {
        Myclass m;
        cout << "main devam ediyor 1\n";
    }

    cout << "main devam ediyor 2\n";

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    cout << "mian basladi\n";
    if(1){
        Myclass m1;
        if(2){
            Myclass m2;
        }
    }

    cout << "main sonlaniyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    cout << "Myclass default ctor ... this : " << this << endl;
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[10];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(); //ctor
    ~Myclass(); //dtor
};

//.cpp
Myclass::Myclass(){
    static int x = 0;
    cout << x++ << " ";
}

Myclass::~Myclass(){
   cout << "Myclass default dtor ... this : " << this << endl;
}

int main()
{
    Myclass a[50];
    _getwch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    auto p = new Myclass;

    cout << "main devam ediyor 1\n";
    cout << "main devam ediyor 2\n";

    //delete p;

    cout << "main devam ediyor 3\n";
    cout << "main devam ediyor 4\n";
    delete p;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass *p = &m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    Myclass &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp


int main()
{
    cout << "main basliyor\n";

    Myclass m;
    auto &r = m;

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass &r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//.hpp

class Myclass{
private:
    int mx[5]{};

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};

//.cpp

void func(Myclass r){

}


int main()
{
    cout << "main basliyor\n";

    Myclass m;

    //copy ctor cagrılıyor
    //ileriki derlerde cevabımızı alacaz
    for (int i = 0; i < 10; ++i ) {
        func(m);
    }

    cout << "main sona eriyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass m2{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır


    Myclass a[10]; // default initialazation
    //default ctor cagrılır
    //cop deger ile hayata gelir


    Myclass b[10]{}; //default value initialazation
    //zero sıfır degeri ile deglir
    //default ctor cagrılır

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(){
        cout << "Myclass default ctor ... this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass mx{}; //nesne tanımı
    Myclass my(); //bir fonksiyon bildirimidir dikkat


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m; //sentaks hatası
    Myclass m1(2); //parametreli ctor cagrılır // direct initilazation


    Myclass m2{22}; // paramterli ctor cagır // uniform initilazation
    //modern C++ -- C++11


    Myclass m3 = 30; // copy initilization -- ctor argüman olarak gönderilir

    return 0;
}

/*********************************************/
/*********************************************/

explicit ctor

genelde tek aprametreli ctorlar olur


#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    explicit Myclass(int x){
        cout << "Myclass default ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m = 3; //copy init.. sentaks hatsı olacak
    //ileride görecez


    return 0;
}

/*********************************************/
/*********************************************/

ctor overloading



#include <iostream>

using namespace std;

//.hpp
class Myclass{
private:
    int x, y, z;

public:
    Myclass(int x){
        cout << "Myclass (int) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(double x){
        cout << "Myclass (double) ctor ... x = " << x << " this : " << this << endl;
    }

    Myclass(int, int){
        cout << "Myclass (int, int) ctor ... x = " << x << " this : " << this << endl;
    }

    ~Myclass(){
       cout << "Myclass default dtor ... this : " << this << endl;
    }
};


int main()
{
    Myclass m1{1.3};
    Myclass m2{22};
    Myclass m3{2, 3};
    Myclass m4{2.0f}; //
    //Myclass m5{2u}; // sentaks hatası



    return 0;
}

/*********************************************/
/*********************************************/


constructor initializer list // güncel ismi
member initializer list (M.I.L syntax) //eski isimlendirme



non-static data memberlara ilk deger verme sentaksı


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int x, y;
    double dval;

};

//.cpp
Myclass::Myclass()
{
    x = 10; //ilk deger verme olmaz, atama olur
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int &r;
    const int x;

};

int g = 10;

//.cpp
Myclass::Myclass()
{
    r = g; //sentaks hatası ilk deger vermiş olmyız

    x = 5; //sentaks hatası ilk deger vermiş olmyız
}


int main()
{




    return 0;
}

/*********************************************/
/*********************************************/


initializer_list --> C++ standard list sınıfıdır -- sınıf türü


constructor initializer list ile karıstımraylım


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10), my(20), mz(30) //constructor initializer list ** M.I.L
{
    cout << mx  << " " << my  << " " << mz << "\n";
}


int main()
{

    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx(10) //constructor initializer list ** M.I.L
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};


//.cpp
Myclass::Myclass() : mx{10}, my{}, mz{20} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        for(int i = 0; i < 10; ++i)
            cout << a[i] << "  ";
        cout << "\n";
    }

private:
    int a[10];

};


//.cpp
Myclass::Myclass() : a{1, 2, 3, 4, 5}
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    Myclass();
    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

int f1(){return 1;}
int f2(){return 2;}
int f3(){return 3;}


//.cpp
Myclass::Myclass() : mx{f1()}, my{f2()}, mz{f3()} //C++11
{

}


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
public:
    //Myclass(int a, int b) : mx{a}, my{b}
    Myclass(int a, int b) : mx{a}, my{b}{} // böyle yazmam lazım

    void print()const
    {
        cout << "mx = " << mx  << " my = " << my  << " mz = " << mz << "\n";
    }

private:
    int mx, my, mz;

};

//.cpp


int main()
{

    Myclass m;
    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


delete  anahtar sözcük

modern C++ ile fonksiyon silme aracı eklendi

fonksiyonu delete edebiliriz ama cagrı yapamayız



#include <iostream>

using namespace std;

void func(int x, int y) = delete;

int main()
{
    func(1, 2); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//3 tane overload fonksiyon var delete edilende buna dahildir
void func(int);
void func(double) = delete;
void func(int *);

int main()
{
    func(1);
    func(2.3); // sentaks hatası cagrı yapamadıgından

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//Mulakat sorusu
//bir fonksiyonun sadece int argumanlarla cagrılmasına olanak veren bir yapı olusturun

void func(int);

template<typename  T>
void func(T x) = delete;

int main()
{
    func(2);
    func(3.); // sentaks hatası
    func(2.F); // sentkas hatsı
    func(3U); // sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/


default //C++11

bir sınıfın üye fonksiyonunu default edilmesi
yanlızca sınıfınn üye fonksiyonlarını default edebilirim


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default; // derleyici bu fonksiyonu benim içiin yaz
    ~Myclass() = default;
};

int main()
{

    return 0;
}


/*********************************************/
/*********************************************/

C++11

default member initialization
in-class initialization


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    //T mx = expr;
    //T mx{expr};
    //T mx(expr) // bunda sentaks hatası
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

private:
    int mx = 10;
    int my{20}; // hatta fonksiyon cagrısı ilede ilk deger verebilirim
    //int mz(30); // sentaks hatası

    int ma[5] = {1, 2, 3, 4, 5};
    int mb[] = {1, 2, 3, 4, 5}; // gecersiz dizi boyutu vermek zorundayiz
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


int mg;

//hpp
class Myclass{
public:

private:
    int *p = &mg;
    int &r = mg;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*
    Myclass()
    {
        cout << "default ctor\n";
    }*/

    Myclass() = default;


private:
    int mx = 10, my = 20;
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:

    //Myclass() : mx{10}, my{20}
    /*Myclass()
    {

    }*/

    Myclass() = default;

    void print()const{
        cout <<"mx = " << mx << "\n";
        cout <<"my = " << my << "\n";
    }


private:
    int mx = 10, my = 20;
};

int main()
{
     Myclass m;
     m.print();

    return 0;
}

/*********************************************/
/*********************************************/

C++11

mutable  anahtar sözcüğü  ---> değiştirilebilir demek



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    void func()const
    {
        ++count;
    }

private:
    mutable int count;
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



special member functions --- sınıfın ozel uye fonksiyonları


6 tane fonksiyon ozel uye fonksiyon vardır


default constructor
copy constructor
move constructor  //C++11
copy assignment function
move assignment function //C++11
destructor


not declared  ---- user declared --- implicity declared


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass(int);
    //burada default ctor yoktur -- not declared durum

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


user declared

 defined
 defaulted
 deleted


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    //Myclass(); //user declared -- defined
    //Myclass(){}; //user declared
    //Myclass() = default; -- defaulted
    Myclass() = delete; //--deleted

private:
};

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/



implicity declared

2 ayrılır

defaulted
deleted





#include <iostream>

using namespace std;

//hpp
class Member{
public:
    Member(int, int);

};

class Myclass{

private:
    Member mx;
};

int main()
{
    Myclass m; //implicity deleted default

    return 0;
}

/*********************************************/
/*********************************************/

copy constructor --- kopyalayan kurucu işlev


x ve y T sınıfı turunden nesneler

T x = y;

copy ctor durumlar

Myclass m2 = m1;
Myclass m2(m1);
Myclass m2{m1};



void func(Myclass m)

Myclass mx;
func(mx); // m nesenesi hayata gelir iken mx nesnesi için copy ctor cagıralacak ve hayata gelecek


Myclass g;

Myclass func()
{

   return g;

}

*****************************************************


derleyici tarafından yazılan copy ctor

1- sınıfın nonstatic, public üye fonksiyonudur
2- inline olaarak tanımlanmış kabul edilir
3- şu imzaya sahiptir

   Myclass(const Myclass &r);

   Myclass x = y;



#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : a{other.a}, b{other.b}
    {

    }

private:
    int a;
    double b;

};


int main()
{
    Myclass m1;

    ///
    Myclass m2 = m1;


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &other) : mx{other.mx}, md{other.md}
    {
        cout << "Myclass copy ctor\n";
    }

    void print()const
    {
        cout << "mx  = " << mx << " md = " << md << "\n";
    }

    void set(int x, double d){
        mx = x;
        md = d;
    }

private:
    int mx = 10;
    double  md = 2.3;

};


int main()
{
    Myclass m1;
    m1.print();
    m1.set(22, 1.2);
    m1.print();


    Myclass m2 = m1;
    m2.print();
    m2.set(33, 5.5);
    m2.print();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    Myclass m2 = m1; // m2 icin copy ctor cagrılacak
    cout << "&m2    :  " << &m2 << endl;
    /*
    Myclass m3(m1); // m3 icin copy ctor cagrılacak
    Myclass m4{m1};// m4 icin copy ctor cagrılacak
    auto m5{m1};  // m5 icin copy ctor cagrılacak
    */

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << endl;
    }

    ~Myclass()
    {
        cout << "Myclass default dtor this : " << this << endl;
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << endl;
        cout << "&other                 : " << &other << endl;
    }
};

void func(Myclass mf)
{
    cout << "func islevi cagrildi\n";
}


int main()
{
    Myclass m1;
    cout << "&m1    :  " << &m1 << endl;
    func(m1);
    cout << "main devam ediyor\n";

    _getch();


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "constructur this : " << this << "\n";
        cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        cout << "the address of allocated block : " << (void *) mp << "\n";
        cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }


    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString ms("Orhan OZTURK");
    std::cout << "length ::  " << ms.length() << "\n";
    ms.print();
    func(ms);
    _getch();

    //derleyici yazar ise shalow copy ctor
    //aynı veriyi kullan demek

    //burada yapmamız gerekn iki tane farklı yer olmaası gerekli
    //bu sebepten copy ctor bizim yazmamız lazım

    ms.print();



    return 0;
}

/*********************************************/
/*********************************************/


 assignment operator function ---> eski ismi buydu
 copy assignment function ==> yeni

 T x;
 T y;

  x = y;  --> copy assignment function cagrılıyor

derleyici bizim için  public inline static fonksiyon olarak yazar


Derleyicinin yazdıgı copy assignment function


class Myclass{
 T t;
 U u;

public:
    Myclass &operator=(const Myclass &other)
    {
       t = other.t;
       u = other.u;


       return *this;
    }
}

 m1 = m2;

arka tarafta donen olay bu

 m1.operator=(m2);



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    void func()
    {
        cout << "Myclass::func() this = " << this << "\n";
    }
};

int main()
{
    Myclass x, y;
    cout << "&x = " << &x << "\n";

    //x = y;  // copy assignment func.

    x.operator=(y).func();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
public:
    Counter() = default;
    Counter(int x) : mx{x}{}

    void print()const{
        cout << "mx = " << mx << "\n";
    }

    void set(int val)
    {
        mx = val;
    }

private:
    int mx = 0;
};


int main()
{
    Counter c1 { 123 };
    Counter c2 { 566 };

    c1.print();
    c2.print();

    //c1 = c2;
    //c1.operator=(c2);

    (c1 = c2).print();
    c1.print();

    c1.operator=(c2).print();



    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
public:
    Counter() = default;
    Counter(int x) : mx{x}{}

    void print()const{
        cout << "mx = " << mx << "\n";
    }

    void set(int val)
    {
        mx = val;
    }

    Counter &operator=(const Counter &other)
    {
        cout << "operator=(const Clunter &) called this : " << this << "\n";
        cout << "&other    =    " << &other << "\n";

        mx = other.mx;

        return *this;
    }

private:
    int mx = 0;
};


int main()
{
    Counter c1, c2, c3, c4;
    Counter c5 { 566 };

    //c1 = c2 = c3 = c4 = c5;

    c1.operator=(c2.operator=(c3.operator=(c4.operator=(c5))));


    c1.print();
    c2.print();
    c3.print();
    c4.print();
    c5.print();


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "constructur this : " << this << "\n";
        //cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        //cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }

    //copy assasignment func
    //deep copy
    MyString &operator=(const MyString &other)
    {
        if(this == &other)
            return *this;

        free(mp); // kendisne atama yapilan nesne önce kendi kaynagını geri vermeli
        mlen = other.mlen;

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);

        return *this;
    }

    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString s1("Orhan OZTURK");
    s1.print();

    s1 = s1; // kendisine atama  == self-assignment

    s1.print();

    _getch();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    ~Myclass();
    Myclass(const Myclass &other);
    Myclass &operator=(const Myclass &other);
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


RAII


Big three (buyuk uclu)

Destructor  --- alinan yerleri yerleri geri verme
Copy constructur  --- kaynak kopyalama ama deep copy ihtiyac var
assignment op. function  -- kaynak kopyalama ama deep copy ihtiyac var


Big Five

move ctor
move assasignment


/*********************************************/

move semantics --- taşıma semantiği

move ctor

kopyalanacak nesnenin hayatının bitmek üzere oldugundan emin oldgumuzda
move ctor ve ya copy işin içine girer

yaptıgı şey diger nesnenin kaynağını çalmak

R value oldugunda devreye girer move semantics

-------------

move assignment da

aynı sekilde move ctor gibi

kopyalanacak nesnenin hayatının bitmek üzere oldugundan emin oldgumuzda
move copy işin içine girer

yaptıgı şey diger nesnenin kaynağını çalmak ama çalmadan öncec kendi kaynagını geri verir



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass(const Myclass &other);  // copy ctor Lvalue larda cagrılcak
    Myclass(Myclass &&); //move ctor PR ve X value için cagrılacak

    Myclass &operator=(const Myclass &other); //copy assignment Lvalue olması lazım
    Myclass &operator=(Myclass &&); //move assignment PR ve X value ile cagrılacak
};

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

class Myclass{};

void func(const Myclass &r) //lvalue
{
    cout << "func(const Myclass &)\n";
}

void func(Myclass &&r) // rvalue
{
    cout << "func(Myclass &&)\n";
}

int main()
{

    Myclass m;

    func(m);

    func(move(m)); // Rvalue

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass &)
    {
        cout << "copy ctor\n";
    }

    Myclass(Myclass &&)
    {
        cout << "move ctor\n";
    }
};


int main()
{

    Myclass m1;

    //Myclass m2 {m1};
    Myclass m3 { move(m1)}; //bilerek isteyerek hayatını calıyorum m1'in

    return 0;
}

/*********************************************/
/*********************************************/

derleyici nasıl yazıyor

class Myclass {
public:
 Myclass(Myclass &&other) : mt(move(other.mt)), mu(move(other.mu))
 {}

 Myclass &operator=(Myclass &&other)
 {
   mt = std::move(other.mt);
   mu = std::move(other.mu);
 }

private:
 T mt;
 U mu;
};



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class MyString{
public:
    MyString(const char *pstr) : mlen{strlen(pstr)}
    {
        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "constructur this : " << this << "\n";
        //cout << "the address of allocated block : " << (void *) mp << "\n";

        strcpy(mp, pstr);

     }

    ~MyString(){
        cout << "destructor this  : " << this << "\n";
        if(mp){
            free(mp);
        }
        cout << "the address of free block : " << (void *) mp << "\n";
    }


    //copy ctor --- deep copy
    MyString(const MyString &other) : mlen{other.mlen}
    {
        //cout << "MyString copy ctor this : " << this << "\n";

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);
    }

    //move ctor
    //tasıyan krucu ıslev
    MyString(MyString &&other) : mlen{other.mlen}, mp{other.mp}
    {
       cout << "move ctor\n";
       other.mp =nullptr;
    }

    //copy assasignment func
    //deep copy
    MyString &operator=(const MyString &other)
    {
        if(this == &other)
            return *this;

        free(mp); // kendisne atama yapilan nesne önce kendi kaynagını geri vermeli
        mlen = other.mlen;

        mp = static_cast<char *>(malloc(mlen + 1));
        if(!mp){
            cerr << "bellek yetersiz\n";
            exit(EXIT_FAILURE);
        }

        //cout << "the address of allocated block : " << (void *) mp << "\n";
        //cout << "other mp                       : " << (void *)other.mp << "\n";

        strcpy(mp, other.mp);

        return *this;
    }


    //move assignment
    MyString &operator=(MyString &&other)
    {
        cout << "move assignment\n";

        if(this == &other)
            return *this;

        mlen = other.mlen;

        std::free(mp);
        mp = other.mp;
        other.mp = nullptr;

        return *this;
    }

    size_t length()const{
        return mlen;
    }

    void print()const{
        cout << "[" << mp << "]\n" << endl;
    }

private:
    size_t mlen;
    char *mp;
};


void func(MyString str)
{
    cout << "func cagrildi\n";
    str.print();
    cout << "func sona eriyor\n";
}

int main()
{
    MyString s1("Orhan OZTURK");
    s1.print();

    MyString s2{ std::move(s1)}; //move ctor
    MyString s3{"OZturk"};

    s2.print();

    s3 = move(s2);

    s3.print();

    return 0;
}

/*********************************************/
/*********************************************/


Modern C++ ile gelen önemli kural


not declared

user declared
   user declared --> defined
   user declared --> defaulted
   user declared --> deleted

implicity declared
   implicity declared  --> defaulted
   implicity declared  --> deleted


eger derleyici görevi gereği dilin kurallarına görevi
bir sınıfn özel bir uye fonksiyonu yazıyor ise (defualt ediyor ise)
yani bu fonksiyon (implicity declared) ise


derleyici bu kodu yazması gerektigi gibi yazarken
 dilin kuralları cignemiyor ise
  derleyici sentaks hatası vermez

yazacagı fonksiyonu delete eder.





#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Member{
public:
    Member(int);
};


class Myclass{

    //derleyici yeni standarlara  göre default ctor soyle yapıyor
    //Myclass() = delete;

private:
    Member mx;
};


int main()
{
    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Member{
private:
    Member();
public:

};


class Myclass{

    //derleyici yeni standarlara  göre default ctor soyle yapıyor
    //Myclass() = delete;

private:
    Member mx;
};


int main()
{
    Myclass m;

    return 0;
}

/*********************************************/
/*********************************************/

destructor yazmam gerekiyor ise

big 3
destructor
copy ctor
copy assasignment

big 5
move ctor
move assignment



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    Myclass(const Myclass &other) = delete;
    Myclass &operator=(const Myclass &other) = delete;

    //move func. açık ise
    //kopyalamaya kapalı taşımaya açık


private:

};


int main()
{


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Member{
private:
    Member(Member &&){}

public:
    Member(){}
    Member(const Member &) {cout<<"Member copy ctor\n";}
};

class A{
    Member m;
    //move delete edilyor
};


int main()
{
    A a1;
    A a2(move(a1));

    return 0;
}

/*********************************************/
/*********************************************/

geçici nesenler --- temporary objects
conversion cunstructor
dinamik ömürlü nesneler


/*********************************************/

geçici nesenler --- temporary objects

oyle nesnesenler ki kodada belirli bir isimleri yok
bu nesnelerin ifadeleri yürütülmesinden sonra jayatları biter


örnek

   Myclass(); // bu bir geçici nesne default ctor ile olsuturlan
   Myclass(12, 22); //parametreli geçici nesne


geçici nesne olsuturan ifadeler R value Pr value expression dir



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(const Myclass &r)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    func(Myclass(2)); //tempraro object

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(const Myclass &r)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    Myclass m{2};

    func(m); //lvalue expr

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    Myclass m{2};

    func(Myclass(3));

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }


};


void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladı\n";

    func(Myclass{});

    cout << "Main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp

class Myclass{
private:
   int mx = 0;

public:
    Myclass() : mx(0)
    {
        cout << "Myclass() this : " << this << "\n";
    }

    Myclass(int val) : mx{val}
    {
        cout << "Myclass(int val) val : "<< val << " this : " << this << "\n";
    }

    ~Myclass(){
        cout << "Myclass dtor this : " << this << "\n";
    }

};

void func(Myclass &&r) //Rvalue
{
    cout << "func Myclass && cagrildi\n";
}

void func(const Myclass &r) //Lvalue
{
    cout << "func const Myclass & cagrildi\n";
}

int main()
{
    cout << "Main basladi\n";

    if(true){
        //life extension
        const Myclass &r = Myclass{12};
        cout << "Main devam ediyor 1\n";
        cout << "Main devam ediyor 2\n";
    }

    cout << "Main devam ediyor 3\n";

    return 0;
}

/*********************************************/
/*********************************************/

convertion constructor --- dönüştüren krucu işlev





#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
};

int main()
{
    Data mydata;

    mydata = 10;  //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
    Data(int);
};

int main()
{
    Data mydata;

    mydata = 10;

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Data{
public:
    Data();
    Data(int);
};

int main()
{
    Data mydata;

    mydata = 10;

    //dereleyici sözde bir kod yazar bizim içn
    //geçici nesene olusturur
    //Data(10);// seklinde
    //ve derleyici söyle kod uretir
    mydata.operator=(Data(10));

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

using namespace std;

//hpp
class Counter{
private:
    int cnt;
public:
    Counter(): cnt{0}
    {
        cout << "default ctor this : " << this << "\n";
    }

    Counter(int val): cnt{val}
    {
        cout << "Counter int ctor val : " << val << "  this : " << this << "\n";
    }

    ~Counter()
    {
        cout << "Counter dtor this : " << this << "\n";
    }

    Counter &operator=(const Counter &other)
    {
        cout << "copy assignment this : " << this << " &other" << &other << "\n";
        cnt = other.cnt;

        return *this;
    }

};

int main()
{

    Counter c;

    c = 234; //Counter{234};

    //c.operator=(Counter(234));

    cout << "main devam ediyor\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{

    Myclass m;

    m = 13; //Myclass{13}

    int ival = 10;
    func(ival);
    foo(ival);
    fuu(ival); //sentaks hatası

    return 0;
}

/*********************************************/
/*********************************************/

explicit anahtar sözcüğü

explicit ctor
bu ctor tür dönüşümü için kullanılabilir
ama bu dönüşüm tür donusturme operatoru ile yapılırsa


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{

    Myclass m;

    m = 13; //sentaks hatası explicit den

    int ival = 10;
    func(ival);//sentaks hatası explicit den
    foo(ival);//sentaks hatası explicit den


    return 0;
}

/*********************************************/
/*********************************************/







#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int);
};

void func(Myclass m);
void foo(const Myclass &);
void fuuu(Myclass &);


int main()
{
    Myclass m;

    m = static_cast<Myclass>(13); //Myclass{13}

    int ival = 10;
    func(static_cast<Myclass>(ival));
    foo(static_cast<Myclass>(ival));


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int); //explicit anahtar sözcüğü sadece hpp dosyasında kullanılır
};

//cpp


int main()
{

    Myclass m = 10;//copy ctor artık sentaks hatsı explicit oldugu



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();
    explicit Myclass(int); //explicit anahtar sözcüğü sadece hpp dosyasında kullanılır

};

//cpp
Myclass::Myclass(int)
{
    //
}

int main()
{

    Myclass m = 10;//copy ctor artık sentaks hatsı explicit oldugu



    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx = 0, my = 0;
public:
    Myclass() = default;
    Myclass(int a, int b) : mx{a}, my{b}{}
    void print()const
    {
        cout << "mx = " << mx << " my = " << my << "\n";
    }
};


int main()
{
    //birden fazla parametrede olunca ortülü dönüşüm salanır
    //parametreli ctor explicit yapar isek sentaks hatası alırız

    Myclass m;

    m = {12, 17};

    m.print();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    Myclass();

};

Myclass func()
{
    ///

    return {};
}

int main()
{

    Myclass m = {};


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    explicit Myclass(int)
    {
        cout << "Myclass int\n";
    }

    Myclass(double)
    {
        cout << "Myclass double\n";
    }
};

int main()
{

   int ival = 10;

   //Myclass m(ival); //ınt ctor cagrılır

   Myclass m = ival; ///double ctor cagrılır

    return 0;
}

/*********************************************/
/*********************************************/

Copy elision -- copy elimination

derleyici durumdan vazife çıkartarak
copyalama yapamadan kod üretir


söyle de denir

mandatory copy elision



#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }

};

void func(Myclass mx)
{
    cout << "func cagrildi\n";
}

int main()
{
  //C++11 ile eklenmiştir
    cout << "Main basladi\n";

    //Myclass m;

    //func(Myclass{});
    func(Myclass{10});

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other) = delete;


};

void func(Myclass mx)
{
    cout << "func cagrildi\n";
}

int main()
{
    cout << "Main basladi\n";

    //Myclass m;

    //func(Myclass{});
    func(Myclass{10});

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/




#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }


};

//RVO => return value optimization
//C++11 ile mandatory copy elision

Myclass foo()
{
    return Myclass{10};
    //mx bu nesnenin yerine geçiyormuş gibi düşünün
}

int main()
{
    cout << "Main basladi\n";

    Myclass mx = foo();

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru

//hpp
class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor this : " << this << "\n";
    }

    Myclass(int x)
    {
        cout << "Myclass int ctor this : " << this << "\n";
    }

    ~Myclass()
    {
        cout << "Myclass dtor this : " << this << "\n";
    }

    Myclass(const Myclass &other)
    {
        cout << "Myclass copy ctor this : " << this << "\n";
    }

    void set1(int x)
    {
        //
    }

    void set2(int x)
    {
        //
    }
};

//RVO => return value optimization
//C++11 ile mandatory copy elision

//NRVO => named return value optimization
//yazacagımız bir cok fonksiyon bu kategoriye giriyor
//C++17 ile mandatory copy elision
Myclass foo()
{
    cout << "foo agrildi\n";
    Myclass m;

    cout << "foo devam ediyor\n";
    m.set1(22);
    m.set2(33);

    cout << "foo sona eriyor\n";

    return m;
}

int main()
{
    cout << "Main basladi\n";

    Myclass mx = foo();

    cout << "Main devam ediyor\n";


    return 0;
}

/*********************************************/
/*********************************************/

dinamik omurlu nesneler uzerıne konusacaz
sınıfın static veri elemanları ve uye fonksiyonları



/*********************************************/


sınıfın static veri elemanları ve uye fonksiyonları

data members
   static
   nonstatic

member functions
  static
  nonstatic
     const
     nonconst

type members

--------------------------------------


sınıfın static veri elemanları


sınıfın static veri elemanları sınıfın kendisis ile ilgilidir



#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx, my, m1, m2;
    char str[12];
    double dval;

};

int main()
{
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    int mx, my;
    double dval;
    static int sy;
    static int m1;
    static int sa[100];

};

int main()
{
//sınıfın static nesneleri boyutu arttırmaz
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri ogleri sıınıfın ıcınde bıldırılır ama tanımlanmaz
//bu veri elemanlarının cpp dosyasında ayrıca tanımlanmaları gereklidir

class Myclass{
public:
   static int mx;

};

//cpp


int main()
{
    Myclass::mx = 10; //sentaks hatası


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri ogleri sıınıfın ıcınde bıldırılır ama tanımlanmaz
//bu veri elemanlarının cpp dosyasında ayrıca tanımlanmaları gereklidir

class Myclass{
public:
   static int mx;

};

//cpp
//int Myclass::mx; //ilk degerinin böyle tnaımlaarım
//int Myclass::mx{}; //value init. edebilirim
//int Myclass::mx(); //sentaks hatası -- fonksiyon olarak gorur
//int Myclass::mx = 10; //gecerli
int Myclass::mx{10}; //gecerli
//int Myclass::mx(10); //gecerli

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp

//sınıfın statik veri elemanları incomplete type olabilir

class Orhn;

class Myclass{
public:
   static Orhn mx; //mx incomplete type

};

//cpp

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/
#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
   Myclass m; //sentaks hatası -- cunku sizeof degerini derleyici bilmek sorunda

};

//cpp

int main()
{



    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//sınıfın kendi türünden statik veri elemanı olabilirmi
//evet olabılır

//hpp
class Myclass{
public:
    static Myclass m; //gecerli --siof etkilenmedigi için

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static unsigned char buffer[]; //gecerli, eger static olmaydı gecersiz boyut bilgisinin verilmesi lazım

};

//cpp
//unsigned char Myclass::buffer[] = {'a', 'b'};
unsigned char Myclass::buffer[5];

int main()
{


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static int mx;
};

//cpp
int Myclass::mx{};

int main()
{
    cout << "Myclass::mx : " << Myclass::mx << "\n";

    Myclass::mx = 12;

    cout << "Myclass::mx : " << Myclass::mx << "\n";

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    int x = 10;
    static int sx;
};

//cpp
int Myclass::sx{};

int main()
{
    Myclass m;

    m.x = 10; //gecerli
    m.sx = 12; //gecerli

    Myclass *p{&m};
    Myclass &r{m};

    p->sx = 22; //gecerli
    r.sx = 13; //gecerli

    //böyle kodlarla statik veri elemanlarını ulasmanız ve oynamanız tavsıye etmem

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static int x;
    static int sx;
};

//cpp
int x = 10; // bu x sınıfın static elemanı deglidir global degısken
int Myclass::x = 99;

int Myclass::sx = x;

int main()
{
    cout << "Myclass::sx : " << Myclass::sx << "\n";

    return 0;
}

/*********************************************/
/*********************************************/


sınıfın
   const ve integral type (tamsayı türlerinden ) static
   veri öglerine sınıf içinde ilk deger verilebilir
   Bu durumda bu eri ögleri cpp dosyasında ayrıca tanımlanmasına gerek kalmaz
   tanımlandı olarak kabul edilir



#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    const static int x = 10; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const int x = 10; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const double x = 10.0; //gecerli degil (integral type) tam sayı olmadıgı için

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    static const bool flag = true; //gecerli, boolda bir tam sayi türü

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//hpp
class Myclass{
public:
    const static int sx = 12;
    constexpr static int sy = 12;
    const static double sd = 1.2; //sentaks hatası
    constexpr static double st = 1.2; //gecerli

};



int main()
{
    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>
#include <string>
#include <numeric>
#include <ios>

using namespace std;


//hpp


int main()
{
    //static constexpt oalrak std kutuphanede cokca tnaım mevcut
    ios::boolalpha;
    ios::badbit;

    string::npos;

    numeric_limits<int>::digits;

    return 0;
}

/*********************************************/
/*********************************************/

 sınıfın static uye fonksiyonları
 static member functions

sınıfın static uye fonksiyonları this pointer'a sahip olmayan
yani bir instance'ın adresini gizlice almazlar
dolasıyla dogrudan bir instance icin (sınıfın nesnesi icin) vagrılmayan
sınıfnn geneli icin bir takım fayda saglaycak uye fonksiyonlardır




#include <iostream>

using namespace std;


//hpp
class Myclass{

public:
    void func(int, int);
};

int main()
{
    Myclass m;

    m.func(1, 2);// m nın adresi gizli oalrak func2a gidiyodu

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//hpp
class Myclass{

public:
    static int func(int); //bunun this poniterı yok
    //public ve private olaiblir
};

int main()
{
    Myclass m;

    Myclass::func(12); //bu sekılde cagrılır

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x)
    {
        return x+x;
    }
};

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x);
};

//cpp
//cpp dosyasında static keyword kullanılmayacak yoksa sentaks hatası
int Myclass::func(int x)
{
    return x+x;
}

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{

public:
    static int func(int x);
};

//cpp
#define STATIC


STATIC int Myclass::func(int x)
{
    return x+x;
}

int main()
{
    Myclass m;

    auto val = Myclass::func(12); //bu sekılde cagrılır
    cout << "val : " << val << "\n";


    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{
private:
    int mx;

public:
    static void foo(int x)
    {
        mx = 10; //sentaks hatası
        //this pointer almadgı icin
        //sınıfn mx goremıyecek
        //bu namelookup hatası degil
        //derleyici hangi mx diye soruyor
    }

    int fuu()
    {
        mx = 10;
        this->mx = 10;
    }

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;


//static uye fonksiyonları sınıfnn cınde ınline yapılabilidigi gibi
//tanımı cpp dosyasındada yapılabilir

//hpp
class Myclass{
private:
    int mx;
    static int val;

public:
    static void foo(int x)
    {
        //mx = 10; //sentaks hatası
        val = 10; //gecerli
        //yada
        Myclass::val = 12;

    }

    void fuu()
    {
        mx = 10;
        Myclass::val = 12;
    }

};

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    void foo(int x)
    {
        //non static uye fonk.
        //iki sekilde cagırabilirim

        func();
        this->func();
    }

    void func()
    {

    }


};

//cpp

int main()
{
    Myclass m;

    m.foo(2);

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//hpp
class Myclass{
public:
    static void foo(int x)
    {
        //non static uye fonk.
        //iki sekilde cagıramam
        //cunku this pointer yok

        //func();
        //this->func();

        //static uye fonksiyonu icinde static uye fonksiyonu cagırabilirim
        fuu();
    }

    void func()
    {

    }

    static void fuu()
    {

    }


};

//cpp

int main()
{
    Myclass m;

    m.foo(2);

    return 0;
}

/*********************************************/
/*********************************************/


Sınıfın static uye fonksiyonları dogrudan ismiyle
   sınıfın static veri elemnalarıı kullanabılır
   sınıfın statıc uye fonksiyonlarını cagarailir



Sınıfın static uye fonksiyonları dogrudan ismiyle
   sınıfın nonstatic veri elemnalarıı kullanamaz
   sınıfın nonstatıc uye fonksiyonlarını cagaramaz

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//soru 1 tahmin yurutun

//hpp
class Myclass{
    //sınıfın uye fonksiyonu const olabilirmi

    //Hayır sentaks hatası
    static void func()const
    {

    }

    /*
    void foo(const Myclass *this)const
    {

    }
    */

};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//soru 1 tahmin yurutun

//hpp
class Myclass{
private:
    int mx;

public:
    //olabilir
    static void func(Myclass &r)
    {
        r.mx = 10;
    }

    static void foo(Myclass *r)
    {
        r->mx =12;
    }

    static void foo(const Myclass *r)
    {
        //r->mx =12;
    }

    static void foo(const Myclass &r)
    {

    }



};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 2

//hpp
class Myclass{
private:
    static int mx;
    int my;

public:
    void func()const
    {
        mx = 10; //gecerli
        //my = 12;
    }
};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 3

//hpp
class Myclass{
private:
    static int mx;

public:
    //function overloading mi degilm i

    //EVET function  overloading burada var
    void func();
    static void func(int);

};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//soru 3

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
};


//cpp

int main()
{
    Myclass m;

    m.func(11); //programcı boyle cagırd statıc oldugun bilmeden
    //sentaks hatası degil
    //ama cagrının m ile lakası yok

    Myclass::func(11); //bunla alakası yok yukarıdakı cagırını

    //iki turlude cagrılabılır
    //nesnee ile cagırmak sadece bir namelookup amacı ile kullanılır
    //sentaks hatası yok


    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
    void func();

};


//cpp

int main()
{
    Myclass mx;

    mx.func(12); //static func.
    mx.func(); //non static func.



    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//hpp
class Myclass{
private:
    static int mx;

public:
    static void func(int);
    void func();

    void foo() //non static
    {
        func();
        func(12);
    }

};


//cpp

int main()
{
    Myclass m;

    m.foo();

    return 0;
}

/*********************************************/
/*********************************************/


#include <iostream>

using namespace std;

//C++17

//hpp
class Myclass{
private:
    inline static int mx = 10;
    //derleyici bunu bir çok dosyasında olmasına karsı bir tane görecek
    //ve header dosyasında boyle tanımlamamıza izin verecek
};


//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/

#include <iostream>

using namespace std;

//C++17

//hpp
class Date{
    static const int daytabs[];

public:
    static Date RandomDate(){
        daytabs[2];
        //acces erişimi oldugu için
    }
};

//bu statik veri elemanını direk olarak kullanabilirmi
Date RandomDate()
{
    daystabs[1];
    //acces erişim yok
}

//cpp

int main()
{

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//iki tane ctor tanımlamak istiyor
//bunun için fabrika fonksiyonu yazarız

//burada derleyici bizim için default ctor olsutur

//hpp
class Complex{
private:
    Complex(double r, double i, int);
    Complex(double distance, double angle);

public:
    static Complex createCartesian(double r, int i)
    {
        return Complex(r, i, 0);
    }

    static Complex createPolar(double distance, double angle)
    {
        return Complex(distance, angle);
    }
};


//cpp

int main()
{
    auto c1 = Complex::createCartesian(2.1, 22);
    auto c2 = Complex::createPolar(1.2, 44);

    return 0;
}

/*********************************************/
/*********************************************/


singleton oruntusu
design pattern

pattern dilden bagımsızdır

object oriented design pattern

bu konu aslında şehir planlama dan gelir
ilk defa orada kullanılmıstır

bazı problem ortay cıkması ile aynı problemleri
czmek için bazı kalıplar üretilmiştir

bunlara design pattern denilmiştir

olusturdukları tasarım kalıpları sistematik sekilde dokumante etmişler


Gamma
Vilissides
Johnson
Helm


bunlara 4 kafadar olarak isimlendirmişler

Gang of four olarak isimlendirilir


23 tasarım kalibi vardır
GOF pattern debir


---------

baslangıc için daha raht veeglenceli kitap,
Head first design patterns
eric freeman

-----

modern C++ design
Andrei Alexandres

---------------------------------------------------


singleton pattern

bir sınıfın turunden tek bir nesne olacak
ve bu nesneye global acces soz konusu olacak


singleton pattern uygulamını birden fazla yöntemi var




#include <iostream>

using namespace std;


//hpp
class Singleton{
public:
    static Singleton *getInstance();

    //kopyalamaya karsı kapalı
    Singleton(const Singleton &) = delete;
    Singleton &operator=(const Singleton &) = delete;

    void func();
    void foo();

private:
    static Singleton *mp;
    Singleton();

};

//cpp
Singleton *Singleton::mp = nullptr;
Singleton *Singleton::getInstance()
{
    if(!mp)
        mp = new Singleton;
    return mp;
}


int main()
{
    auto ps = Singleton::getInstance();

    return 0;
}

/*********************************************/
/*********************************************/



#include <iostream>

using namespace std;

//scott meyers singleton pattern implemention

//kitap
//scott meyers Effective modern C++ = 11 ve 14 mevcut


//hpp
class Singleton{
private:
    Singleton();

public:
    static Singleton &getInstance()
    {
        static Singleton s; // fonksiyon ilk cagrıldıgında hayata gelir tekrar tekrar hayat gelmez
        //aynı nesne sürekli olarak geri döndürülücek

        return s;
    }

};

//cpp


int main()
{
    auto &s = Singleton::getInstance();

    auto &s1 = Singleton::getInstance();

    return 0;
}

/*********************************************/
/*********************************************/


mülakat sorusu

öyle bir sınıf olsuturun ki
sınıfın hayatta olan nesnelerin sayisini geri verecek
hayatta kalan veya hayatta olan nesnelerin sayısını sınıf bilecek






#include <iostream>
#include <string>

using namespace std;


//hpp
class Fighter{
public:
    Fighter()
    {
        ++ms_live_count;
        ++ms_total_count;
    }
    Fighter(std::string name, int age) : m_name{std::move(name)}, m_age{age}
    {
        ++ms_live_count;
        ++ms_total_count;
    }

    ~Fighter()
    {
        --ms_live_count;
    }

    Fighter(const Fighter &) = delete;
    Fighter &operator=(const Fighter &) = delete;

    int Age()const
    {
        return m_age;
    }

    std::string Name()const
    {
        return m_name;
    }

    void kill();
    void run();

    static int get_live_count();
    static int get_total_count();

private:
    static int ms_live_count;
    static int ms_total_count;

    std::string m_name = "isimsiz";
    int m_age = 0;

};

//cpp
#define STATIC

int Fighter::ms_live_count{};
int Fighter::ms_total_count{};

STATIC int Fighter::get_live_count()
{
    return ms_live_count;
}

STATIC int Fighter::get_total_count()
{
    return ms_total_count;
}



int main()
{
    cout << "Hayatta olan savasci sayisi : " << Fighter::get_live_count() << "\n";
    Fighter f1{"Orhan", 30};
    Fighter f2{"Ahmet", 22};

    cout << "Hayatta olan savasci sayisi : " << Fighter::get_live_count() << "\n";

    if(1)
    {
        auto pf1 = new Fighter { "Aleattin", 55};
        auto pf2 = new Fighter { "Seda", 21};

        cout << "Hayatta " << Fighter::get_live_count() << "  savasci var\n";
        cout << "Hayata gelmis toplam savasci sayisi  " << Fighter::get_total_count() << "\n";

        delete pf1;
        delete pf2;
    }

    cout <<  "\n";
    cout << "Hayatta " << Fighter::get_live_count() << "  savasci var\n";
    cout << "Hayata gelmis toplam savasci sayisi  " << Fighter::get_total_count() << "\n";

    /*
    Fighter x{f1};
    Fighter y{f2};
    */

    return 0;
}

/*********************************************/
/*********************************************/


scope leakage

void func()
{
  int x = foo();
  if(x > 10){

  }

  x //yanlıslıkla


}


C++17 ile
core syntax etkilenyen yeni bir if eklendi


if with initializer dir


#include <iostream>
#include <string>

using namespace std;

int func(int);

int main()
{
    //C++17
    if(auto y = 2; y > 10)
    {
        func(y);
    }
}

/*********************************************/
/*********************************************/

#include <iostream>
#include <string>

using namespace std;

int func(int);

int main()
{
    //eskiden beri gelen bir özellik
    if(int y = 5)
    {
        func(y);
    }
}

/*********************************************/
/*********************************************/



#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;


//hpp
class Fighter{
public:
    Fighter()
    {
        msvec.push_back(this);
    }

    Fighter(std::string name, int age) : m_name{std::move(name)}, m_age{age}
    {
        msvec.push_back(this);
    }

    ~Fighter()
    {
        /*
        auto iter = std::find(msvec.begin(), msvec.end(), this);

        if(iter != msvec.end())
            msvec.erase(iter);
        else
            std::cerr << "hata : arana deger bulunamadi\n";
        */

        //C++17 if with initilizer...
        if(auto iter = std::find(msvec.begin(), msvec.end(), this); iter != msvec.end())
            msvec.erase(iter);
        else
            std::cerr << "hata : arana deger bulunamadi\n";
    }

    Fighter(const Fighter &) = delete;
    Fighter &operator=(const Fighter &) = delete;

    void ask_help()
    {
        //range for loop
        //C++11 ile geldi

        cout << "Dusmanlar beni oldurecek\n";
        for(auto f : msvec){
              if(f != this)
                  cout << f->m_name << " ";
        }

        cout << "\nYardima kosun!!!!\n";

    }

    int Age()const
    {
        return m_age;
    }

    std::string Name()const
    {
        return m_name;
    }

    void kill();
    void run();

private:

    std::string m_name = "isimsiz";
    int m_age = 0;
    static std::vector<Fighter *> msvec;

};


//cpp
std::vector<Fighter*> Fighter::msvec{};


int main()
{
    Fighter f1{ "alican", 12};
    Fighter f2{ "kemal", 21};
    Fighter f3{ "hacer", 13};
    Fighter f4{ "muhammet", 55};

    auto pf1 = new Fighter { "hasan", 45};
    auto pf2 = new Fighter { "salih", 23};
    auto pf3 = new Fighter { "irem", 16};

    delete pf2;
    delete pf1;

    f1.ask_help();
    //alican, kemal, hacer, muhammet .... yardıma kosun ... dusmnalar beni oldurecek



    return 0;
}


/***************************************************/
/***************************************************/


 new operator
 array new operator
 delete
 array delete


new operator

tek bir nesne olusturan operator new dir

C++ da new opratoru soyle

void *operator new(size_t n)

operator new fonksiyonu ile yer elde etmede başarılı olursa

malloc ta oldugu gibi elde edilen adresi dönecek

başarısız olur ise exception handking mekanizması devre girer
bad alacotion mesajı verir


new operator yaptıgı sey arka trafta

new Point(1, 2, 3)

((Point *)(operator new(sizeof(Point)))->Point(1, 2, 3);


bu sayede dinamik omurlu nesneler olusturmus oluruz


#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p1 = new Point(2, 3, 5);
    Point *p2{ new Point(3, 6, 7) };

    auto *p3 = new Point();

    delete p;
    delete p1;

    return 0;
}



/***************************************************/
/***************************************************/

operator delete isimli fonksiyon


void operator delete(void *vp);

delete dinamik omurlu nesnelerin bellek bloklarını geri vermesini saglar
ve sınıfın destructorını cagırır


delete p

p->~Point();


1. eger nesne delete edilmez ise

 a- destructor cagrılmaz
 b- operator delete işlevi cagrılmaz

resource leak -- kaynak sızıntısı yasanır


2. dinamik omurlu ve hayatı bıten nesneyi gösteren poıinter dangling hale gelmiş olur






#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p2 = p;

    cout << "p : " << p << "\n";
    p->print();

    delete p;

    p->print();  //dangling pointer


    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    Point *p = new Point();
    Point *p2 = p;  //copy ctor

    p2 = p;//copy assigment

    cout << "p : " << p << "\n";
    p->print();

    delete p;

    p2->print();  //dangling pointer -- tanımsız davranış olmus olur
    p->print();  //dangling pointer



    return 0;
}



/***************************************************/
/***************************************************/


array new
bir degil birden fazla nesne yi hayata getirmek için kullanılır





#include <iostream>
#include "point.hpp"

using namespace std;

int main()
{
    int n;

    cout << "kac nesne : ";
    cin >> n;

    Point *p = new Point[n];

    //delete p; // tanımsız davranıs olur


    //array delete
    delete[]p;

    return 0;
}



/***************************************************/
/***************************************************/


smart pointer ve unique_ptr  devreye giriyor

delete kullanmadan belleklerini geri vermenizi saglar


bulundukları baslık dosyası

<memory>


modern C++ en onemli ögelerinden



#include <iostream>
#include "point.hpp"
#include <memory>

using namespace std;

int main()
{
    unique_ptr<Point> p{new Point(1, 2, 3)};
    p->print();
    p->set(2, 3 , 5);
    p->print();

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>
#include "point.hpp"
#include <memory>

using namespace std;

int main()
{
    unique_ptr<Point> p{new Point(1, 2, 3)};
    p->print();
    p->set(2, 3 , 5);
    p->print();

   // auto p2 = p; // copy ctor delete edilmiş

    auto p4 = move(p); // artık kaynagını p4 verildi p nin

    p4->print();

    return 0;
}



/***************************************************/
/***************************************************/

operator overloading  --- operator yüklemesi


bir sınıfın nesnesi bir operatorun operandı olmus ise
derleyici duurumdan vazife çıkartarak bunu fonksiyona cevirir

neden böyle bir araç var
programcının işini kolaylastırmak ıcın



run time maliyeti yok problem yasamayız
cunku bu işlem ceviri surecinde gercekleşir




#include <iostream>
#include <string>


using namespace std;

int main()
{
    string s1 {"Orhan"};
    string s2 {"Ozturk"};

    auto s3 = s1 + s2; //toplama operatorunu kullanıyorum

    if(s1 == s2){

    }

    return 0;
}



/***************************************************/
/***************************************************/


operator fonksiyonu

1- global operator function
2- member operator function
   non-static member function -- olmak zorunda

olablir



her operator overload edilemez


nokta operaotru
sizeof operatoru
:: scope resolution
.* operatoru
? : operatoru
typeid operatoru overload edilemez


overload edilebilne  operatorlerden bazıları

*
->
&
[]
()
tür donusturme
....




operator fonksiyonu nasıl tnaıumlanmalı

operator fonksiyonu ismi "operator" leyword taşıyacak bundan sonra hangi operator
overload ediliyor ise yazılacak

operator!
operator<

-------------------------

varsayilan argüman almazlar (default argüman)

sadece bir istisna hariç
function call () overload eden fonksiyon dışındaki hiç bir operator fonksiyonu
varsayılan argüman alamaz



----------------------------------------------------

#include <iostream>

using namespace std;

class Myclass{

};

//!x;


bool operator!(Myclass m);

//bir tane parametresi olmaz zorunda dır ! operatorunun

bool operator!(); //sentaks hatası
bool operator!(Myclass m1, Myclass m2); //sentaks hatası


int main()
{
    Myclass m;

    !m;

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator!()const;  //
    bool operator!(Myclass m)const;  // sentaks hatası
};

//!x;






int main()
{
    Myclass m;

    !m;

    return 0;
}



/***************************************************/
/***************************************************/


global fonksiyon olarak overload edilen unary operatorler tek parametre alacak
üye fonksiyon olarak overload edilen unary operatorler parametre almayacak

-----------------------------------------------------

#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator>(Myclass m1);
    bool operator>(Myclass m1, Myclass m2); //sentaks hatsı

};


bool operator>(Myclass m1); //sentaks hatası

bool operator>(Myclass m1, Myclass m2);




int main()
{
    Myclass m1, m2;

    auto m3 = m1 > m2;

    return 0;
}



/***************************************************/
/***************************************************/


global fonksiyon olarak overload edilen binary operatorler iki parametre alacak
üye fonksiyon olarak overload edilen binary operatorler bir parametre alacak


----------------------------------------------------------

bazır operatorlar bir veya iki operand alabilir


*x
x*y

+a
a+b

-b
a-b

&a
a&b



#include <iostream>

using namespace std;

class Myclass{
public:
    int &operator*(); //ıcerık operatoru
    //dereferens

};



class Matrix{
public:
    Matrix operator*(const Matrix &); // carpma operatoru

};



int main()
{
    Myclass m1, m2;

    *m1;

    Matrix mt1, mt2;

    auto mt3 = mt1 * mt2;

    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Myclass{
public:


};

int &operator*(Myclass m); //ıcerık operatoru
//dereferens


class Matrix{
public:


};

Matrix operator*(const Matrix &, const Matrix &); // carpma operatoru



int main()
{
    Myclass m1, m2;

    *m1;

    Matrix mt1, mt2;

    auto mt3 = mt1 * mt2;

    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass operator*(Myclass)const;
    Myclass operator+(Myclass)const;
    Myclass operator-(Myclass)const;
    bool operator<(Myclass)const;

};


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1*m2 + m3 < m4;

    return 0;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass operator*(Myclass)const;
    Myclass operator+(Myclass)const;
    Myclass operator-(Myclass)const;
    bool operator<(Myclass)const;

};


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1 * m2 + m3 < m4;

    //derleyici

    //öncelik yönü
    //aslında soyle olcak derleyci tarafından

    fg = m1.operator*(m2).operator+(m3).operator<(m4);

    return 0;
}



/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

class Myclass{
public:


};

//global fonksiyonlar const olamaz

Myclass operator*(Myclass, Myclass);
Myclass operator+(Myclass, Myclass);
Myclass operator-(Myclass, Myclass);
bool operator<(Myclass, Myclass);


int main()
{
    Myclass m1, m2, m3, m4;

    auto fg = m1 * m2 + m3 < m4;

    //derleyici

    //öncelik yönü
    //aslında soyle olcak derleyci tarafından

    fg = operator<(operator+(operator*(m1,m2),m3),m4);

    return 0;
}



/***************************************************/
/***************************************************/




class ostream{
public:
  ostream &operator<<(int);
  ostream &operator<<(double);
  ostream &operator<<(long);


};

std::ostream &operator<<(std::ostream &, const std::string &s);


cout <<

-------------------------------------------


#include <iostream>

using namespace std;

class Counter{
public:
    Counter operator+(int)const;
};




int main()
{
    Counter c;

    auto cx = c + 5;  // 5 + c
    cx = c.operator+(5);
    cx = 5 + c; //sentaks hatası



    return 0;
}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Counter{
public:
    //Counter operator+(int)const;
};


Counter operator+(Counter, int);
Counter operator+(int, Counter);

int main()
{
    Counter c;

    auto cx = c + 5;  // 5 + c
    //cx = c.operator+(5);
    cx = 5 + c; //sentaks hatası



    return 0;
}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    bool operator<(const Myclass &other)const
    {
        cout << "Myclass::operator<(const Myclass &other)\n";
        cout << "this  :  " << this << "\n";
        cout << "&other =  " << &other << "\n";

        return true;
    }
};


int main()
{

    Myclass mx, my;

    cout << "&mx : " << &mx << "\n";
    cout << "&my : " << &my << "\n";

    bool b = mx < my;

    cout << "b = " << b << "\n";



    return 0;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:

};


bool operator<(const Myclass &a, const Myclass &b)
{
    cout << "global operator\n";
    cout << "&a  :  " << &a << "\n";
    cout << "&b =  " << &b << "\n";

    return true;
}

int main()
{

    Myclass mx, my;

    cout << "&mx : " << &mx << "\n";
    cout << "&my : " << &my << "\n";

    bool b = mx < my;

    cout << "b = " << b << "\n";



    return 0;
}



/***************************************************/
/***************************************************/


friend declaration
arkaslik bildirimi


sinifa ait bir kod veya sınıfa ait olmayan fonksiyon sınıfın private
elemanlarına erişmesini istiyoruz. Bir kodun bizim arkadaşımız odlugunu
bildirir isek bunu sentaks hatası olarak bildirmeyecek


1. global bir fonksiyona arkadaslık vermek
2. bir sınıfın bir uye fonksiyonuna arkadaslık vermek
3. bir sınıfa arkadaslık vermek



1. global bir fonksiyona arkadaslık vermek




#include <iostream>

using namespace std;

class Myclass{
private:
    void pfunc();
    friend void gfoo(int);
public:

};


void gfoo(int x)
{
    ++x;
    Myclass m;
    m.pfunc(); //sentaks hatası friend olarka tanımlamadıgımız için
}


int main()
{

    Myclass mx, my;


    return 0;
}


/***************************************************/
/***************************************************/

friend bildirimi public veya private tada yapılaiblir  sonuc olarak anlam değişmez





#include <iostream>

using namespace std;

class Myclass{
private:
    void pfunc();
    friend void gfoo(Myclass p);
public:

};


void gfoo(Myclass m)
{
    Myclass m1;
    m1.pfunc(); //sentaks hatası friend olarka tanımlamadıgımız için
}


int main()
{

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class orhn{
public:
    void foo();
};

class Myclass{
public:
    friend void foo();

private:
    void pfunc();

};

void foo()
{
    Myclass m;
    m.pfunc();
}




int main()
{

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;



class Myclass{
public:
    friend class orhn; //sınıfn hepsine freindlik verildi

private:
    void pfunc();

};

class orhn{
public:
    void f1()
    {
        Myclass m;
        m.pfunc();
    }
};

int main()
{

    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;


class Myclass{
public:
    friend bool operator<(Myclass m1, Myclass m2) //inline
    {
        return m1.mx < m2.mx;
    }

private:
    int mx;
};



int main()
{

    return 0;
}


/***************************************************/
/***************************************************/




A sınıfı B sınıfının arkadaslık vverilmiş ise
B sınıfı A sınınfının arkadaslık verilmiş ise

A sınınıfın C sınıfına .... arkasdlık vermiş olmaz


---------------------------------------------------------------



#include <iostream>
#include "mint.hpp"

using namespace std;


int main()
{
    Mint m1, m2{23};

    cout << m1 << " " << m2 << "\n";
    cout << "iki tam sayi girin: ";
    cin >> m1 >> m2;
    cout << m1 << " " << m2 << "\n";

    if(m1 == m2)
        printf("esitler\n");
    else
        printf("degil esit\n");

    cout << boolalpha; //manipilator

    cout << m1 << " <  "  << m2  << " = " << (m1 <  m2) << "\n";
    cout << m1 << " <= "  << m2  << " = " << (m1 <= m2) << "\n";
    cout << m1 << " >  "  << m2  << " = " << (m1 >  m2) << "\n";
    cout << m1 << " >= "  << m2  << " = " << (m1 >= m2) << "\n";
    cout << m1 << " == "  << m2  << " = " << (m1 == m2) << "\n";
    cout << m1 << " != "  << m2  << " = " << (m1 != m2) << "\n";


    return 0;
}


/***************************************************/
/***************************************************/


aritmatik operatorleri


#include <iostream>
#include "mint.hpp"

using namespace std;


int main()
{
    Mint m1, m2{23};

    cout << m1 << " " << m2 << "\n";
    cout << "iki tam sayi girin: ";
    cin >> m1 >> m2;
    cout << m1 << " " << m2 << "\n";

    cout << m1 << " + "  << m2  << " = " << (m1 + m2) << "\n";
    cout << m1 << " - "  << m2  << " = " << (m1 - m2) << "\n";
    cout << m1 << " * "  << m2  << " = " << (m1 * m2) << "\n";
    cout << m1 << " / "  << m2  << " = " << (m1 / m2) << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include "mint.hpp"

using namespace std;


int main()
{
    Mint m1{10}, m2{15}, m3{19};

    auto m4 = m1 += m2 *= m3;

    cout << "m2 = " << m2 << "\n";
    cout << "m1 = " << m1 << "\n";
    cout << "m4 = " << m4 << "\n";


    return 0;
}


/***************************************************/
/***************************************************/

++m  //prefix Lvalue
m++  //posfix Rvalue

--m  Lvalue
m--  Rvalue



#include <iostream>
#include "mint.hpp"

using namespace std;


int main()
{
    Mint m1, m2{15};

    m1 = ++m2;

    cout << "m1 = " << m1 << "\n";
    cout << "m2 = " << m2 << "\n";

    m1 = m2++;

    cout << "m1 = " << m1 << "\n";
    cout << "m2 = " << m2 << "\n";

    return 0;
}


/***************************************************/
/***************************************************/



+m   --> işaret  ---> Rvalue
-m    ---> Rvalue


------------------------------

şimdi sıra özel operatorleri overload etmeye


[ ] index -- subscript operatoru
*    operatoru -- derefence

->   ok operatoru

fonsiyon cagrı operatoru
tür donusturme operatoru






[ ] index -- subscript operatoru

bu operator dondurdugu deger referans olmalı




#include <iostream>
#include "mint.hpp"

using namespace std;


class Array{
public:
    Array(size_t size, int val = 0);
    ~Array();
    Array(const Array &) = delete;
    Array &operator=(const Array &) = delete;

    int &operator[](size_t idx);

    size_t size()const{return msize;}

    //inserter dunctions
    friend std::ostream& operator<<(std::ostream &os, const Array &a);

private:
    size_t msize;
    int *mpa;

};

Array::Array(size_t size, int val) : msize{size}, mpa{new int[msize]}
{
    for(size_t i = 0; i < msize; ++i)
        mpa[i] = val;
}

Array::~Array()
{
    delete []mpa;
}

int &Array::operator[](size_t idx)
{
    return mpa[idx];
}

std::ostream& operator<<(std::ostream &os, const Array &a)
{
    os << "[";
    for (size_t i = 0; i < a.msize - 1; ++i) {
        os << a.mpa[i] << ", ";
    }

    os << a.mpa[a.msize - 1] << "]";

    return os;
}

int main()
{

    Array a{10};

    cout << a << "\n";

    for(size_t i = 0; i < a.size(); ++i)
        a[i] = i; //Lvalue

    cout << a << "\n";


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include "mint.hpp"

using namespace std;


class Array{
public:
    Array(size_t size, int val = 0);
    ~Array();
    Array(const Array &) = delete;
    Array &operator=(const Array &) = delete;

    int &operator[](size_t idx);
    const int &operator[](size_t idx)const;

    size_t size()const{return msize;}

    //inserter dunctions
    friend std::ostream& operator<<(std::ostream &os, const Array &a);

private:
    size_t msize;
    int *mpa;

};

Array::Array(size_t size, int val) : msize{size}, mpa{new int[msize]}
{
    for(size_t i = 0; i < msize; ++i)
        mpa[i] = val;
}

Array::~Array()
{
    delete []mpa;
}

int &Array::operator[](size_t idx)
{
    return mpa[idx];
}


const int &Array::operator[](size_t idx)const
{
    return mpa[idx];
}


std::ostream& operator<<(std::ostream &os, const Array &a)
{
    os << "[";
    for (size_t i = 0; i < a.msize - 1; ++i) {
        os << a.mpa[i] << ", ";
    }

    os << a.mpa[a.msize - 1] << "]";

    return os;
}

int main()
{

    //bunu const yapmamız durumunda
    //alttaki atama sentaks hatası olur
    //peki neden sentaks hatası oldu
    //cunku [] const uye fonksiyon değil
    //const olmayan bir uye fonkksiyon için cagramazsınız
    //yani const olan nesne const olan uye fonksıyonu cagırabilir

    //gecerli kılmak için operator [] const yapar isek olmaz


    //bunun için const overloading yapacaz
    //bu sayaede hem const array kullanabilecegiz
    //hemde const olmayan halinide

    const Array a{10, 5};

    auto val = a[4];
    //auto val1 = a.operator[](4);//aslında arka tarafta derleyicinin yaptıgı sey bu

    a[5] = 45; //array const oldugu için sentaks hatası oluyor

    Array a1{10, 2};

    a1[2] = 34;




    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>
#include "mint.hpp"

using namespace std;


class Array{
public:
    Array(size_t size, int val = 0);
    ~Array();
    Array(const Array &) = delete;
    Array &operator=(const Array &) = delete;

    int &operator[](size_t idx);
    const int &operator[](size_t idx)const;

    size_t size()const{return msize;}

    //inserter dunctions
    friend std::ostream& operator<<(std::ostream &os, const Array &a);

private:
    size_t msize;
    int *mpa;

};

Array::Array(size_t size, int val) : msize{size}, mpa{new int[msize]}
{
    for(size_t i = 0; i < msize; ++i)
        mpa[i] = val;
}

Array::~Array()
{
    delete []mpa;
}

int &Array::operator[](size_t idx)
{
    return mpa[idx];
}


const int &Array::operator[](size_t idx)const
{
    return mpa[idx];
}


std::ostream& operator<<(std::ostream &os, const Array &a)
{
    os << "[";
    for (size_t i = 0; i < a.msize - 1; ++i) {
        os << a.mpa[i] << ", ";
    }

    os << a.mpa[a.msize - 1] << "]";

    return os;
}

int main()
{
    Array a{10};

    //range for loop yapabilirmiyim

    //suan için gecerli değil ama yapmaak mumkun ileride görecez ve yapacaz
    for (auto val : a) {

    }

    return 0;
}


/***************************************************/
/***************************************************/


içerik operatoru [dereferencing]

-> operatoru - member selection - arrow op




#include <iostream>


using namespace std;


class Tint
{
public:
    Tint() = default;
    explicit Tint(int val) : mval{val}
    {
        cout << "Tint constructor val = " << val << "  this = " << this << "\n";
    }

    ~Tint()
    {
        cout << "Tint destructor this = " << this << "\n";
    }

    int Tint::getMval() const
    {
        return mval;
    }

    void Tint::setMval(int value)
    {
        mval = value;
    }


    friend std::ostream &operator<<(std::ostream &os, const Tint val);
    friend std::istream &operator>>(std::istream &is, Tint &val);

private:
    int mval{};
};

std::ostream &operator<<(std::ostream &os, const Tint val)
{
    return os << "[ " << val.mval << " ] ";
}

std::istream &operator>>(std::istream &is, Tint &val)
{
    return is >> val.mval;
}

//dinamik omurlu tint nesne gibi davranacak
//içerik ve ok operatorunu overload edecez

class TintPtr{
public:
    explicit TintPtr(Tint *pt) :  mptr{pt}{}

    TintPtr(const TintPtr &) = delete;
    TintPtr &operator=(const TintPtr &) = delete;

    ~TintPtr()
    {
        if(mptr)
            delete mptr;
    }

    Tint &operator*()
    {
        return *mptr;
    }

    //ptr->func()
    //derleyici su sekil ele alıyor
    //ptr.operator->()->func()

    Tint *operator->()
    {
        return mptr;
    }

private:
      Tint *mptr;
};

int main()
{
    cout << "main basladi\n";

    {
        //constructur explicit oldugu için bu sentaks hatası
        //TintPtr ptr = new Tint{2};

        TintPtr ptr{new Tint{2}};

        std::cout << *ptr << "\n";

        std::cout << ptr->getMval() << "\n";
        ptr->setMval(12);
        std::cout << ptr->getMval() << "\n";


    }

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>


using namespace std;


class Tint
{
public:
    Tint() = default;
    explicit Tint(int val) : mval{val}
    {
        cout << "Tint constructor val = " << val << "  this = " << this << "\n";
    }

    ~Tint()
    {
        cout << "Tint destructor this = " << this << "\n";
    }

    int Tint::getMval() const
    {
        return mval;
    }

    void Tint::setMval(int value)
    {
        mval = value;
    }


    friend std::ostream &operator<<(std::ostream &os, const Tint val);
    friend std::istream &operator>>(std::istream &is, Tint &val);

private:
    int mval{};
};

std::ostream &operator<<(std::ostream &os, const Tint val)
{
    return os << "[ " << val.mval << " ] ";
}

std::istream &operator>>(std::istream &is, Tint &val)
{
    return is >> val.mval;
}

//Meta koda ceviriyorum
//ileriki konulara deyinmek için

template <typename  T>
class SmartPtr{
public:
    explicit SmartPtr(T *pt) :  mptr{pt}{}

    SmartPtr(const SmartPtr &) = delete;
    SmartPtr &operator=(const SmartPtr &) = delete;

    ~SmartPtr()
    {
        if(mptr)
            delete mptr;
    }

    T &operator*()
    {
        return *mptr;
    }

    //ptr->func()
    //derleyici su sekil ele alıyor
    //ptr.operator->()->func()

    T *operator->()
    {
        return mptr;
    }

private:
      T *mptr;
};

int main()
{
    cout << "main basladi\n";

    {
        SmartPtr<Tint> ptr{new Tint{2}};


        cout << *ptr << "\n";

        cout << ptr->getMval() << "\n";

    }

    return 0;
}


/***************************************************/
/***************************************************/

 yeni konu endl


#include <iostream>

using namespace std;

//mumkun oldugunca kullanmayın
//sadece amacımız bir alt satıra gecmek ise
//"\n" kullanıın gereksiz yere flush kullanmayınız

std::ostream &Endl(std::ostream& os)
{
    os << "\n";
    os.flush(); //flush

    return os;
}


int main()
{

    int ival = 10;
    double dval = 3.45;

    cout << ival << Endl << dval << Endl;

    return 0;
}


/***************************************************/
/***************************************************/

Fonksiyon cagrı operatorunun ıverload edilmesi

#include <iostream>

using namespace std;

class Functor{
public:
    int  operator()(int val)const
    {
        cout << "int Functor::operator()(int val)\n";
        cout << "val = " << val << "\n";
        cout << "this : " << this << "\n";

        return val*val;
    }
};


int main()
{
    Functor f;
    cout << "&f = " << &f << "\n";

    auto val = f(10);
    cout << "val = " << val << "\n";


    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Functor{
public:
    //varsayılan arguman alabilir
    int  operator()(int val = 15)const
    {
        cout << "int Functor::operator()(int val)\n";
        cout << "val = " << val << "\n";
        cout << "this : " << this << "\n";

        return val*val;
    }
};


int main()
{
    Functor f;
    cout << "&f = " << &f << "\n";

    auto val = f();
    cout << "val = " << val << "\n";


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Functor{
public:
    //varsayılan arguman alabilir
    int  operator()(int val = 15)const
    {
        cout << "int Functor::operator()(int val)\n";
        cout << "val = " << val << "\n";
        cout << "this : " << this << "\n";

        return val*val;
    }

    int operator()(int x, int y)const
    {
        return x + y;
    }
};


int main()
{
    Functor f;
    cout << "&f = " << &f << "\n";

    auto val = f();
    cout << "val = " << val << "\n";

    auto val2 = f(3, 4);
    cout << "val2 = " << val2 << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Functor{
public:
    //varsayılan arguman alabilir
    int  operator()(int val = 15)const
    {
        cout << "int Functor::operator()(int val)\n";
        cout << "val = " << val << "\n";
        cout << "this : " << this << "\n";

        return val*val;
    }

    int operator()(int x, int y)const
    {
        return x + y;
    }
};


int main()
{
    Functor f;
    cout << f.operator()(12) << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Random{
public:
    Random(int low, int high) : mlow{low}, mhigh{high}{}
    int operator()()
    {
        ++cnt;
        return rand() % (mhigh - mlow - 1) + mlow;
    }

    int getCnt() const
    {
        return cnt;
    }

private:
    int mlow, mhigh;
    int cnt = 0;
};


int main()
{
    Random rand1{234, 555};

    for (int i = 0; i < 10; ++i) {
        cout << rand1() << "  ";
    }
    cout << "\n";
    cout << "\n";

    Random rand2{21, 33};

    for (int i = 0; i < 22; ++i) {
        cout << rand2() << "  ";
    }
    cout << "\n";
    cout << "\n";

    cout << "rand1 icin call count = " << rand1.getCnt() << "\n";
    cout << "rand2 icin call count = " << rand2.getCnt() << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Random{
public:
    Random(int low, int high) : mlow{low}, mhigh{high}{}
    int operator()()
    {
        ++cnt;
        return rand() % (mhigh - mlow - 1) + mlow;
    }

    int getCnt() const
    {
        return cnt;
    }

private:
    int mlow, mhigh;
    int cnt = 0;
};

void foo(Random x)
{
    cout << "foo cagrildi\n";
    int val = x();
}

int main()
{
    foo(Random{12, 55});

    return 0;
}


/***************************************************/
/***************************************************/

tur donusturme operator fonksiyonu overload edilmesi




#include <iostream>

using namespace std;

class Myclass{
public:

};

int main()
{
    Myclass m;

    int ival{};

    ival = m; //bu turun otomatik tur donusumu yok sentaks hatsı

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(int val) : mval{val}{}
    operator int()const; // int turune donusum yapılması ıcın
    operator double()const; //double tur dnusumu var

private:
    int mval;

};

int main()
{
    Myclass m;

    int ival{};

    ival = m; //bu turun otomatik tur donusumu yok sentaks hatsı

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(int val) : mval{val}{}
    operator int()const
    {
        return mval;
    }

private:
    int mval;

};

int main()
{
    Myclass m{15};

    int ival{};

    ival = m;
    //ival = m.operator int();

    cout << "ival = " << ival << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(int val) : mval{val}{}
    operator int()const
    {
        return mval;
    }

private:
    int mval;

};

int main()
{
    Myclass m{15};

    double ival{};

    ival = m;
    //olay soyle ılerlıyor
    //ilk once m int turune donusuyor
    //sonra da double turune otomatik tür donusumu oluyor
    //tabı boyle donusumleri kullanmayınız


    cout << "ival = " << ival << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(int val) : mval{val}{}
    explicit operator int()const
    {
        return mval;
    }

private:
    int mval;

};

int main()
{
    Myclass m{15};

    double ival{};

    ival = m; //artık gecersiz

    cout << "ival = " << ival << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass() = default;
    Myclass(int val) : mval{val}{}
    explicit operator int()const
    {
        return mval;
    }

private:
    int mval;

};

int main()
{
    Myclass m{15};

    double ival{};

    ival = static_cast<int>(m); //artık gecerli, bilincli olarak yaptıgımız icin

    cout << "ival = " << ival << "\n";

    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>
#include <string>

using namespace std;


int main()
{
    string str = "orhan"; //const char * dan string donusum var

    //const char *p = str; //string den const char * donusum yok

    const char *p1 = str.c_str();


    return 0;
}


/***************************************************/
/***************************************************/



int main()
{
    int ival = 10;

    if(ival){

    }

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>


using namespace std;

class Myclass{
public:

};

int main()
{
    Myclass m;

    if(m){ //gecersiz bool turunde bir donusum olması lazım  sınıfın

    }

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>


using namespace std;

class Myclass{
public:
    operator bool()const
    {
        return true;
    }
};

int main()
{
    Myclass m;

    if(m){ //gecersiz bool turunde bir donusum olması lazım  sınıfın

    }

    return 0;
}


/***************************************************/
/***************************************************/


  !expr

 expr && epxr2
 expr || expr3

 bunun gibi lojik ifadeler bool oalrak degerlendirilir




#include <iostream>


using namespace std;

class Myclass{
public:
    operator int()const
    {
        return true;
    }
};

int main()
{
    Myclass m;

    if(m){ //şimdi gecerli ama dikkat

    }

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>


using namespace std;

class Myclass{
public:
    operator bool()const
    {
        return true;
    }
};

int main()
{
    Myclass m;

    if(m){ //şimdi daha iyi


    }

    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>
#include "mint.hpp"

using namespace std;


int main()
{
    Mint m;

    cout << "bir tam sayi giriniz : ";
    cin >> m;
    cout << "x = " << m << "\n";

    if(m)
        cout << "dogru\n";
    else
        cout << "yanlis\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include "mint.hpp"
#include <memory>

using namespace std;


int main()
{
    //explicit oldugu iiçin copy init ile veremeyiz deger
    //unique_ptr<Mint> uptr = new Mint{1};

    unique_ptr<Mint> uptr;
    unique_ptr<Mint> uptr1{new Mint{1}};

    if(uptr)
        cout << "uptr dogru\n";
    else
        cout << "uptr yanlis\n";

    if(uptr1)
        cout << "uptr1 dogru\n";
    else
        cout << "uptr1 yanlis\n";

    Mint uptr2{3};
    int ival = (uptr2); // setaks hatası bool tür donusumu explixit oldugu için convert ederken sentaks hatsı olru

    return 0;
}


/***************************************************/
/***************************************************/


composition
nested types
string sınıfı

enum class
++
-- operatorlerini overload emtek gerekiyor


#include <iostream>

using namespace std;

//underline type secebiliyoruz
enum class WeekDay : int {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};

std::ostream &operator<<(std::ostream &os, WeekDay wd)
{
    static constexpr const char *const pwdays[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

    return os << "(" << pwdays[static_cast<int>(wd)] << ")";
}

int main()
{
    WeekDay wd{WeekDay::Monday};

    cout << wd << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//underline type secebiliyoruz
enum class WeekDay : int {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};

std::ostream &operator<<(std::ostream &os, WeekDay wd)
{
    static constexpr const char *const pwdays[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

    return os << "(" << pwdays[static_cast<int>(wd)] << ")";
}

//önek ++ operatoru overloading
WeekDay &operator++(WeekDay &wd)
{
    return wd = wd == WeekDay::Saturday ? WeekDay::Sunday : static_cast<WeekDay>(static_cast<int>(wd) + 1);
}

int main()
{
    WeekDay wd{WeekDay::Monday};

    for (; ;) {
        cout << ++wd;
        getchar();
    }

    return 0;
}


/***************************************************/
/***************************************************/

composition - containment (içerme) -- bir sınıfın bir baska sınıf turunden nesneye sahip olması


sınıflar arasında ilişkiler var, bu snıflar arasında işbirliği içinde çalışması gerekiyor
buna compositionilişkisi denir

bu iki sınıf türünden nesne haytaları aynı anda bitecek
cunku bir sınıf diger sınıfın türünden nesneye sahip


class Engine{

};

class Car{
private:
   Engine eng;
};

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//incomplite tanım
class Engine;

//incomplete type türünden elemana sahip olamaz compliti sınıf
class Car{
private:
    Engine eng;
};


int main()
{


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//Engine sınıfını butun elemanların erişim vermemek
//clientlara private elemanlara göstermemek
//buna pimpl idiomu denir


class Engine
{
public:
    void start();
    void stop();
    void run();
};

class Car{
public:

private:
    Engine eng;
};


int main()
{
    Car mycar;

    //egine sınıfından elemana sahip olmak publice erişim anlamına gelmez
    mycar.run(); //sentaks hatası


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//Engine sınıfını butun elemanların erişim vermemek
//clientlara private elemanlara göstermemek
//buna pimpl idiomu denir


class Engine
{
private:
    void maintain();
    void repair();

public:
    void start();
    void stop();
    void run();
};

class Car{
public:
    void func()
    {
        //car sınıfıunı içinden
        //publice erişim var
        //private erişim yok
        eng.run();
    }

private:
    Engine eng;
};


int main()
{
    Car mycar;

    //egine sınıfından elemana sahip olmak publice erişim anlamına gelmez
    mycar.run(); //sentaks hatası


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//Engine sınıfını butun elemanların erişim vermemek
//clientlara private elemanlara göstermemek
//buna pimpl idiomu denir


class Engine
{
private:
    void maintain();
    void repair();

public:
    void start();
    void stop();
    void run();
};

class Car{
public:
    void func()
    {
        //car sınıfıunı içinden
        //publice erişim var
        //private erişim yok
        eng.run();
    }

private:
    Engine eng;
};


int main()
{
    Car mycar;
    Engine eng;

    mycar = eng; // bunlar arasında hiçbir ilişki yoktur
    //bu yuzdende otomatık donusum olmaz


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//Engine sınıfını butun elemanların erişim vermemek
//clientlara private elemanlara göstermemek
//buna pimpl idiomu denir


class Engine
{
public:
    void start()
    {
        cout << "Engine has started\n";
    }
    void stop();
    void run();
};

class Car{
public:
    void start()
    {
        eng.start();
    }

private:
    Engine eng;
};


int main()
{
    Car mycar;

    mycar.start();


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Member{
public:
    Member()
    {
        cout << "Member default ctor\n";
    }

    ~Member()
    {
        cout << "Member dctor\n";
    }

};

class Owner{
private:
    Member mx;
};


int main()
{
    Owner ox;


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Member{
public:
    Member()
    {
        cout << "Member default ctor\n";
    }

    ~Member()
    {
        cout << "Member dctor\n";
    }

};

class Owner{
public:
    Owner() : mx{}
    {
        cout << "Owner default ctor\n";
    }

    ~Owner()
    {
        cout << "Owner destructor\n";
        //derleyici soyle yapar
        //mx.~Member();
    }

private:
    Member mx;
};


int main()
{
    Owner ox;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

class Member{
public:
    Member(int x)
    {
        cout << "Member (int x) ctor x = " << x << "\n";
    }

    ~Member()
    {
        cout << "Member dctor\n";
    }

};

class Owner{
public:
    //Owner() = delete; bunu tanımlamazsan derleyici otomatik delete eidyor bu sekılde

private:
    Member mx;
};


int main()
{
    //derleyici default ctor delete etti Owner Classın
    Owner ox;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Member{
public:
    Member(int x)
    {
        cout << "Member (int x) ctor x = " << x << "\n";
    }

};

class Owner{
public:
    Owner() : mx{10}
    {
        cout << "Owner defaurlt ctor\n";
    }

private:
    Member mx;
};


int main()
{
    //artık gecerli biz yazdıgımız için
    Owner ox;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>
#include <string>


using namespace std;

class Myclass{
public:
    Myclass(size_t n) : mvec(n)
    {

    }

private:
        std::vector<std::string> mvec;
};


int main()
{
    Myclass m{200};
    //Myclass m; //sentaks hatası default ctor olmadıgı için

    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>
#include <vector>
#include <string>


using namespace std;

class Myclass{
public:

private:
     std::string mstr;
};


int main()
{
    Myclass m;//derleyici default ctor yazdı
    //eger string kutuphanesinin default ctro olmasaydı
    //myclassın default ctor olacaktı ama derleyici delete edecekti bunu

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <vector>
#include <string>


using namespace std;

class Myclass{
public:
    Myclass(size_t n) : mstr(n, 'A'){}
    Myclass(size_t n, char c) : mstr(n, c){}
    void print()const
    {
        cout << mstr << "\n";
    }

private:
     std::string mstr;
};


int main()
{
    Myclass m{5};
    m.print();

    Myclass m1{13, 'T'};
    m1.print();

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>
#include <vector>
#include <string>


using namespace std;

class Myclass{
public:
    void print()const
    {
        cout << mstr << "\n";
    }

private:
    std::string mstr{"orhan"};
    //bunu yazmamız ile default ctor buna göre olsuurulacak
};


int main()
{
    Myclass m;

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include "mint.hpp"

using namespace std;

class Myclass{
public:
    void print()const
    {
        cout << "( " << mx << " )" <<"\n";
    }

private:
    Mint mx;
};


int main()
{
    Myclass m;

    m.print();

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include "mint.hpp"

using namespace std;

class Myclass{
public:
    void print()const
    {
        cout << "( " << mx << " )" <<"\n";
    }

private:
    Mint mx = 20; //explicit oldugu için sentaks hatası
};


int main()
{
    Myclass m;

    m.print();

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include "mint.hpp"

using namespace std;

class Myclass{
public:
    void print()const
    {
        cout << "( " << mx << " )" <<"\n";
    }

private:
    Mint mx{20}; //şimdik gecerli
};


int main()
{
    Myclass m;

    m.print();

    return 0;
}


/***************************************************/
/***************************************************/

Ozel diğer uye fonksiyponların composition daki durumları



copy ctor

#include <iostream>
#include "mint.hpp"

using namespace std;

class Member{
public:
    Member() = default;
    Member(const Member &)
    {
        cout << "member copy ctor\n";
    }


private:
};

class Owner{
private:
    Member mx;
};


int main()
{
    Owner ox;

    Owner oz{ox}; //copy ctor deryici yazar

}


/***************************************************/
/***************************************************/
#include <iostream>
#include "mint.hpp"

using namespace std;

class Member{
public:
    Member() = default;
    Member(const Member &)
    {
        cout << "member copy ctor\n";
    }


private:
};

class Owner{
public:
    Owner() = default;

    /* derleyici boyle yazar
    Owner(const Owner &other) : mx{other.mx}
    {
        cout << "Owner copy ctor\n";
    }
    */
    //ben yazmaya nyet ettim
    //default ctor cagrıldı
    //mx {other.mx } yazmamı gerekliydi
    Owner(const Owner &other)
    {
        cout << "Owner copy ctor\n";
    }

private:
    Member mx;
};


int main()
{
    Owner ox;

    Owner oz{ox};

}


/***************************************************/
/***************************************************/



copy assigment

#include <iostream>
#include "mint.hpp"

using namespace std;

class Member{
public:
    Member &operator=(const Member &other)
    {
        cout << "member copy assignment function\n";
        return *this;
    }


private:
};

class Owner{
public:

    Owner &operator=(const Owner &other)
    {
        cout << "Owner copy assignment function\n";

        //eger programcı yazar ise
        //bunun sorumlulugu programcıda
        //mx = other.mx;

        return *this;
    }

private:
    Member mx;
};


int main()
{
    Owner ox;

    Owner oz;

    oz = ox;

}


/***************************************************/
/***************************************************/
/***************************************************/
/***************************************************/
move ctor

Myclass(Myclass &&other) : ax{std::move(other.ax)), by{std::move(other.by)}{}

eger biz yazıyor isek bunu oglerın tasınma işleminide biz yapmamız lazım


/***************************************/

move assasignment
#include <iostream>
#include "mint.hpp"

using namespace std;

class Member{
public:
    Member &operator=(const Member &other)
    {
        cout << "member copy assignment function\n";
        return *this;
    }


private:
};

class Owner{
public:

    Owner &operator=(const Owner &other)
    {
        cout << "Owner copy assignment function\n";

        //eger programcı yazar ise
        //bunun sorumlulugu programcıda
        //mx = other.mx;

        return *this;
    }

    Owner &operator=(Owner &&other)
    {
        cout << "Owner move assigmnet function\n";
        //bunun sorumlulugu bende
        mx = std::move(other.mx);

        return *this;
    }

private:
    Member mx;
};


int main()
{
    Owner ox;

    Owner oz;

    oz = ox;

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <vector>

using namespace std;

class istack{
public:
    void push(int val);
    void pop();
    int &top();
    const int &top()const;
    bool empty()const;
    size_t size()const;

private:
    vector<int> mvec;

};

void istack::push(int val)
{
    mvec.push_back(val);
}

void istack::pop()
{
    mvec.pop_back(); //cıakrtma
}

int & istack::top()
{
    return mvec.back();
}

const int & istack::top() const
{
    return mvec.back();
}

bool istack::empty() const
{
    return mvec.empty();
}

size_t istack::size() const
{
    return mvec.size();
}

int main()
{

    istack mystack;

    for (int i = 0; i < 10; ++i) {
        mystack.push(i);
    }

    cout << "size : " << mystack.size() << "\n";

    while (!mystack.empty()) {
        cout << mystack.top() << "\n";
        mystack.pop();
    }

}


/***************************************************/
/***************************************************/

içsel türler (nested types)

types members
member types


#include <iostream>

using namespace std;

class Myclass{
    class Data{

    };

    enum class  Color{Blue, Red, Green};

    typedef int World;

    using iptr = int;

};


int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:
    class Data{

    };

};


int main()
{
    //sentaks hatası
    //Data mydata;

    Myclass::Data mydata; // içsel türden nesne

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Myclass{
public:

    Data mydata; //sentaks hatası tanımı alt kısımda kaldıgı için
    class Data{

    };

};


int main()
{
    //sentaks hatası
    //Data mydata;

    Myclass::Data mydata; // içsel türden nesne

}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

class Myclass{
public:
    class Data{

    };

    Data mydata; //artık gecerli
};


int main()
{
    //sentaks hatası
    //Data mydata;

    Myclass::Data mydata; // içsel türden nesne

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

typedef int Data;

class Myclass{
public:
    Data mydata; //eş isim olan int türünün Data sı
    class Data{

    };

};


int main()
{
    //sentaks hatası
    //Data mydata;

    Myclass::Data mydata; // içsel türden nesne

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

typedef int Data;

class Myclass{
public:
    Data myHacer; //typedef eş isminin türü

    class Data{

    };

    Data mydata; // class Data nin türü
};


int main()
{
    //sentaks hatası
    //Data mydata;

    Myclass::Data mydata; // içsel türden nesne

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Word{
public:
    void foo();
};

class Myclass{
private:
    void func()
    {
        Word w;  // int eş ismi
        w.foo(); //sentaks hatası
    }

    typedef int Word;
};

//cpp


int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
    class Nested{
    private:
        void foo();
    };

    void func()
    {
        Nested ns;
        ns.foo(); // sentaks hatası erişim yok neden private;
    }
};



int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
    class Nested{
    private:
        friend class Encloser;
        void foo();
    };

    void func()
    {
        Nested ns;
        ns.foo(); // fiend verildşğiiçin gecerli
    }
};



int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Data{

    };

    class Nested{
        Data md;
        //eski c++ gecerli değildi
        //modern c++ ile gecerli
    };
};



int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    static void sfunc();

    class Nested{
        void foo()
        {
            sfunc();
            //eskiden bu gecerli değildi
            //modern c++ ile gecerli hale geldi
        }
    };
};



int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Nested{

    };

public:
    static Nested foo();
};


int main()
{
    //clientların erişimi yok
    Encloser::Nested ns = Encloser::foo(); //sentaks hatsı private erişim yok

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Nested{
    public:
        void nf();
    };

public:
    static Nested foo();
};


int main()
{
    //clientların erişimi yok
    //Encloser::Nested ns = Encloser::foo(); //sentaks hatsı private erişim yok
    auto as = Encloser::foo(); //boyle erişim mevcut
    as.nf();
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Nested{

    };

    Encloser::Nested x; //bu sekılde tanımlama yapabiliriz

};


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Nested{

    };

    void func();

};

//cpp
void Encloser::func()
{
    Nested x;
}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        void func(Nested x);

    };

};

//cpp
void Encloser::Nested::func(Nested x)
{
    Nested y;
}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
private:
    class Nested{
    public:
        void func(Nested x);

    };

};

//cpp
void Encloser::Nested::func(Nested x)
{
    Nested y;
}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        void func(Nested x);
        Nested foo();

    };

};

//cpp
void Encloser::Nested::func(Nested x)
{
    Nested y;
}

Encloser::Nested Encloser::Nested::foo()
{
    return Nested{};
}

int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        Nested(const Nested &); //copy ctor

    };

};

//cpp

Encloser::Nested::Nested(const Nested &)
{

}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        int func(int x)
        {
            //
            return x;
        }

    };

};

//cpp



int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        int func(int x)
        {
            //
            return x;
        }

        int foo(int y);

    };

};

//cpp
int Encloser::Nested::foo(int y)
{
    return y;
}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//içsel türe sahip olan sınıf ---> Enclosing type
//içsel türe ---> nested type


class Encloser{
public:
    class Nested{
    public:
        int func(int x)
        {
            //
            return x;
        }

        int foo(int y);
        int f(int);

    };

    //boyle bir tnaımlama yapılamaz
    int Nested::f(int)
    {

    }

};

//cpp
int Encloser::Nested::foo(int y)
{
    return y;
}


int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int>::iterator;
    vector<int>::difference_type;
    vector<int>::const_iterator;
    vector<int>::size_type;
    vector<int>::pointer;
    vector<int>::reference;
}


/***************************************************/
/***************************************************/

yuzeysel bir iterator yapısı mantık olusması için yaptık


#include <iostream>

using namespace std;

class Myclass{};

class Vector{
public:

    class iterator{
        //
    public:
        Myclass &operator *();
        Myclass *operator->();
    };

    iterator begin();
    iterator end();
};

int main()
{
    Vector myvec;

    Vector::iterator iterBegin = myvec.begin();
    Vector::iterator iterEnd = myvec.end();


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>

using namespace std;

class Myclass{
public:
    void func();
};

int main()
{
    vector<Myclass> myvec;

    vector<Myclass>::iterator iterBegin = myvec.begin();

    auto iterB = myvec.begin();

}


/***************************************************/
/***************************************************/

eski pimpl idomuna ornek verelim

cashire cat
handle body
pimpl
opaque pointer


veri gizleme için kullanılmaktadır


eski pimpl
#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass();
    ~Myclass();

    void func();

private:
    struct Pimpl; //pointer implementain
    Pimpl *ptr;
    //opac pointer
};

//cpp
struct Myclass::Pimpl{
    //bu türler class türü de oşlablir
    //ki kullanımı coktur
    int a;
    double b;
    void fuu();
};

Myclass::Myclass() : ptr{new Pimpl}
{

}

void Myclass::func()
{
    ptr->a;
    ptr->b;
    ptr->fuu();
}


Myclass::~Myclass()
{
    delete ptr;
}


int main()
{

}


/***************************************************/
/***************************************************/


yeni pimpl

#include <iostream>
#include <memory>

using namespace std;

class Myclass{
public:
    Myclass();
    ~Myclass();

    void func();

private:
    struct Pimpl; //pointer implementain
    unique_ptr<Pimpl> uptr;
    //opac pointer
};

//cpp
struct Myclass::Pimpl{
    //bu türler class türü de oşlablir
    //ki kullanımı coktur
    int a;
    double b;
    void fuu();
};

Myclass::Myclass() : uptr{new Pimpl}
{

}

void Myclass::func()
{
    uptr->a;
    uptr->b;
    uptr->fuu();
}

int main()
{

}


/***************************************************/
/***************************************************/


HW 1 odevi verildi Data sınıfı
Date : 05.04.2022

//test kodu

#include <iostream>
#include "date.hpp"

using namespace std;


int main()
{
    Date mydate; //1.1.1900
    Date t1 = {12, 3, 1987};
    //Date t2 = {"05.04.1983"};  //explicit yapılır ise bu sentaks hatsına duser
    //şimdi gecerli explicit olsada
    Date t2{"05.04.1983"};

    Date t3{15000000};

    t2.set_month_day(22);
    cout << mydate.get_year_day();

    cout << t1 + 145 << "\n";
}

/***************************************************/
/***************************************************/

delegating constructor
user defined literals

string class ı


/***************************************************/
/***************************************************/


delegating constructor

bir constructor bir başka constructor tarafından çağrılması


#include <iostream>

using namespace std;

class Orhn{
public:
    Orhn();
    Orhn(int);
    Orhn(int, int, int);
    Orhn(const char *);

private:
    void init();
    //Ortak kod
};

int main()
{

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

class Orhn{
public:
    Orhn() : Orhn(0, 0, 0)
    {

    }

    Orhn(int x) : Orhn{x, x, x}
    {

    }

    Orhn(int a, int b, int c) : mx{a}, my{b}, mz{c}
    {

    }

    Orhn(const char * p) : Orhn(std::atoi(p), std::atoi(p+2), std::atoi(p+4))
    {

    }

private:
    int mx, my, mz;
};

int main()
{

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

class Orhn{
public:
    Orhn(int, int); //delege edilen

    Orhn(int x) : Orhn(x, x)
    {

    }

private:
    int mx, my, mz;
};

int main()
{

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

class Orhn{
public:
    Orhn() : Orhn(0, 0){}
    Orhn(int, int);
    Orhn(int, int, int);
    Orhn(int, int, int, int);

    //bu contrctorlar birbirinin deleget edebilir
    //fakat reucersive olmamalıdır bu programcı sourmlulugunda

private:
    int mx, my, mz;
};

int main()
{

}



/***************************************************/
/***************************************************/



user defined literals


12u  --> unsigned int
12m  --> programcı tarafından ele alınan tür gibi düşünecez


C++14 ile dile eklendi...


#include <iostream>
#include <string>

using namespace std;


int main()
{

    string str{"orhn"};

    auto s = "orhn"s; //s eklentisis ile s türü const char * dan çıkar string olur
    s;

}



/***************************************************/
/***************************************************/



#include <iostream>
#include <string>
#include <chrono>

using namespace std;
using namespace chrono;

int main()
{
    auto sec = 24s;
    auto min = 35min;
    auto ns = 34567ns;

}



/***************************************************/
/***************************************************/


user defined literals

tam sayıalr için unsigned long long int
gecek sayılar da long double

const char *



#include <iostream>


double operator""_km(long double val)
{
    std::cout << "user defined literal op function\n";
    return static_cast<double>(val) * 1000.;
}

int main()
{

    auto m = 2.4_km;

    std::cout << "distance : " << m << "\n";

}



/***************************************************/
/***************************************************/

#include <iostream>


constexpr double operator""_km(long double val)
{
    return static_cast<double>(val) * 1000.;
}


constexpr double operator""_m(long double val)
{
    return static_cast<double>(val);
}


constexpr double operator""_cm(long double val)
{
    return static_cast<double>(val) / 100.;
}


constexpr double operator""_mm(long double val)
{
    return static_cast<double>(val) / 1000.;
}


int main()
{

    constexpr auto distance = 2.4_km + 12.6_m + 345645._cm + 2343._mm;

    std::cout << "distance : " << distance << "\n";

}



/***************************************************/
/***************************************************/


#include <iostream>


constexpr unsigned long long int operator""_KB(unsigned long long int kbytes)
{
    return 1024 * kbytes;
}

int main()
{

    constexpr auto term = 16_KB;

    std::cout << "term = " << term << "\n";

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <array>

namespace ORHN {
    constexpr size_t operator""_KB(unsigned long long int kbytes)
    {
        return static_cast<size_t>(1024 * kbytes);
    }

    constexpr size_t operator""_MB(unsigned long long int kbytes)
    {
        return static_cast<size_t>(1024 * 1024 * kbytes);
    }
}

int main()
{
    using namespace ORHN;
    auto _size{ 4_KB };

    std::cout << "_size : " << _size << "\n";

    using byte = unsigned char;

    auto buf1 = std::array<byte, 16_KB>{};
    auto buf2 = std::array<byte, 1_MB>{};

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <array>
#include "date.hpp"
#include <cstdlib>

using namespace std;

int main()
{
    auto date = "03.06.1992"_d;
    date;

}



/***************************************************/
/***************************************************/


---- string -----

cstring dediğimizde --> sonunda "\0" karateri tutan bir yazı


"ahmet" artık C de ki gibi char * dizi degil const char * dizisidir


stl in standart kutuphanesiinn bir konteynarıdır

<string>

<cstring> --> karıztırmıyoruz bu C nin C++ daki halidr



#include <iostream>
#include <string>

using namespace std;

int main()
{

    //string str;
    //string aslında eş ismi budur
    basic_string<char, char_traits<char>>;


}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

int main()
{

    cout << typeid (string).name() << "\n";

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

int main()
{

    cout << "sizeof string : " << sizeof (string) << "\n";
    cout << "sizeof char * : " << sizeof (char *) << "\n";

    //small string optimization oldugu için
    //eger girilen string kucuk ise string sınıfının içinde hazır bir dizi yapısı
    //bu dizide tutulur
    //buyuk ise o zman daha fazla alan alınır heap ten

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

//standart algoritma sınıfları bu alttaki gibidir

#include <algorithm>
#include <numeric>



int main()
{



}



/***************************************************/
/***************************************************/



#include <iostream>
#include <string>

using namespace std;



int main()
{

    string::size_type size;

    /*
     * yazının uzunlugunun turudur
     * index türüdür
     * tane adet türüdür
     */


}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;



int main()
{

    string str; //default ctor

    //size lenght  ikiside aynı amaca sahip
    //size aslında konteynarlar için ortak arayuzlerinden bir tanesi


}



/***************************************************/
/***************************************************/





#include <iostream>
#include <string>

using namespace std;


int main()
{

    string str{"orhan ozturk gelesne"};

    cout << "size : " << str.size() << "\n";
    cout << "lenght : " << str.length() << "\n";
    cout << "capacity : " << str.capacity() << "\n";//dinamik bellek boyutunu gösterir


}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

   string str("alican");
   string str1{"orhn"}; //eski C++ gecerli degildi
   string str2 = "orkun"; //explicit degil

   display_string(str);
   display_string(str1);
   display_string(str2);

}



/***************************************************/
/***************************************************/



#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //altaki tanımlamaların heps farklıdır
    //ilişki yoktur farklı kaynak kullanır
    string s1{"orhan ozturk"};
    string s2(s1);
    string s3{s1};
    string s4 = s1;

   display_string(s2);
   display_string(s3);
   display_string(s4);

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};
    string s2(move(s1)); //move ctor

     display_string(s1);
    display_string(s2);


}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //data ctor

    char str[] = "0123456789";

    string s1{str, 4};
    string s2{str + 3, 3};
    string s3{str, 40};//tanımsız davranış dikkat


    display_string(s1);
    display_string(s2);
    display_string(s3);

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};
    string s2(s1, 2, 3);
    string s3(s1, 0, 5);

    display_string(s2);
    display_string(s3);

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};
    string s2(s1, 2);
    string s3(s1, 0);

    display_string(s2);
    display_string(s3);

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};
    string s2(s1, 2, 1000); //bu gecerli durum geriye kalan hepsini demek


    display_string(s2);

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //fill ctor

    string s1(80, 'A');
    display_string(s1);

    string s2{80, 'A'}; //burda 80 ni karater kodu olarak algılıyor bu yuzden PA pcıkıyor
    display_string(s2);



}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    char str[] = {"0123456789"};

    string s1(str+2, 5);
    string s2{str + 2, str+5};

    display_string(s1);
    display_string(s2);

}



/***************************************************/
/***************************************************/

string --> basic_string<char, <char_traits,>>


default ctor
copy ctor --> const string &
move ctor --> string &&
const string &s, size_type idx
const string &s, size_type idx, size_type n
ctring(const char *)
data(const cahr *, size_type)
fill (size_t, char c)
initilizer_lict
range ctor


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
   string str = "orhan ozturk derste rahatsiz etmeyin";
   auto cap = str.capacity();
   cout << "initial capcity : " << cap << "\n";
   auto size = str.size();
   cout << "initial size : " << size << "\n";

   while (true) {
       str += 'A';
       if(str.capacity() > cap){
           cout << "size = " << str.size() << " new cap = " << str.capacity() << "\n";
            cap = str.capacity();
            getchar();
       }
   }


}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
   string str;
   str.reserve(50000); //bu kadar  yer ayırtıyorum
   auto cap = str.capacity();
   cout << "capacity : " << cap << "\n";

   while (true) {
       str += 'A';
       if(str.capacity() > cap){
           cout << "size = " << str.size() << " new cap = " << str.capacity() << "\n";
            cap = str.capacity();
            getchar();
       }
   }


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
   string str;
   str.reserve(50000); //bu kadar  yer ayırtıyorum
   auto cap = str.capacity();

   cout << str.size() << "\n";
   cout << str.capacity() << "\n";


}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
   string s1("a");
   string s2{'B'};
   string s3{1, 'C'};
   string s4{'D', 1};
   string s5(10, 'A');

   display_string(s1);
   display_string(s2);
   display_string(s3);
   display_string(s4);
    display_string(s5);
}


/***************************************************/
/***************************************************/



#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfında null karateri '\0' yaznın sonu anlamınada kullanılmaz
   string s1(10, '\0');

   display_string(s1);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"orhan ozturk"};

    cout << str[3] << "\n";


    for (size_t i{}; i < str.size(); ++i) {
        cout << str[i] << " ";
    }

    cout << "\n";

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya"};
    display_string(str);

    str[0] = 'm';

    display_string(str);

    str[2] = 's';

    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfının cont overloding [] vardır
    const string str{"kaya"};
    display_string(str);

    str[0] = 'm'; //bu sebepten bunlarda atama yapamayız

    display_string(str);

    str[2] = 's';

    display_string(str);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya"};

    try {
        auto c = str[20]; //tanımsız davranış
    }  catch (std::exception &ex) {
        cout << "hata yakalandi : " << ex.what() << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya"};

    try {
        auto c = str[4]; // yazısının sonunda null karakteri bulunmasada
        cout << "c = " << static_cast<int>(c) << "\n"; // bu tanımsız davranıs değil
        //son karakterin null karateri olma garantisi var
    }  catch (std::exception &ex) {
        cout << "hata yakalandi : " << ex.what() << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya akdag"};

    for (size_t i{}; i < str.size(); ++i) {
        cout << str.at(i) << " ";
    }

    cout << "\n";


    /*
     * AT() İN [] DEN FARKI EXCEPtion throw etmesi
     * [] gecersiz bir index girer isek tanımsız davranıs
     * at ise exception throe eder
     */


    try {
        auto c = str.at(456); //gecersiz index exception throw edecek
    }  catch (std::exception &ex) {
        cout << "hata yakalandi : " << ex.what() << "\n";
    }


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya akdag"};
    display_string(str);

    str.front() = 'm'; // konteynerda tutulan ilk ogeye referans verir
    str.back()  = 'n';

    display_string(str);

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //const atamaya tabi tutulmustur
    const string str{"kaya akdag"};
    display_string(str);

    str.front() = 'm'; // konteynerda tutulan ilk ogeye referans verir
    str.back()  = 'n';

    display_string(str);

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    const string str{"kaya akdag"};

    //range for loop

    for (auto c : str) {
        cout << c << " " << static_cast<int>(c) << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya akdag"};

    //range for loop

    for (auto &c : str) {
        ++c;
    }

    display_string(str);

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kaya akdag"};

    for(auto iter = str.begin(); iter != str.end(); ++iter ){
        cout << *iter << " ";
    }


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string s1 = "ali";
    string s2 = "ali";
    string s3 = "can";

    cout << boolalpha << (s1 == s2) << "\n";
    cout << boolalpha << (s1 == s3) << "\n";
    cout << boolalpha << (s1 < s3) << "\n";
    cout << boolalpha << (s1 > s3) << "\n";

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string psw = "blue bird";

    if(psw == "blue bird")
        cout << "dogru parola\n";
    else
        cout << "yanlis parola\n";


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string psw = "blue bird";

    //boyle bir karsılastıma tek karaterle mumkun değil
    if(psw == 'c')
        cout << "dogru parola\n";
    else
        cout << "yanlis parola\n";


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican"};

    cout << "compare : " << str.compare("alican") << "\n";
    cout << "compare : " << str.compare("alacan") << "\n";
    cout << "compare : " << str.compare("mehmet") << "\n";


}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican aglar"};

    string name{"mehmet doganer"};

    display_string(str);

    //str = name;
    //str = "hasancan oglu";

    str = {'a', 'b', 'c', 'u'}; //initliazer _ list atam yapabiliriz

    display_string(str);

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"ali"};
    display_string(str);

    str.push_back('c');
    display_string(str);

    str.push_back('a');
    display_string(str);

    str.push_back('n');
    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string s1{"ali"};
    string s2{"han"};

    display_string(s1);

    s1 += s2;

    display_string(s1);

    s1 += " erler";
    display_string(s1);

    s1 += 'c';
    display_string(s1);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican"};

    //str.insert(3, "12345");
    //display_string(str);

    string s{"45678"};
    //str.insert(3, s);
    //display_string(str);

    //str.insert(3, s, 2);
    //display_string(str);

    str.insert(3, s, 2, 2);
    display_string(str);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican"};

    display_string(str);

    str.insert(str.begin(), 'X');
    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican"};

    display_string(str);

    //str.insert(str.begin() + 2, 10,'8');
    //display_string(str);

    char s1[] = "12345678";
    //str.insert(3, s1+1, 4);
    //display_string(str);

    str.insert(3, s1, 2, 4);
    display_string(str);
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string str{"alican"};

    display_string(str);

    str.insert(0, "orhanozturk").at(2) = 'q';

    display_string(str);
}


/***************************************************/
/***************************************************/

string::npos

string sınıfının public static constexpr string::size_type türünden npos isimli veri elemanıdır

string size_type alaceği en buyuk deger

npos degeri string nesnesinin tutugu yazının gecerli bir indeksi olamaz


string sınıfının cok sayıda arama fonksiyonu var
arama fonksiyonularının hepsinin geri donus deger inex degeridir bulunan
bulunamaz ise string  npos sabiti döndürür



#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    cout << string::npos << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string name;

    cout << "bir isim giriniz :";
    getline(cin, name); //veri almak için

    display_string(name);

    auto idx = name.find('a');

    if(idx != string::npos){
        cout << "bulundu idx = " << idx << "\n";
        name[idx] = '!';
        display_string(name);
     }
    else{
        cout << "bulunmadi\n";
    }


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <string>

using namespace std;

void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{

    string name{"alican"};
    string str{"mustafa"};

    //name.insert(3, str, 1, 4);
    //display_string(name);

    //butun elelmnaları heosini alınmasını saglar
    name.insert(3, str, 1, string::npos);

    display_string(name);

}


/***************************************************/
/***************************************************/

initializer_list

<initializer_list>


#include <iostream>
#include <initializer_list>

using namespace std;


int main()
{
    initializer_list<double> mylist1{1.3, 2.4, 5.6, 2.2, 112.5};
    initializer_list<double> mylist2 = {1.3, 2.4, 5.6, 2.2, 112.5};

    auto mylist3 = {1.3, 2.4, 5.6, 2.2, 112.5};

    //auto mylist4{1.3, 2.4, 5.6, 2.2, 112.5}; //sentaks hatasıboyle bir initializer list yok

    auto ival{12}; //gecerli fakat initializer list değil
    auto x = {12}; //gecerli initializer list


}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>

using namespace std;

void func(initializer_list<int> x);


int main()
{

      int x = 10, y = 20, z = 30;
      func({1, 2, 3, 4,5});
      func({1});
      func({});
      func({x, y, z});


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>

using namespace std;

initializer_list<int> func(initializer_list<int> x)
{
    return initializer_list<int>{1,2,3,4,5};
}


int main()
{

      int x = 10, y = 20, z = 30;
      func({1, 2, 3, 4,5});
      func({1});
      func({});
      func({x, y, z});


}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>

using namespace std;


int main()
{
    initializer_list<int> mylist{10, 20, 30, 40, 50};
    initializer_list<int> mylist2{};

    cout << mylist.size() << "\n";
    cout << mylist2.size() << "\n";

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>

using namespace std;


int main()
{
    initializer_list<int> mylist{10, 20, 30, 40, 50};

    for (auto iter = mylist.begin(); iter != mylist.end(); ++iter) {
        cout << *iter << "\n";
    }

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>

using namespace std;


int main()
{
    //initializer list conts olarak kabul edilir derleyici tarafından
    initializer_list<int> mylist{10, 20, 30, 40, 50};

    auto iter = mylist.begin();

    *iter = 55; //sentask hatası const oldugu için

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>

using namespace std;


class Myclass{
public:
    Myclass(){cout << "default ctor\n";}
    Myclass(const Myclass &r){cout << "copy ctor\n";}
};

void func(initializer_list<Myclass> x)
{
    cout << "func caggrildi\n";
}

int main()
{
    initializer_list<Myclass> mylist{Myclass(), Myclass(), Myclass()};

    func(mylist); //copy ctor cagrılmaz
    //cunku referans semantıgı kullandıgı için initializer_list in

    cout << "main devam ediyor\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>

using namespace std;

void func(int x)
{
    cout << "x = " << x << "\n";
}

int main()
{
    for (auto val : {2, 3, 4,5 ,78, 77}) {
        func(val);
    }
}


/***************************************************/
/***************************************************/

initializer_list modern c++ gelen bir ozelliktir

ve

konteynır ctorlarının initializer_list parametreleri bulunmkatadır




#include <iostream>
#include <initializer_list>
#include <vector>

using namespace std;


int main()
{
    vector<int> ivec{2, 3, 4, 6, 7};

    cout << ivec.size() << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


int main()
{
    string str{'A', 'B', 'C'};

    cout << str.size() << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


int main()
{
    string str;

    str = {'A', 'B', 'C'};

    cout << str.size();
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


class Myclass
{
public:
    Myclass(initializer_list<int> x)
    {
        cout << "initializer_list<int> ctor\n";
        cout << "x.size = " << x.size() << "\n";
    }

    Myclass()
    {
        cout << "default ctor\n";
    }
};


int main()
{
   Myclass m;
   Myclass m1 = {2, 3, 5, 7, 8};
   Myclass m2{2, 3, 5, 7, 8};
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


class Myclass
{
public:
    Myclass(int val)
    {
        cout << "Myclass int ctor val = " << val << "\n";
    }

    Myclass(initializer_list<int> x)
    {
        cout << "initializer_list<int> ctor\n";
        cout << "x.size = " << x.size() << "\n";
    }

    Myclass()
    {
        cout << "default ctor\n";
    }
};


int main()
{
   Myclass m1 = 10;
   Myclass m2(10);
   Myclass m3{2};
   Myclass m4 = {44};

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
   string s1(45, 'A');
   display_string(s1);
   string s2{70, 'A'};
   display_string(s2);



}


/***************************************************/
/***************************************************/
#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    vector<int> ivec{2, 3, 4, 5, 6, 7, 8,12}; //eski C++ boyle bir sentaks yoktu

    //eskiden yaptıgımız uygulma bu şekildeydi
    const int a[] = {2, 3, 4, 5, 6, 7, 8,12};
    vector<int> ivec2{a, a + sizeof (a) / sizeof (*a)}; //range ctor
}


/***************************************************/
/***************************************************/
#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string other{"orhan ozturk"};
    char buffer[] = "mustatafa demir";

    string s1;
    string s2(other);
    string s3 = other;
    string s4{other};
    string s5 = move(other);
    string s6 = "kaya"; //const char * ctor
    string s7{buffer};
    string s8(other, 5); //range ctor
    string s9(other, 5, 3);
    string s10(buffer, 7);
    string s11(buffer, buffer + 4);
    string s12(100, 'A');
    string s13{100, 'A'}; //initializer list ctor

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str(50000, 'A');

    cout << "size = " << str.size() << "\n";
    cout << "cap = " << str.capacity() << "\n";

    str.erase(1);

    cout << "size = " << str.size() << "\n";
    cout << "cap = " << str.capacity() << "\n";

    //str.reserve(10); //kapasiteyi buzme garantisi yok
    str.shrink_to_fit(); //kapasiteyi buzme garantisi var

    cout << "size = " << str.size() << "\n";
    cout << "cap = " << str.capacity() << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);
    //str = other;
    //str = foo();
    //str = 'A';
    //str = buffer;
    //str = "niyazi denizhan";
    //str = {'N', 'U', 'R'};
    str = {};

    display_string(str);

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);
    //str.assign(other);
    //str.assign("kerim nazli");
    //str.assign(other, 0);
    //str.assign(other, 8);
    //str.assign(other, 8, 5);
    //str.assign(20, '!');
    //str.assign(buffer); //cstring  paramtreli
    //str.assign(buffer, 5);
    //str.assign(buffer + 3, buffer + 5);
    str.assign({'A', 'B'});

    display_string(str);

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);

    str += other;
    str += buffer;
    str += "kazim";
    str += 'X';
    str += {'C', 'A', 'N'};

    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);

    //str.append(buffer);
    //str.append(other);
    //str.append(other, 8);
    //str.append(other, 8, 5);
    //str.append(buffer, 6);
    //str.append(buffer + 3, buffer + 6);
    str.append(10, '.');

    str.push_back('X');


    display_string(str);

}


/***************************************************/
/***************************************************/




#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);

    //containerların ortak silme interface clear dır
    str.clear();

    display_string(str);

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);

    //containerların ortak silme interface clear dır
    //str.clear();

    //str.erase(7, 5);
    //str.erase(0, 3);
    //str.erase(8);
    //str.erase(0, string::npos); //tumunu sil
    //str.erase(); // tumunu sil


    str.erase(str.begin(), str.begin() + 3); //range araasında silme

    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};
    string other{"mustafa cangoz marti"};
    char buffer[100] = "mehmet acikgoz";

    display_string(str);

   //str.erase(str.begin(), str.begin() + 3); //range araasında silme
   //str.erase(str.begin());
   //str.erase(1);
    //str.erase(str.end() -1);
    //str.pop_back();
    str.erase(str.begin(), str.end());


    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};

    display_string(str);

    //konteynerların bütün ogelerini nasıl silebilirim
    str.clear();
    str.erase();
    str.erase(0);
    str.erase(0, string::npos);
    str.erase(str.begin(), str.end());
    str = "";
    str = {};
    str = string{};
    str = string();
    str.assign({});
    str.assign("");

    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};

    display_string(str);

    display_string(str.substr(0, 3));
    display_string(str.substr(8));
    display_string(str.substr());

    display_string(str);

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    char *s1 = nullptr;
    string str{s1}; //boyle bir ilk deger verme yapamayız tanımsız davranış

    char s1[] = "orhn";

    string str1{s2, 6}; //boyle bir ilk deger verme ilede boyutu aşarsak tanımsız davranıs


    //bunlar programcının sorumlulugunda

    display_string(str);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk"};

    display_string(str);

    display_string(str.substr(5, 666)); //10 nokta sonra kalan hepsini al demek

    display_string(str);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string s1{"orhan ozturk"};
    string s2{"mehmet kazim"};

    s1.swap(s2);

    display_string(s1);
    display_string(s2);

    swap(s1, s2);

    display_string(s1);
    display_string(s2);

    //bu swap işlemlerinde sadece pointerlar değişir
    //bu yğzden malyet azdır

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string s1{"orhan ozturk"};
    display_string(s1);

    s1.resize(25);
    //null karakterleri ile doldurdu

    display_string(s1);

    s1.resize(5);

    display_string(s1);

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk kastmonu"};

    auto idx = str.find('z');
    //eger bulursa karateri bulundu index numarası
    //eger bulamaz npos dondurur


    if(idx != string::npos){
        cout << "bulundu idx = " << idx << "\n";
    }

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk kastmonu"};

    auto idx = str.find('z', 5);
    //5 inci indexten baslyarak ara ve index numarası
    //eger bulamaz npos dondurur


    if(idx != string::npos){
        cout << "bulundu idx = " << idx << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk kastamonu"};

    auto idx = str.find("tamo");//baslama iindexsi verir

    string s1{"tamo"};
    char s2[20] = "orhan ozturk";

    auto idx1 = str.find(s1);
    auto idx2 = str.find(s2, 0, 4); // s2 nin 0 ile 4 indexlari arasını ara


    if(idx != string::npos){
        cout << "bulundu idx = " << idx << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

string foo()
{
    return "mehmet";
}

int main()
{
    string str{"orhan ozturk kastamonu"};

    auto idx = str.rfind('a');//terten arama

    if(idx != string::npos){
        cout << "bulundu idx = " << idx << "\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str;

    cout << "bir yazi giriniz : ";
    getline(cin, str);

    auto idx = str.find_first_of("012345"); //bu akraterlerden biri olan ilk index bul
    auto idx1 = str.find_first_of("012345", 6); //bu indexten baslar ara

    cout << "idx = " << idx << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str;

    cout << "bir yazi giriniz : ";
    getline(cin, str);

    auto idx = str.find_first_not_of("012345"); //bu akraterlerden biri olmayan ilk index bul

    cout << "idx = " << idx << "\n";

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str;

    cout << "bir yazi giriniz : ";
    getline(cin, str);

    auto idx = str.find_last_of("012345"); //bu akraterlerden biri olan son index bul
    auto idx1 = str.find_last_not_of("012345"); //bu akraterlerden biri olmayan son index bul

    cout << "idx = " << idx << "\n";

}


/***************************************************/
/***************************************************/

not: bu arama fonksiyonları eger bulmazsa npos dondurur



/****************************************************/


if with initializer  -- ilk deger vermeli if deyimi




#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str;

    cout << "bir yazi giriniz : ";
    getline(cin, str);

    //bu durumda scope leakage vardır
    /*
    auto idx = str.find('a');
    if(idx != string::npos)
    {
        str.erase(idx, 1);
        cout << "silindi\n";
        display_string(str);
    }
    */


    //C++17 ile birlikte if with init .. getirdik

    if(auto idx = str.find('a'); idx != string::npos)
    {
        str.erase(idx, 1);
        cout << "silindi\n";
        display_string(str);
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int func(int ch);

int main()
{
    //C++17 ile birlikte if with init .. getirdik

    if(auto x =func('A'); x > 5)
    {
        cout << string(x, 'A') << "\n";
    }
    else {
        cout << string(x, 'B') << "\n";
    }

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int func(int ch);

int main()
{
    //C++17 ile birlikte if with init .. getirdik

    if(auto x =func('A'); x > 5)
    {
        cout << string(x, 'A') << "\n";
    }
    else {
        cout << string(x, 'B') << "\n";
    }

    //eski C++ da olan bir özellik
    //bunla karıstırmayınız
    if(int x = func('A')){
      cout << string(x, 'A') << "\n";
    }

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int func(int ch);

int main()
{
    string str;

    cout << "bir yazi giriniz : ";
    getline(cin, str);

    //C++17 ile birlikte if with init .. getirdik

    if(auto idx = str.find('e'); idx != string::npos)
    {
        str.insert(idx, 5, 'X');
        display_string(str);
    }
    else {
        cout << "bulunamadi\n";
    }

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int func(int ch);

int main()
{
    string s1{"cansle"}, s2{"nurcan"};

    cout << boolalpha;
    cout << (s1 < s2) << "\n";
    cout << (s1 <= s2) << "\n";
    cout << (s1 > s2) << "\n";
    cout << (s1 >= s2) << "\n";
    cout << (s1 == s2) << "\n";
    cout << (s1 != s2) << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int func(int ch);

int main()
{
    string s1, s2;

    cout << "bir isim giriniz : ";
    cin >> s1 >> s2;

    auto result = s1.compare(s2);

    if (result > 0)
        cout << s1 << " > " << s2 << "\n";
    else if(result < 0)
        cout << s1 << " < " << s2 << "\n";
    else
        cout << s1 << " == " << s2 << "\n";
}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};

    display_string(s1);
    s1.replace(2, 4, "bim");
    display_string(s1);
}


/***************************************************/
/***************************************************/


string nesneleri ve string arasındaki donusumler


cstringden dogrudan string e donusum var


string sınıfın ctring e otomatik donusumu yok

bu donusumu yapan 2 ayrı uye fonksiyon var


const char *c_str()const;



#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};

    const char *p = s1.c_str();
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string s1{"orhan ozturk"};

    const char *p = s1.c_str();
    strlen(p);
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

void func(const char *cx);


int main()
{
    string s1{"orhan ozturk"};

    const char *p = s1.c_str();
    func(s1.c_str());
}


/***************************************************/
/***************************************************/
#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

void func(const char *cx);


int main()
{
    string s1{"orhan ozturk"};

    const char *p = s1.c_str();
    puts(p);
    s1 += " ve kastamonu da yasiyor"; //otomatık donusume ugrar
    puts(p); // tanısmız davranısa dusuyor
    //bu kullanım yanlıs dikkat

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

int main()
{
    string str{"orhan ozturk kocaeli dogumlu"};

    auto s1 = &str[0];
    auto s2 = str.data();
    //ikiside aynı anlama gelir

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}

void cfunc(const char *p, size_t size);

int main()
{
    string str{"orhan ozturk kocaeli dogumlu"};

    cfunc(str.data(), str.size());

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    char str[100];
    string s1;

    cout << "bir yazi girin : ";
    getline(cin, s1);

    //kopyalandıgı karater sayı geri dondurur
    auto n = s1.copy(str, 100); //copylama işleminde null karateri konmaz
    str[n] = '\0'; //bu yzuden biz koymalıyız

    cout << str << "\n";

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //sitring sınınfında giriş çıkış işlemleri

    string str{"orhan ozturk"};

    cout << str << "\n";

    string s1 = "mustafa murat";
    string s2 = "ozan ahmet";

    cout << left << setw(20) << s1 << s2 << "\n";

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;

    cout << "bir isim giniriz : ";
    cin >> str;

    //cin giriş işlemi bosluk karaterlerini ayıraç olarak alır

    display_string(str);

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string name, surname, town;

    cout << "bir isim giniriz : ";
    cin >> name >> surname >> town;


    cout << town << " dogumlu " << name << "  " <<  surname << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string name;

    cout << "bir isim giniriz : ";
    cin >> setw(20) >> name; // 20 karater oku

    cout << name << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string name;

    cout << "bir isim giniriz : ";

    getline(cin, name); //giriş akımından nesene aktar işlemi

    //bu sayede tüm veriyi alırız

    cout << name << "\n";
}


/***************************************************/
/***************************************************/


sayı yazı dönüşümleri

sto ile baslayan global fonksiyonlar kullanılabilir


yazıyı sayıya cevirme için
tostring gibi fonksiyonlar kullanılır





#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;
    cout << "bir isim giniriz : ";
    getline(cin, str);

    int ival = stoi(str);

    cout <<" ival = " << ival << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;
    cout << "bir isim giniriz : ";
    getline(cin, str);

    display_string(str);

    string::size_type idx;

    int ival = stoi(str, &idx);

    cout <<" idx = " << idx << "\n";
    cout <<" ival = " << ival << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;
    cout << "bir isim giniriz : ";
    getline(cin, str);

    display_string(str);

    string::size_type idx;

    int ival = stoi(str, &idx, 16);

    cout <<" idx = " << idx << "\n";
    cout <<" ival = " << ival << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;
    cout << "bir isim giniriz : ";
    getline(cin, str);

    display_string(str);

    string::size_type idx;

    int ival = stoi(str, &idx, 8);

    cout <<" idx = " << idx << "\n";
    cout <<" ival = " << ival << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    //string sınıfı giriş işlemleri

    string str;
    cout << "bir isim giniriz : ";
    getline(cin, str);

    display_string(str);

    string::size_type idx;

    //double donusum
    auto ival = stod(str, &idx);

    cout <<" idx = " << idx << "\n";
    cout <<" ival = " << ival << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    int ival;
    cout << "bir sayi giriniz\n";
    cin >> ival;

    auto str = to_string(ival);

    display_string(str);
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kazimnazimehmet"};

    //str.insert(str.begin(), 'X');
    auto iter = str.insert(next(str.begin(), 2), 'X');

    display_string(str);
    cout << "*iter = " << *iter << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kazimnazimehmet"};

    auto iter = str.erase(str.begin());

    display_string(str);
    cout << "*iter = " << *iter << "\n";
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kazimnazimehmet"};

    //str.end -1 işlemine takabul eder
    auto iter = str.erase(prev(str.end()));

    display_string(str);
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <initializer_list>
#include <string>
#include <cstring>
#include <iomanip>

using namespace std;


void display_string(const string &s)
{
    cout << "[" << s.length() << "] (" << s << ")\n";
}


int main()
{
    string str{"kazimnazimehmet"};

    //str.end -1 işlemine takabul eder
    auto iter = str.erase(next(str.begin(), 2));

    display_string(str);
}


/***************************************************/
/***************************************************/


namespace

isim alanları -- isim uzayı

isim çakışmasının önğne geçmek için tasarlanmıştır

namespace bir scope dur

isim alanın içindeki elemnalar publictir

namespace bir anahtar sözcüktür





namespace Orhn {
    int x = 10;
    void func(int);
    class Myclas;

    class Date{

    };

    namespace timer {
        namespace  {

        }
    }
}


/***************************************************/
/***************************************************/


qualified name
unqualifed name

:: scope resulation


eger ben çözünütlük operatoru ile kullanırsam qualified name

std::vector

egger çözününrlük operatoru kullanmıyorsak unqualifed name



/***************************************************/
/***************************************************/


namespace Orhn {
    int x = 10;
    void func(int);
    double x = 2.2; // aynı isimde değişken tanımlayamayız
    //fakat farklı namespace içindekiler aynı olablir
}


/***************************************************/
/***************************************************/


namespace Orhn {
    int x = 10;
    void func(int);

}

int main()
{
    //x = 20;//sentaks hatası

    //geçerli erişm budur
    Orhn::x = 20;
    Orhn::func(12);

}


/***************************************************/
/***************************************************/


#include <iostream>

namespace Orhn {
    int x = 10;
    void func(int);

}

namespace ozturk {
    int x = 20;
}


namespace kocaeli {
    int x = 30;
}

int main()
{
    std::cout << Orhn::x << "\n";
    std::cout << ozturk::x << "\n";
    std::cout << kocaeli::x << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>

//function overloading
namespace Orhn {
    void func(int);
    void func(double);
}

int main()
{

}


/***************************************************/
/***************************************************/



#include <iostream>

//unnamespace
//buna ileride değinecez
namespace {
    int x = 20;
    int y = 12;
}

int main()
{

}


/***************************************************/
/***************************************************/
#include <iostream>

namespace orhan{
    int x = 20;
    int y = 12;
}

namespace orhan{
    int a = 20;
    int b = 12;
}

int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>

//nested namespace
namespace orhan{
    int x = 20;
    int y = 12;
    namespace fikret {
        int a = 20;
        namespace engin {
            int v = 50;
        }
    }
}

int main()
{
    orhan::x;
    orhan::fikret::a;
    orhan::fikret::engin::v;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>


int main()
{
    std::cout << std::endl;

    std::vector<std::string> ivec;

}


/***************************************************/
/***************************************************/

using declaration (using bildirim)
using namespace directive
ADL(argument dependant lookup (argümana baglı isim arama))


using declaration (using bildirim)



#include <iostream>

namespace  orhan{
    int x, y;
    void func(int);
}

using orhan::x;
using std::cout;
using std::endl;



/***************************************************/
/***************************************************/



#include <iostream>

using std::cout;

int main()
{
    int x = 10;
    cout << x << std::endl;
}



/***************************************************/
/***************************************************/

#include <iostream>

void func()
{
   using std::cout;
   using std::endl;

   int x = 20;
   cout << x << endl;
}

int main()
{
    int x = 10;
    std::cout << x << std::endl;
}



/***************************************************/
/***************************************************/


#include <iostream>


namespace orhan {
    int a, b, c;
}

int a = 11;
using orhan::a; //sentaks hatası

int main()
{
    using orhan::a;
    a;

    int a = 22; //sentaks hatasına düşer

}



/***************************************************/
/***************************************************/

#include <iostream>

namespace orhan {
    namespace ali {
        namespace veli {
            int a, b, c;
        }
    }
}

using orhan::ali::veli::a;

int main()
{
    a = 45;

}



/***************************************************/
/***************************************************/

#include <iostream>

namespace orhan {
    int a, b;
    void func();
    class Myclass{

    };
}

using namespace orhan;

void f1()
{
    a = 30;
}


void f2()
{
    b = 30;
    func();
}

int main()
{
    a;
    b;
    func();
}



/***************************************************/
/***************************************************/
#include <iostream>

namespace orhan {
    int a = 12, b;
    void func();
    class Myclass{

    };
}

using namespace orhan;

int main()
{
    //int a = 40;

    std::cout << a << "\n";

}



/***************************************************/
/***************************************************/


#include <iostream>

namespace orhan {
    int a = 12, b;
    void func();
    class Myclass{

    };
}

using namespace orhan;


int a = 40;

int main()
{
    //sentaks hatası
    //std::cout << a << "\n";

    std::cout << ::a << "\n";

    std::cout << orhan::a << "\n";

}



/***************************************************/
/***************************************************/


ADL(argument dependant lookup (argümana baglı isim arama))

#include <iostream>

namespace orhan {
    void func(int);
    class Myclass{

    };

    void foo(Myclass)
    {
        std::cout << "orhan foo call\n";
    }
}

int main()
{
    orhan::Myclass m;

    //orhan::foo(m);

    foo(m);

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

int main()
{

    std::string str{"orhan"};

    //<< operator overloading
    //ADL fonksiyonu
    std::cout << str;

    //std::operator<<(std::cout, str);

}



/***************************************************/
/***************************************************/

#include <iostream>

//.hpp
namespace orhan {
    class Myclass{
    public:
        void foo(int);
        void func(int);
    };

    void gf(Myclass m);
}


//client.cpp
int main()
{

    orhan::Myclass m;

    m.foo(12);
    m.func(55);

    //ADL sayesinde bunu yapabiliyoruz
   gf(m);

}



/***************************************************/
/***************************************************/

#include <iostream>

//.hpp
namespace orhan {
    class Myclass{
    public:

    };

    void foo(Myclass m);
}


void foo(orhan::Myclass m)
{

}


//client.cpp
int main()
{

    orhan::Myclass m;

    foo(m); //sentaks hatası

}



/***************************************************/
/***************************************************/

#include <iostream>

//.hpp
namespace orhan {
    class Myclass{
    public:

    };

    void foo(Myclass m);
}

//client.cpp
int main()
{

    orhan::Myclass m;

    int foo = 22;

    foo(m);//sentaks hatası

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>

int main()
{
    //sentaks hatası
    std::cout << "Hello world" << endl;

    //bu global isimde fonsiyon ismi oldugu için geçerli
    endl(std::cout);

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>
#include <vector>

namespace orhan {
    class Myclass{

    };

    void f1(Myclass);
    void f2(Myclass *);
    void f3(std::vector<Myclass>);
    enum Color{White, Black};
    void f4(Color);
}


int main()
{
    orhan::Myclass mx;

    //ADL
    f1(mx);

    //ADL
    f2(&mx);

    std::vector<orhan::Myclass> myvec;
    f3(myvec); //ADL

    f4(orhan::Black); //ADL

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>
#include <vector>

namespace Ali {
    namespace Veli {
        namespace Selami {
            int x = 10;
        }
    }
}


int main()
{
    Ali::Veli::Selami::x = 33;

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>
#include <vector>

//C++17

namespace Ali::Veli::Selami {
    int x = 2;
}

namespace Ali {
    int y =10;
}

namespace Ali::Veli {
        int z = 20;
}

int main()
{
    Ali::Veli::Selami::x = 33;
    Ali::Veli::z =22;
    Ali::y =55;

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>
#include <vector>

//C++17

namespace A {

}

namespace A::B {

}

namespace A::B::C {

}

int main()
{


}



/***************************************************/
/***************************************************/
#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

namespace orhan {
    namespace Nested {
        int x = 10;
        void foo(int);
    }

    using namespace Nested;
}



int main()
{
    orhan::Nested::x = 20;
    orhan::Nested::foo(22);

    orhan::x = 21;
    orhan::foo(34);
}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

namespace orhan {
    inline namespace Nested {
        int x = 10;
        void foo(int);
    }
}



int main()
{
    orhan::Nested::x = 20;
    orhan::Nested::foo(22);

    orhan::x = 21;
    orhan::foo(34);
}



/***************************************************/
/***************************************************/



#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

namespace orhan {
    int a = 50;
    inline namespace Nested {
        int x = 10;
        void foo(int);
    }
}



int main()
{
    orhan::x = 100;
    orhan::foo(12);
    orhan::a++;

}



/***************************************************/
/***************************************************/

#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

namespace orhan {
    int a = 50;
    inline namespace Ali {
        int x = 10;
        void foo(int);
    }

    inline namespace Veli {
        int y = 22;
        void func(int);
    }
}



int main()
{
    orhan::x = 100;
    orhan::a++;
    orhan::y = 11;

}



/***************************************************/
/***************************************************/


#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

namespace orhan {
    int a = 50;
    inline namespace Ali {
        int x = 10;
        void foo(int);

        inline namespace Veli {
            int y = 22;
            void func(int);
        }
    }
}



int main()
{
    orhan::x = 100;
    orhan::a++;
    orhan::y = 11;

    orhan::Ali::y = 55;

}



/***************************************************/
/***************************************************/
#include <iostream>
#include <string>
#include <vector>

//C++11
//inline namespace

inline namespace orhan {
    int a = 50;
    inline namespace Ali {
        int x = 10;
        void foo(int);

        inline namespace Veli {
            int y = 22;
            void func(int);
        }
    }
}



int main()
{
    y;
    x;
    a;

}



/***************************************************/
/***************************************************/


#include <iostream>

#define NEW_VERSION

namespace orhan {

#ifndef NEW_VERSION
    inline
#endif
    namespace old_version {
        class Myclass{
        public:
            Myclass()
            {
                std::cout << "Myclass old version\n";
            }
        };
    }

#ifdef NEW_VERSION
    inline
#endif
    namespace new_version {
        class Myclass{
        public:
            Myclass()
            {
                std::cout << "Myclass new version\n";
            }
        };
    }

}

//client.cpp
int main()
{
    orhan::Myclass m;

}



/***************************************************/
/***************************************************/

unnamespace


//internal linkage
static int func(int);


//veli.h
extern int g;
exter int foo();

int c; // bu internal

veli.cpp
int g = 20;
int foo();


ali.c
static int gf = 10;
static void foo(int);


cpp da ise static depracte edilmiş durumda bunun yerine unnamespace gelmiştir


#include <iostream>

//buradaki tanımları dış modulere kapatıldı
//sadece kendi moullümüze kullanbiliriz
//static ler yerine geçmiştir
//isim ile direk olarka kullanabiliiriz

namespace  {
    int x = 10;
    int foo();
    class Myclass{

    };
}

int main()
{
    x = 2;
    foo();
    Myclass m;

}



/***************************************************/
/***************************************************/


#include <iostream>

//buradaki tanımları dış modulere kapatıldı
//sadece kendi moullümüze kullanbiliriz
//static ler yerine geçmiştir
//isim ile direk olarka kullanabiliiriz

namespace  {
    int x = 10;
    int foo();
    class Myclass{

    };
}

namespace  {
    int a = 22;
}

int main()
{
    x = 2;
    foo();
    Myclass m;

    a = 44;
}



/***************************************************/
/***************************************************/

//eski cpp var

namespace alias

namespace se verieln eş isim




#include <iostream>

namespace sd = std;

int main()
{
    sd::cout << "veli\n";
}

/***************************************************/
/***************************************************/

#include <iostream>

namespace orhan {
int x = 10;
}

namespace veli = orhan;

int main()
{

    veli::x;
    orhan::x;
}

/***************************************************/
/***************************************************/


#include <iostream>

namespace orhan_proj_file_documents {
    int x = 10;
}

namespace myproject = orhan_proj_file_documents;

int main()
{
    myproject::x;

}

/***************************************************/
/***************************************************/

#include <iostream>

namespace orhan_proj_file_documents {
    int x = 10;
}


int main()
{
    namespace myproject = orhan_proj_file_documents;
    myproject::x;

}

void func()
{
    myproject::x; //sentaks hatsı
}

/***************************************************/
/***************************************************/

#include <iostream>

namespace orhan {
    namespace ali {
        namespace veli {
            int x = 11;
        }
    }
}

namespace ax = orhan::ali::veli;

int main()
{
    ax::x;
}

/***************************************************/
/***************************************************/


#include <iostream>

namespace orhan {
    namespace old_version {
        class Myclass{
        public:
            Myclass() {std::cout << "Myclass old ctor\n";}
        };
    }

    namespace new_version {
        class Myclass{
        public:
            Myclass() {std::cout << "Myclass new ctor\n";}
        };
    }
}


namespace oldV = orhan::old_version;
namespace newV = orhan::new_version;

int main()
{
    oldV::Myclass m1;
    newV::Myclass m2;
}

/***************************************************/
/***************************************************/


raw string literals (ham yazı sabiti)
C++11 ile dile eklendi


#include <iostream>


int main()
{
    const char *p = "orhan";
    //c de bu char *

    //cpp da const char *


}

/***************************************************/
/***************************************************/

#include <iostream>


int main()
{
    const char *p = "orhan";

    "bugun gunlerden pazar ve hava cok guzel
      acaba disarimi cıksak
              beraber parka gideriz"


}

/***************************************************/
/***************************************************/

#include <iostream>


int main()
{
    const char *p = "bugun gunlerden pazar ve hava cok guzel \
                    acaba disarimi cıksak\
                    beraber parka gideriz";

    std::puts(p);

}

/***************************************************/
/***************************************************/

#include <iostream>


int main()
{
    //compile time da bu stringler birleştrilir
    const char *p = "bugun gunlerden pazar ve hava cok guzel "
                    "acaba disarimi cıksak "
                    "beraber parka gideriz";

    std::puts(p);

}

/***************************************************/
/***************************************************/


#include <iostream>


int main()
{
    //compile time da bu stringler birleştrilir
    const char *p = "benim evim \" senin \" evin dedi";

    std::puts(p);

}

/***************************************************/
/***************************************************/


mehmet dediki ayseye "merhaba hanımefendi"
ayse da "evet buyurun" dedi
daha sonra \orhan\ olaylar gelisit
"hikaye boyle devam etti"



raw string literals burada devreye giriyor


#include <iostream>


int main()
{
    const char *p = R"(bugun hava guzel)";

    std::puts(p);
}

/***************************************************/
/***************************************************/



#include <iostream>


int main()
{
    const char *p =
            R"(bugun hava guzel" dedi kadin
            1. bu madde cok onemli
                "mehmet" nerede
            2. sabah kalkmak lazim
               "ceylan" gelcek")";

    std::cout << p << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>


int main()
{
    const char *p =
            R"(mustafa mehmet ..)" ahmet ibrahim nese)";

    std::cout << p << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>


int main()
{
    const char *p =
            R"abc(mustafa mehmet ..)" ahmet ibrahim nese)abc";

    std::cout << p << "\n";
}

/***************************************************/
/***************************************************/


kalıtım - inheritance

composition --> has a relations
inheritance ---> is-a relationship



public inheritance
private inheritance
protected inheritance


Araba
//kalıtım terminolojisi
super class
parent class

c++ da
base class

Mercedes
child class
sub class

c++ da
drived class



#include <iostream>

//incomplete type
class Base;
//buunun kalıtımını yapabilmemiz için
//base sınıfınnın complete type olması lazım


int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    void func();
    void foo();
};

//private kalıtım olur bu
class Der : Base{
public:

};


int main()
{

}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    void func();
    void foo();
};

class Der : public Base{
public:

};


int main()
{

}

/***************************************************/
/***************************************************/
#include <iostream>

class Base{
public:
    void func();
    void foo();
};

//struct a ise public kabul ediyor
struct Der : Base{

};


int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    void func();
    void foo();
    class Nested{};
    static void gf();
};

class Der : public Base{

};


int main()
{
    Der myder;
    myder.foo();
    myder.func();
    Der::gf();
    Der::Nested nes;
}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    void func();
    void foo();
    class Nested{};
    static void gf();
};

class Der : public Base{
public:
    void f1();
    void f2();

};


int main()
{
    Der myder;
    myder.foo();
    myder.func();
    myder.f1();
    myder.f2();

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    void func();
    void foo();
};

class Der : public Base{
public:
    void f1();
    void f2();

};


int main()
{
    Der myder;
    Der *p{&myder};
    Der &dr = myder;

    myder.f1();
    //isim arama şu şekilde
    //ilk nesnenin olsuturuldugu sınıfa bakar
    //yani Der sınıfı
    //Base sınıfa bakar

    myder.func();

    //basede buldu

}

/***************************************************/
/***************************************************/


#include <iostream>

class MainBase{
public:
    void g();
    static void gf();
};

class Base : public MainBase{
public:
    void func();
    void foo();
};

class Der : public Base{
public:
    void f1();
    void f2();

};


int main()
{
    Der myder;
    Der *p{&myder};
    Der &dr = myder;

    myder.g();
    //der bakarcak
    //base
    //mainbase buldu

    //isim arama sistemi aynı şekilde ilerleyecek
    p->g();
    dr.g();

    Der::gf();

}

/***************************************************/
/***************************************************/



#include <iostream>

class MainBase{
public:
    void g();
    static void gf();
};

class Base : public MainBase{
public:
    void func();
    void foo();
};

class Der : public Base{
public:
    void f1();
    void f2();

};


int main()
{
    Der myder;
    Der *p{&myder};
    Der &dr = myder;

    //direk erişim olmus olur
    myder.Base::foo();
    p->Base::func();

}

/***************************************************/
/***************************************************/
#include <iostream>

class MainBase{
public:
    void g();
    static void gf();
};

class Base : public MainBase{
public:
    void func();
    void foo();
};

class Der : public Base{
public:
    void f1();
    void f2()
    {
        f1();
        func();
        g();
    }

};


int main()
{


}

/***************************************************/
/***************************************************/



#include <iostream>


class Base{
private:
    void pri_func();

protected:
    void pro_func();

public:
    void pub_func();

};

class Der : public Base{
public:
    void derfunc()
    {
        pub_func();
        pro_func();
        //pri_func(); //sentaks hatası erişim yok
    }
};


int main()
{
    Der myder;
    myder.pub_func();  //sadece publice erişim var

    Base mybase;
    mybase.pub_func(); //sadece publice erişim var

}

/***************************************************/
/***************************************************/

#include <iostream>


class Base{
public:
    void func(int);

};

class Der : public Base{
public:
    void func(int, int);
};


int main()
{
    Der myder;

    //isim arama
    //ismi bulur ise diger kontrolleri yapıyor
    myder.func(12); //sentaks hatası arguman sayısından

    //direk erişim var
    myder.Base::func(12); //bu gecerli

}

/***************************************************/
/***************************************************/


#include <iostream>


class Base{
public:
    void func(double);

};

class Der : public Base{
private:
    void func(int, int);

};


int main()
{
    Der myder;

    //sisim arama
    //der de var
    //fakat arguman sayısına takıl
    myder.func(2.3);

}

/***************************************************/
/***************************************************/
#include <iostream>


class Car{
public:

};

class Mercedes : public Car{
public:

};


int main()
{
    Mercedes *p = new Mercedes;

    //gecerli, ilderger olarak verilir
    //bu donuşum dogaldır
    Car *ptr = p;

}

/***************************************************/
/***************************************************/

#include <iostream>


class Car{
public:

};

class Mercedes : public Car{
public:

};


int main()
{
    Mercedes p;

    //gecerli, ilderger olarak verilir
    //bu donuşum dogaldır
    //upcasting olayı denir
    Car &rc{p};

}

/***************************************************/
/***************************************************/

#include <iostream>


class Car{
public:

};

class Mercedes : public Car{
public:

};


int main()
{
    Mercedes m;

    //bu durumdan mumkun oldugunca kacınacaz
    //bu durum sentask hatası değil fakat yanlıs durum
    Car cr = m;
    Car ca;

    ca = m; //object slicing -- nesne dilimlemesi

}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    int a, b;
};

class Der : public Base{
public:

    int x, y;

};


int main()
{
    std::cout <<"sizeof(Base) : " << sizeof (Base) << "\n";
    std::cout <<"sizeof(Der) : " << sizeof (Der) << "\n";
}

/***************************************************/
/***************************************************/



#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    ~Base()
    {
        std::cout << "Base dtor\n";
    }

};

class Der : public Base{
public:


};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    //Base() = delete;
    Base(int a)
    {
        std::cout << "Base default ctor\n";
    }

    ~Base()
    {
        std::cout << "Base dtor\n";
    }

};

class Der : public Base{
public:


};


int main()
{
    Der myder; //sentask hatası
    //derleyci default ctor delete etti

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    ~Base()
    {
        std::cout << "Base dtor\n";
    }

};

class Der : public Base{
public:
    Der()
    {
        std::cout << "Der default ctor\n";
    }

    ~Der()
    {
        std::cout << "Der dtor\n";
    }

};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    ~Base()
    {
        std::cout << "Base dtor\n";
    }

};

class Member{
public:
    Member()
    {
        std::cout << "Member default ctor\n";
    }

    ~Member()
    {
        std::cout << "Member dtor\n";
    }
};

class Der : public Base{
    Member mx;
public:
    Der()
    {
        std::cout << "Der default ctor\n";
    }

    ~Der()
    {
        std::cout << "Der dtor\n";
    }

};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    Base(int x)
    {
        std::cout << "Base x = " << x <<"\n";
    }

    Base(int x, int y)
    {
        std::cout << "Base x = " << x << " y = " << y << "\n";
    }
};

class Der : public Base{
public:
    Der()
    {
        std::cout << "Der default ctor\n";
    }
};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    Base(int x)
    {
        std::cout << "Base x = " << x <<"\n";
    }

    Base(int x, int y)
    {
        std::cout << "Base x = " << x << " y = " << y << "\n";
    }
};

class Der : public Base{
public:
    Der() : Base(15)
    {
        std::cout << "Der default ctor\n";
    }
};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    Base(int x)
    {
        std::cout << "Base x = " << x <<"\n";
    }

    Base(int x, int y)
    {
        std::cout << "Base x = " << x << " y = " << y << "\n";
    }
};

class Der : public Base{
public:
    Der() : Base{12, 4}
    {
        std::cout << "Der default ctor\n";
    }
};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/



#include <iostream>

class Base{
public:
    Base()
    {
        std::cout << "Base default ctor\n";
    }

    Base(int x)
    {
        std::cout << "Base x = " << x <<"\n";
    }

    Base(int x, int y)
    {
        std::cout << "Base x = " << x << " y = " << y << "\n";
    }
};

class Member{
public:
    Member(int)
    {
        std::cout << "Member int \n";
    }
};

class Der : public Base{
    Member mx;
public:
    Der() : Base{12, 4}, mx{5}
    {
        std::cout << "Der default ctor\n";
    }
};


int main()
{
    Der myder;

}

/***************************************************/
/***************************************************/


#include <iostream>

class Employee{
public:
    Employee(std::string name, int no);

};


class Developer : public Employee{
public:
    Developer(std::string name, int no, int status) : Employee(name, no)
    {

    }
};


int main()
{

}

/***************************************************/
/***************************************************/



#include <iostream>

class Base{
public:
    Base(){
        std::cout << "Base default ctor\n";
    }

    Base(const Base &){
        std::cout << "Base copy ctor\n";
    }
};

class Der : public Base{
public:
    //derleyici kendisi yazdı
};


int main()
{
    Der der1;
    Der der2(der1);
}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base(){
        std::cout << "Base default ctor\n";
    }

    Base(const Base &){
        std::cout << "Base copy ctor\n";
    }
};

class Der : public Base{
public:
    Der() = default;
    Der(const Der &){
        std::cout << "Der copy ctor\n";
    }
};


int main()
{
    Der der1;
    Der der2(der1);
}

/***************************************************/
/***************************************************/



#include <iostream>

class Base{
public:
    Base(){
        std::cout << "Base default ctor\n";
    }

    Base(const Base &){
        std::cout << "Base copy ctor\n";
    }
};

class Der : public Base{
public:
    Der() = default;
    Der(const Der &other) : Base(other) //artık base copy ctor cagırabildik
    {
        std::cout << "Der copy ctor\n";
    }
};


int main()
{
    Der der1;
    Der der2(der1);
}

/***************************************************/
/***************************************************/




#include <iostream>

class Base{
public:
    Base(){
        std::cout << "Base default ctor\n";
    }

    Base(const Base &&){
        std::cout << "Base move ctor\n";
    }
};

class Der : public Base{
public:
    Der() = default;
    Der(const Der &&other) : Base(std::move(other))
    {
        std::cout << "Der move ctor\n";
    }
};


int main()
{
    Der der1;
    Der der2{std::move(der1)};
}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    Base &operator=(const Base &){
        std::cout << "Base copy assignment\n";
        return *this;
    }
};

class Der : public Base{
public:
        //derleyiciye yazdırdık copy assignmnt ı
};


int main()
{
    Der der1;
    Der der3;

    der1 = der3;
}

/***************************************************/
/***************************************************/


#include <iostream>

class Base{
public:
    Base &operator=(const Base &){
        std::cout << "Base copy assignment\n";
        return *this;
    }
};

class Der : public Base{
public:
        Der &operator=(const Der &other)
        {
            std::cout << "Der copy assignment\n";
            Base::operator=(other);

            return *this;
        }
};


int main()
{
    Der der1;
    Der der3;

    der1 = der3;
}

/***************************************************/
/***************************************************/

#include <iostream>

class Base{
public:
    Base &operator=(const Base &&){
        std::cout << "Base move assignment\n";
        return *this;
    }
};

class Der : public Base{
public:
        Der &operator=(const Der &&other)
        {
            std::cout << "Der move assignment\n";
            Base::operator=(std::move(other));

            return *this;
        }
};


int main()
{
    Der der1;
    Der der3;

    der1 = std::move(der3);
}

/***************************************************/
/***************************************************/

#include <iostream>

class Car{
public:
    void start()
    {
        std::cout << "car has started\n";
    }
    void run()
    {
        std::cout << "car is running\n";
    }
    void stop()
    {
        std::cout << "car has stopped\n";
    }
};


class Mercedes : public Car{
public:
    void start()
    {
        std::cout << "Mercedes has started\n";
    }
    void run()
    {
        std::cout << "Mercedes is running\n";
    }
    void stop()
    {
        std::cout << "Mercedes has stopped\n";
    }
};

void cargame(Car &r)
{
    r.start();
    r.run();
    r.stop();
}

int main()
{
    Mercedes mymercedes;

    cargame(mymercedes);


}

/***************************************************/
/***************************************************/


#include <iostream>

class Car{
public:
    virtual void start()
    {
        std::cout << "car has started\n";
    }
    virtual void run()
    {
        std::cout << "car is running\n";
    }
    virtual void stop()
    {
        std::cout << "car has stopped\n";
    }
};


class Mercedes : public Car{
public:
    void start()
    {
        std::cout << "Mercedes has started\n";
    }
    void run()
    {
        std::cout << "Mercedes is running\n";
    }
    void stop()
    {
        std::cout << "Mercedes has stopped\n";
    }
};

void cargame(Car &r)
{
    r.start();
    r.run();
    r.stop();
}

int main()
{
    Mercedes mymercedes;

    cargame(mymercedes);


}

/***************************************************/
/***************************************************/

Kalıtımda taban sınfın üye fonksiyonları

3 fonksiyon kategorine ayrılır

a- türemiş sınıfların hem bir interface(arayüz) hem de implementatoin (kod ) veriliyor
b- türemiş sınıfların hem bir interface(arayüz) hem de defult implementatoin (kod ) veriliyor
c- türemiş sınıfların hem bir interface(arayüz) ama implementatoin (kod ) veriliyor


b ve c bir fonksiyona sahip sınıflar polimorfiktir

c seklinde uye fonksiyonlara sahip sınıf va ise abstract sınıftır



#include <iostream>

class Airplane{
    void fly();
};

class Chessna : public Airplane{
    //a kategorisine giriyor
    //fly fonksiyonuna sahip
    //base sınıfın verdiği kodu kullancak
};

int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>

class Airplane{
    void fly();
    virtual void takeoff(); //sanal uye fonksiyonu

    //eger fonksiyon static ise bu fonksiyon virtual bildirilemez


};

class Chessna : public Airplane{
    //b kategorisine giriyor
    //takeoff fonksiyonuna sahip
    //base sınıfın verdiği kodu kullancak
    //yadad kendi kodunu yazabilir


};

int main()
{

}

/***************************************************/
/***************************************************/

#include <iostream>

class Airplane{
    void fly();
    virtual void takeoff(); //sanal uye fonksiyonu
    virtual void land() = 0; //pure virtual function
    //sana sadece interface veririm
    //sen bu interface'i implemante etmek zorundasın
    //eger implement e etmesen benim gibi abstract olursun
    //Abstract --> soyut sınıf
    //soyut sınıflardan nesne olusturamayız
    //sadece pointer ve reference arayüzü ile kullanbiliriz
    //c kategori



};

class Chessna : public Airplane{
    };

int main()
{

}

/***************************************************/
/***************************************************/


abstract class - soyut sınıf -- bu sınıf türünden nesne olsturulamaz
concrete class - somut sınıf -- bu sımıf türünden nesne olusturabiliriz

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

Car *create_random_car()
{
    switch (rand() % 4) {
    case 0: cout << "Mercedes...\n"; return new Mercedes;
    case 1: cout << "Audi...\n"; return new Audi;
    case 2: cout << "Fiat...\n"; return new Fiat;
    case 3: cout << "Tofas...\n"; return new Tofas;
    }

    return nullptr;
}


void car_game(Car *ptr)
{
    ptr->start();
    ptr->run();
    ptr->stop();
}

int main()
{
    srand(static_cast<unsigned>(time(nullptr)));

    for(;;){
        car_game(create_random_car());
        _getch();
    }

}

/***************************************************/
/***************************************************/


foksiyon çağrıldıgı zaman dilim derleme zamnı ise
static binding / early binding


fonksiyon çağrıldıgı zaman dilimi run time da belli oluyor ise
dynamic binding / late binding

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base {
public:
    virtual void func(int x);
};

class Der : public Base{
public:
    void func(double x); // overrride değil
    //function ooverloading de degil
};

int main()
{


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base {
public:
    virtual void func(int x);
};

class Der : public Base{
public:
    double func(int x); //suan sentaks hatası
    //isim ve parametre aynı ama geri dönüş farklı oldugundan
};

int main()
{


}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base {
public:
    virtual void func(int x);
};

class Der : public Base{
public:
    void func(int x); //override olur artık
    //C++ eski de yöntemi
};

int main()
{


}

/***************************************************/
/***************************************************/


contextual keyword - baglamsal anahatar sözcük
override
final


belirli bir baglamda kullanıldıgında anahtarszöcük olarak ele alınır
eger belirli bir baglamda kullanı9lmazsa ise identfier  isim olarka kullanılır


/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

void car_game(Car *ptr)
{
    ptr->start();
    ptr->run();
    ptr->stop();
}

int main()
{
    srand(static_cast<unsigned>(time(nullptr)));
    Car *p = create_random_car();
    car_game(p);
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

void car_game(Car &ptr)
{
    ptr.start();
    ptr.run();
    ptr.stop();
}

int main()
{
    srand(static_cast<unsigned>(time(nullptr)));
    Car *p = create_random_car();
    car_game(*p);
}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

void car_game(Car ptr)
{
    ptr.start();
    ptr.run();
    ptr.stop();
}

int main()
{
    srand(static_cast<unsigned>(time(nullptr)));
    Car *p = create_random_car();
    car_game(*p);
}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
public:
    virtual void func(int) const;
    virtual void fooo(double);
};

class Der : public Base
{
    void func(int); //override degil cunku const olması lazım
    void fooo(float); //override degil cunku parametre farklı
};

int main()
{

}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
public:
    void func(int);

};

class Der : public Base
{
    void func(int); //override degil taban sınıf sanal degil

};

int main()
{

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
public:
    void func(int);

};

class Der : public Base
{
    void func(int) override; //sentaks hatası olur

};

int main()
{

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
public:
    virtual void func(int);

};

class Der : public Base
{
    void func(int) override;

};

//cpp

void Der::func(int)
{

}

int main()
{

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
public:
    virtual void func(int)const;

};

class Der : public Base
{
    //void func(int) const override; //gecerli
    void func(int) override const;  //sentask hatası

};

int main()
{

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

//polimorfik sınıf
class Base{
public:
    virtual void func();

};


int main()
{
    Base mybase;
}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

//abstract sınıf
class Base{
public:
    virtual void func() = 0;

};


int main()
{
    Base mybase; //abstract sınıftan nesne olusturamayız
}

/***************************************************/
/***************************************************/
#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

//abstract sınıf
class Base{
public:
    virtual void func() = 0;

};

class Der : public Base{

};


int main()
{
    Der myder;//abstract sınıftan nesne olusturamayız
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

//abstract sınıf
class Base{
public:
    virtual void f1() = 0;
    virtual void f2() = 0;
    virtual void f3() = 0;

};

class Der : public Base{
    void f1()override;
    void f2()override;
    void f3()override;
};


int main()
{
    Der myder;
}

/***************************************************/
/***************************************************/


abstract sınıfların reference ve pointer semantiği ile kullanılır



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

//abstract sınıf
class Base{
public:
    virtual void f1() = 0;
    virtual void f2() = 0;
    virtual void f3() = 0;

};

void foo(Base *baseptr)
{
    baseptr->f1();
    baseptr->f2();
    baseptr->f3();
}

void func(Base &baseptr)
{
    baseptr.f1();
    baseptr.f2();
    baseptr.f3();
}


int main()
{

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;



int main()
{
    Fiat f;
    f.check();

}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
    int x, y;

public:
    void func();
};

int main()
{
    cout << "sizeof Base = " << sizeof (Base) << "\n";
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
    int x, y;

public:
    virtual void f1();
    virtual void f2();
    virtual void f3();
    virtual void f4();
    virtual void f5();
    virtual void f6();
    virtual void f7();
    virtual void f8();
    virtual void f9();
    virtual void f11();
    virtual void f12();
    virtual void f13();

};

int main()
{
    cout << "sizeof Base = " << sizeof (Base) << "\n";
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
    int x, y;

public:
    virtual void f1();
    virtual void f2();
    virtual void f3();
};

class Der : public Base{

};

int main()
{
    cout << "sizeof Base = " << sizeof (Base) << "\n";
    cout << "sizeof Der = " << sizeof (Der) << "\n";
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
    int x, y;

public:
    virtual void f1();
    virtual void f2();
    virtual void f3();
};

class Der : public Base{
    void f1()override;
    void f2()override;
    void f3()override;
};

int main()
{
    cout << "sizeof Base = " << sizeof (Base) << "\n";
    cout << "sizeof Der = " << sizeof (Der) << "\n";
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc(){
        cout << "Base::vfunc\n";
    }
};


class Der : public Base{
private:
    void vfunc()override; //gecerli
};


int main()
{
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc(){
        cout << "Base::vfunc\n";
    }
};

class Der : public Base{
private:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

void func(Base &baseref)
{
    baseref.vfunc();
}

int main()
{
    Der myder;
    func(myder); //gecerli

    //myder.vfunc(); //sentaks private oldugu için
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc(int x = 10){
        cout << "Base::vfunc x = " << x << "\n" ;
    }
};

class Der : public Base{
public:
    void vfunc(int x = 15)override //default arguman degerlerinin aynı verecez
    {
        cout << "Der::vfunc x = " << x << "\n";
    }
};

void func(Base &baseref)
{
    baseref.vfunc();
}

int main()
{
    Der myder;
    func(myder); //gecerli

    myder.vfunc(); //sentaks private oldugu için
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    void foo()
    {
        vfunc();
    }

    virtual void vfunc(){
        cout << "Base::vfunc\n" ;
    }
};

class Der : public Base{
public:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
    myder.foo();
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    void foo()
    {
        vfunc();
        this->vfunc();
        Base::vfunc();
    }

    virtual void vfunc(){
        cout << "Base::vfunc\n" ;
    }
};

class Der : public Base{
public:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
    myder.foo();
}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base default ctor\n";
        vfunc();
        //ctor içinde yapılan cagrılar sananlık olayşarı baglmaaz
    }

    virtual void vfunc(){
        cout << "Base::vfunc\n" ;
    }
};

class Der : public Base{
public:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    ~Base()
    {
        cout << "Base dtor\n";
        vfunc();
        //dtor içinde yapılan cagrılar sanallık mekanızması
        //devreye girmez
    }

    virtual void vfunc(){
        cout << "Base::vfunc\n" ;
    }
};

class Der : public Base{
public:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    void foo()
    {
        vfunc();
        Base::vfunc();
    }

    virtual void vfunc(){
        cout << "Base::vfunc\n" ;
    }
};

class Der : public Base{
public:
    void vfunc()override
    {
        cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
    myder.foo();
}

/***************************************************/
/***************************************************/


virtual constructor idiyomu



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual Base();//sentaks hatası
};



int main()
{

}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


void car_game(Car *ptr)
{
    auto p = ptr->clone();
}


int main()
{
    Car *pc = new Audi;
    Car &r = *new Audi;
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


void car_game(Car *ptr)
{
    auto p = ptr->clone();
    ptr->start();
    p->start();
    getchar();
}


int main()
{
    for (; ; ) {
        auto p = create_random_car();
        car_game(p);
    }
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc()
    {
        cout << "Base vfunc\n";
    }

    ~Base()
    {
        cout << "Base nesnesinin geri veriyor\n";
    }
};

class Der : public Base
{
public:
    Der()
    {
        cout << "Der kaynak alindi\n";
    }
    ~Der()
    {
        cout << "Der kaynak verildi\n";
    }
};


int main()
{
    Der myder;
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc()
    {
        cout << "Base vfunc\n";
    }

    ~Base()
    {
        cout << "Base nesnesinin geri veriyor\n";
    }
};

class Der : public Base
{
public:
    Der()
    {
        cout << "Der kaynak alindi\n";
    }
    ~Der()
    {
        cout << "Der kaynak verildi\n";
    }
};


int main()
{
    Der *pd =  new Der;

    delete  pd;
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc()
    {
        cout << "Base vfunc\n";
    }

    ~Base()
    {
        cout << "Base nesnesinin geri veriyor\n";
    }
};

class Der : public Base
{
public:
    Der()
    {
        cout << "Der kaynak alindi\n";
    }
    ~Der()
    {
        cout << "Der kaynak verildi\n";
    }
};


int main()
{
    Base *p =  new Der;

    delete  p;
    //dikkatli ol kaynak sızındtısı var
}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual void vfunc()
    {
        cout << "Base vfunc\n";
    }

    virtual~Base()
    {
        cout << "Base nesnesinin geri veriyor\n";
    }
};

class Der : public Base
{
public:
    Der()
    {
        cout << "Der kaynak alindi\n";
    }

    ~Der()
    {
        cout << "Der kaynak verildi\n";
    }
};


int main()
{
    Base *p =  new Der;

    delete  p;
    //destructor virtual yapıldıgın sızıntı problemi ortadan kalktı
}

/***************************************************/
/***************************************************/


taban sınıfların dtor u public ise mutlaka vitual olacak
Eger virtaul dtro olmasını istemiyor isek protected yapacaz


derleyiciye kendimşiz yaz dememiz lazım
virtual~Base() = default;


/***************************************************/
/***************************************************/


sınıf içinde using bildirimleri



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }
};


class Der : public Base{

};

int main()
{
    Der myder;
    myder.func(12); //sentaks hatası erişim yok

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }
};


class Der : public Base{
public:
    void func(int x)
    {
        //func(x); //recursive

        Base::func(x);
    }

};

int main()
{
    Der myder;
    myder.func(12); //sentaks hatası erişim yok

}

/***************************************************/
/***************************************************/




#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

    void func(int x, int y)
    {
        cout << "Base func x = " << x << " y = "<< y << "\n";
    }
};


class Der : public Base{
public:
    void func(double dx)
    {
        cout << "Der func dx = " << dx << "\n";
    }

};

int main()
{
    Der myder;
    myder.func(12, 33); //sentaks hatsı


}

/***************************************************/
/***************************************************/




#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

    void func(int x, int y)
    {
        cout << "Base func x = " << x << " y = "<< y << "\n";
    }
};


class Der : public Base{
public:
    void func(double dx)
    {
        cout << "Der func dx = " << dx << "\n";
    }

    void func(int x)
    {
        Base::func(x);
    }

    void func(int x, int y)
    {
        Base::func(x, y);
    }

};

int main()
{
    Der myder;
    myder.func(12, 33); //şimdi gecerli


}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

};


class Der : public Base{
public:
    using Base::func;

};

int main()
{

    Der myder;

    myder.func(12);


}

/***************************************************/
/***************************************************/




#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

protected:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

    void func(int x, int y)
    {
        cout << "Base func x = " << x  << " y = " << y << "\n";
    }

};


class Der : public Base{
public:
    using Base::func;

};

int main()
{

    Der myder;

    myder.func(12);
    myder.func(12, 44);


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

    private:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

    void func(int x, int y)
    {
        cout << "Base func x = " << x  << " y = " << y << "\n";
    }

};


class Der : public Base{
public:
    using Base::func; //gecerli olmaz private oldugu için

};

int main()
{

    Der myder;

    myder.func(12);
    myder.func(12, 44);


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:

public:
    void func(int x)
    {
        cout << "Base func x = " << x << "\n";
    }

    void func(int x, int y)
    {
        cout << "Base func x = " << x  << " y = " << y << "\n";
    }

    void func(double dx)
    {
        cout << "Base func dx = " << dx << "\n";
    }

};


class Der : public Base{
public:
    using Base::func;
    void func(double dx)
    {
        cout << "Der func dx = " << dx << "\n";
    }

};

int main()
{

    Der myder;

    myder.func(12);
    myder.func(12, 44);

    myder.func(123.3); //türemiş sınıftaki func ı dikkate alır


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    Base(int x);
    Base(int x, int y);
    Base(double dx);
    int func();
    int foo(double);
    int f();

};


class Der : public Base{
public:
    void g();

};

int main()
{

    Der myder(12, 33);

    //der in iki parametreli ctor i olmasıgı için sentaks hatası

}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    Base(int x);
    Base(int x, int y);
    Base(double dx);
    int func();
    int foo(double);
    int f();

};


class Der : public Base{
public:
    Der(int x) : Base(x){}
    Der(int x, int y) : Base(x, y){}
    Der(double dx) : Base(dx){}

};

int main()
{

    Der myder(12, 33);

    myder.foo(12);

}

/***************************************************/
/***************************************************/
#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    Base(int x);
    Base(int x, int y);
    Base(double dx);
    int func();
    int foo(double);
    int f();

};


class Der : public Base{
public:
    using Base::Base;
    //modern C++ ile bu özellik getirildi

};

int main()
{

    Der myder(12, 33);

    myder.foo(12);

}

/***************************************************/
/***************************************************/


variant return type

yada

covariant




#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class Base{
public:
    virtual int foo(int);

};


class Der : public Base{
public:
    double foo(int);//override olmaz gecerlide degil
    //geri donus türü fakrlı aynı olması gerekiyor
};

int main()
{


}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class B{
public:

};


class A : public B{
public:

};

class Base{
public:
    virtual B* func();
};


class Der : public Base{
public:
    A * func()override;

    //variant return type
    //covariant
};


int main()
{


}

/***************************************************/
/***************************************************/

referans semantigi


#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class B{
public:

};


class A : public B{
public:

};

class Base{
public:
    virtual B& func();
};


class Der : public Base{
public:
    A & func()override;

    //variant return type
    //covariant
};


int main()
{


}

/***************************************************/
/***************************************************/


bu şekilde olmaz

#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;

class B{
public:

};


class A : public B{
public:

};

class Base{
public:
    virtual B func();
};


class Der : public Base{
public:
    A func()override;

    //variant return type
    //covariant
};


int main()
{


}

/***************************************************/
/***************************************************/

Non virtual interface
NVI


template method
şablon methodu



#include "car.hpp"
#include <cstdlib>
#include <cctype>
#include <conio.h>

using namespace std;


class Base{
private:
    virtual void vfunc();
    virtual void vfoo();

public:
    void func()
    {
        vfunc();
    }

    void foo()
    {
        vfoo();
    }

};


class Der : public Base{
public:
    void vfunc()override;
    void vfoo()override;

};

void g(Base & baseref)
{
    baseref.func();
    baseref.foo();
}


int main()
{


}

/***************************************************/
/***************************************************/

polimorfik liste


#include "car.hpp"
#include <iostream>
#include <vector>

using namespace std;



int main()
{
    vector<Car *> carvec;

    for (int i = 0; i < 10; ++i) {
        carvec.push_back(create_random_car());
    }

    for (size_t i{}; i < carvec.size(); ++i) {
        carvec[i]->start();
        carvec[i]->run();
        carvec[i]->stop();
        cout << "\n";
        getchar();
    }

    for (size_t i{}; i < carvec.size(); ++i) {
        delete carvec[i];
    }


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>
#include <vector>
#include <memory>

using namespace std;



int main()
{
    vector<std::unique_ptr<Car>> carvec;

    for (int i = 0; i < 10; ++i) {
        carvec.push_back(std::unique_ptr<Car>{create_random_car()});
    }


    for (size_t i{}; i < carvec.size(); ++i) {
        carvec[i]->start();
        carvec[i]->run();
        carvec[i]->stop();
        cout << "\n";
        getchar();
    }

}

/***************************************************/
/***************************************************/


çoklu kalıtım
multiple inheritance

bir sınıfın birden fazla taban sınıftan kalıtım yolu ile elde edilmesi


#include "car.hpp"
#include <iostream>

using namespace std;

class Base1{
public:
    void func();
    void fooo();
};



class Base2{
public:
    void f1();
    void f2();
};

//publix Base1 türemesi private Base2 türemesi

/*class Der : public Base1, Base2{

};
*/

//her iki sınıftan public türemiş olur

class Der : public Base1, public Base2{

};

int main()
{
    Der myder;

    myder.f1();
    myder.f2();
    myder.fooo();
    myder.func();
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class Base1{
public:
    void func();
    void fooo();
};



class Base2{
public:
    void f1();
    void f2();
};

//publix Base1 türemesi private Base2 türemesi

/*class Der : public Base1, Base2{

};
*/

//her iki sınıftan public türemiş olur

class Der : public Base1, public Base2{

};

int main()
{
    //yapabiliriz
    Base1 *bs1 = new Der;
    Base2 *bs2 = new Der;
}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class Base1{
public:
    void func();
    void fooo();
};



class Base2{
public:
    void f1();
    void f2();
};

//publix Base1 türemesi private Base2 türemesi

/*class Der : public Base1, Base2{

};
*/

//her iki sınıftan public türemiş olur

class Der : public Base1, public Base2{

};

void gf1(Base1 &);
void gf2(Base2 &);

int main()
{
    //yapabiliriz
    Der myder;

    gf1(myder);
    gf2(myder);

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class Base1{
public:
    void func();
    void fooo();
};



class Base2{
public:
    void f1();
    void f2();
};

//publix Base1 türemesi private Base2 türemesi

/*class Der : public Base1, Base2{

};
*/

//her iki sınıftan public türemiş olur

class Der : public Base1, public Base2{

};

//overloading
void gf(Base1 &);
void gf(Base2 &);

int main()
{
    //yapabiliriz
    Der myder;

    gf(static_cast<Base1&>(myder));
    gf(static_cast<Base2&>(myder));

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class Base1{
public:
    virtual void func();
    void fooo();
};

class Base2{
public:
    virtual void f1();
    void f2();
};

class Der : public Base1, public Base2{
public:
    void func()override;
    void f1()override;
};



int main()
{

}

/***************************************************/
/***************************************************/



#include "car.hpp"
#include <iostream>

using namespace std;

class A{
public:
    A(){
        cout << "A ctor \n";
    }

    ~A(){
        cout << "A dtor \n";
    }
};


class B{
public:
    B(){
        cout << "B ctor \n";
    }

    ~B(){
        cout << "B dtor \n";
    }
};

class C : public A, public B{

};


int main()
{
    C cx;

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class A{
public:
    void func(int x)
    {
        cout << "A func x = " << x << "\n";
    }
};


class B{
public:
    void func(int x, int y)
    {
        cout << "A func x = " << x << " y = " << y << "\n";
    }
};

class C : public A, public B{

};


int main()
{
    C cx;
    //hata iki sınıftada func isminde fonksiyon ben hangisini cagıracagıma sasırdım
    //sakın türeme ile alakası oldugunu düşünmeyin
    cx.func(12);

}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;

class A{
public:
    void func(int x)
    {
        cout << "A func x = " << x << "\n";
    }
};


class B{
public:
    void func(int x, int y)
    {
        cout << "A func x = " << x << " y = " << y << "\n";
    }
};

class C : public A, public B{

};


int main()
{
    C cx;

    //artık gecerli
    cx.A::func(12);
    cx.B::func(12, 15);

}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>

using namespace std;
//elams formasyonu

//DDD --> dreaded Dimond of derivation

class A{
public:
    void afunc(int x);
};


class B : public A{
public:

};

class C : public A{

};

class D : public B, public C{
public:
    void f()
    {
        //afunc(); //setantaks hatası
        B::afunc(2);
        C::afunc(3);

    }
};


int main()
{
    D dx;

    //dx.afunc(12); //dentasks hatası

    //gecerli
    dx.B::afunc(12);
    dx.C::afunc(11);

    //A *ptr = &dx; //sentaks hatası
    //B ve C den gelen A this pointerı oldugundan çift anlamlılık

    A *ptr1 = static_cast<B*>(&dx);
    A *ptr2 = static_cast<C*>(&dx);

}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>

using namespace std;
//elams formasyonu

//DDD --> dreaded Dimond of derivation


class EDevice{
private:
    bool mflag = false;

public:
    void turn_on()
    {
        mflag = true;
    }

    void turn_off()
    {
        mflag = false;
    }


    bool isOn()const
    {
        return mflag;
    }
};


class Modem : public EDevice{
public:
    void sendData()
    {
        if(!isOn()){
            cout << "cihaz kapali oldgun data gonderilemiyor\n";
        }
        else{
            cout << "data gonderildi\n";
        }
    }
};

class Fax : public EDevice{
public:
    void sendFax()
    {
        if(!isOn()){
            cout << "cihaz kapali oldgun fax gonderilemiyor\n";
        }
        else{
            cout << "fax gonderildi\n";
        }
    }
};

class FaxModem : public Fax, public Modem{
    ///
};


int main()
{
    FaxModem fm;

    fm.Fax::turn_on();
    //fm.Modem::turn_on();
    fm.sendFax();
    fm.sendData();


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>

using namespace std;
//elams formasyonu

//DDD --> dreaded Dimond of derivation


class A{
public:
    void afunc(int x);
};


class B : virtual public A{
public:

};

class C : virtual public A{

};

class D : public B, public C{
public:
    void f()
    {
        afunc(12);

    }
};


int main()
{
    D der;
    der.afunc(12);

    A *ptr = new D;



}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;
//elams formasyonu

//DDD --> dreaded Dimond of derivation


class EDevice{
private:
    bool mflag = false;

public:
    void turn_on()
    {
        mflag = true;
    }

    void turn_off()
    {
        mflag = false;
    }


    bool isOn()const
    {
        return mflag;
    }
};


class Modem : virtual public EDevice{
public:
    void sendData()
    {
        if(!isOn()){
            cout << "cihaz kapali oldgun data gonderilemiyor\n";
        }
        else{
            cout << "data gonderildi\n";
        }
    }
};

class Fax : virtual public EDevice{
public:
    void sendFax()
    {
        if(!isOn()){
            cout << "cihaz kapali oldgun fax gonderilemiyor\n";
        }
        else{
            cout << "fax gonderildi\n";
        }
    }
};

class FaxModem : public Fax, public Modem{
    ///
};


int main()
{
    FaxModem fm;

    fm.turn_on();
    fm.sendFax();
    fm.sendData();


}

/***************************************************/
/***************************************************/

#include "car.hpp"
#include <iostream>

using namespace std;


class Base{
public:
    Base(int x)
    {
        cout << "Base int x = " << x << "\n";
    }
};


class Der1 : virtual public Base{
public:
    Der1() : Base(12){}
};

class Der2 : virtual public Base{
public:
    Der2() : Base(12){}
};

class SpecialDer : public Der1, public Der2{
public:
};

int main()
{
    Der1 d1;
    Der2 d2;

    SpecialDer sd; //neden delete edilmiş defaulr ctor


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>

using namespace std;


class Base{
public:
    Base(int x)
    {
        cout << "Base int x = " << x << "\n";
    }
};


class Der1 : virtual public Base{
public:
    Der1() : Base(12){}
};

class Der2 : virtual public Base{
public:
    Der2() : Base(12){}
};

class SpecialDer : public Der1, public Der2{
public:
    SpecialDer() : Base(12){}

};

int main()
{
    Der1 d1;
    Der2 d2;

    SpecialDer sd; //artık gecerli


}

/***************************************************/
/***************************************************/


#include "car.hpp"
#include <iostream>

using namespace std;


class Base{
public:
    Base(int x)
    {
        cout << "Base int x = " << x << "\n";
    }
};


class Der1 : virtual public Base{
public:
    Der1() : Base(12){}
};

class Der2 : virtual public Base{
public:
    Der2() : Base(12){}
};

class SpecialDer : public Der1, public Der2{
public:
    SpecialDer() : Base(12){}

};

class VerySpecialDer : public SpecialDer{
public:
    VerySpecialDer() : Base(12){}
};

int main()
{
    Der1 d1;
    Der2 d2;

    SpecialDer sd; //artık gecerli

    VerySpecialDer vsd; //default ctor delete


}

/***************************************************/
/***************************************************/


yeni konu

exception handling



throw
try
catch


throw statement
hatayı tespit edip daha yukarıdaki kolara bu hatadan haberdae etmek için
bir kod nesnesi olusturur ve gönderrir


try block
eger söyle bir hata var ise olursa ben buna mühale edecem diyor


catch block
hata nesnesinin yakalanması durumnda hatanın işlenmesi durumunda catch blogu devreye girerr


throw edildiğinde
terminate fonksiyonu cagrılır buda aslında abort'u cagırır



#include <iostream>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";
    throw 5;
    //eger hata yakalnamaz ise bu alttaki işlemmleri yapar
    //terminate fonksiyonun abort fonksiyonunu cagırıp abort etti
    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    cout << "main baslad\n";
    f1();
    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <cstdlib>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";
    int x = 1;
    throw x; //yeni hata nesnesi olusturup onu gönderiyor
    //terminate fonksiyonun abort fonksiyonunu cagırıp abort etti
    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    //eski abort özelliklerini kaydet
    //ve yebi myabort özelliklerini al
    auto f = set_terminate(myabort);

    //eski haline gerir döner
    set_terminate(f);

    cout << "main baslad\n";
    f1();
    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


uncaught exception -- hata yalanamadıgı dyuruum

terminate fonksiyonu cagrıır
terminate fonksşyonuda abort'u cagırır ve programı sonlandırır


/***************************************************/
/***************************************************/

try blok


try{
  //
  int cnt = 0;
}
catch(int x){
catch(const T& x){


}

try blok'tan sonra en az bir catch gelecek

türü neyse hatanın  o parametreli catch yakalar
try{

}
catch(int x){

}
catch(double){

}
catch(long x)
{

}



#include <iostream>
#include "utility.hpp"
#include <cstdlib>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";
    int x = 1;
    throw x; //yeni hata nesnesi olusturup onu gönderiyor
    //terminate fonksiyonun abort fonksiyonunu cagırıp abort etti
    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (int val) {
        cout << "hata yakalandi  val = " << val << "\n";
    }


    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";
    //throw 'a';
    throw 4.5;
    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (int val) {
        cout << "hata yakalandi  val = " << val << "\n";
    } catch (char c) {
        cout << "hata yakalandi  c = " << static_cast<int>(c) << "\n";
    }



    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

//all catch
catch(...)
{
  cout << "butun catch türleri yakalanır"\n;
}


#include <iostream>
#include "utility.hpp"
#include <cstdlib>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";
    //throw 'a';
    throw 4.5;
    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (int val) {
        cout << "hata yakalandi  val = " << val << "\n";
    } catch (char c) {
        cout << "hata yakalandi  c = " << static_cast<int>(c) << "\n";
    } catch(...){
        cout << "hata yakalndi\n";
    }



    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

hata yakaladık ne yapacaz


1- hataya tamamen dühale eder ve program handler kodu izleyen kodla devam eder
2- hataya kısmen müdahale eder ve hata nesnesini yeniden gönderirir
3- hatayı translate eder -- haa türünü değiştirir
4- terminate eder





#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";

    std::string str{"orhan"};

    str.at(30) = 'X'; //out of range

    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi  = " << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";

    std::string str{"orhan"};

    str.at(30) = 'X'; //out of range

    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (std::logic_error &ex) { //kalıtım yapıası var
        cout << "hata yakalandi  = " << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


void f4()
{
    cout << "f4 basladi\n";

    std::string str{"orhan"};

    str.at(30) = 'X'; //out of range

    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (std::exception &ex) { //kalıtım yapıası var
        cout << "hata yakalandi  = " << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


try{

}
catch(std::out_of_range  &ex){

}
catch(std::logic_error &ex){

}
catch(std::exception &ex){

}
catch(...){

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


class bad_date : public std::exception{
public:
    const char *what()const override{
        return "gecersiz tarhi olusumu\n";
    }
};

class Date{
public:
    int getDate(){
        throw bad_date{};
    }
};

void f4()
{
    cout << "f4 basladi\n";

    Date date;

    auto n = date.getDate();

    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";
    f4();
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (std::exception &ex) { //kalıtım yapıası var
        cout << "hata yakalandi  = " << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


class bad_date : public std::exception{
public:
    const char *what()const override{
        return "gecersiz tarhi olusumu\n";
    }
};

class Date{
public:
    int getDate(){
        throw bad_date{};
    }
};

void f4()
{
    cout << "f4 basladi\n";

    Date date;

    auto n = date.getDate();

    cout << "f4 sona erdi\n";
}


void f3()
{
    cout << "f3 basladi\n";

    try {
        f4();
    }  catch (std::exception &ex) {
        cout << "f3 hata yakaladi .. : " << ex.what() << "\n";
    }
    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{
    set_terminate(myabort);

    cout << "main baslad\n";

    try {
        f1();
    }  catch (std::exception &ex) { //kalıtım yapıası var
        cout << "hata yakalandi  = " << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

stack unwinding -- yagının geri sarımı


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


class Orhn{
public:
    Orhn(){
        cout << this << " adresteki Orhn nesnesi icin kaynak alindi\n";
    }

    ~Orhn(){
        cout << this << " adresteki Orhn nesnesi icin kaynak verildi\n";
    }
};


void f3()
{
    cout << "f3 basladi\n";
    Orhn orhn;
    throw  std::runtime_error{"orhan hatasi\n"};

    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{

    cout << "main baslad\n";

    f1();

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


class Orhn{
public:
    Orhn(){
        cout << this << " adresteki Orhn nesnesi icin kaynak alindi\n";
    }

    ~Orhn(){
        cout << this << " adresteki Orhn nesnesi icin kaynak verildi\n";
    }
};


void f3()
{
    cout << "f3 basladi\n";
    Orhn orhn;
    throw  std::runtime_error{"orhan hatasi\n"};

    cout << "f3 sona erdi\n";
}


void f2()
{
    cout << "f2 basladi\n";
    f3();
    cout << "f2 sona erdi\n";
}


void f1()
{
    cout << "f1 basladi\n";
    f2();
    cout << "f1 sona erdi\n";
}


int main()
{

    cout << "main baslad\n";
    try {
        f1();
    }  catch (std::exception &ex) {
        getchar();
        cout << "hata yakalnadi " << ex.what() << "\n";
    }

//artık exception yakaladıgımız icin bellek sızıntısı olmaz

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;

void foo()
{
    cout << "foo basladi\n";
    throw std::runtime_error("hata hata hata\n");
    cout << "foo sonlandi\n";
}

void func()
{
    cout << "func basladi\n";

    auto p = new int[10000];
    //
    //

    foo();

    delete [] p; //hata yakalanmadıgı icin alına  yer geri verilmedi

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    func();

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;

void foo()
{
    cout << "foo basladi\n";
    throw std::runtime_error("hata hata hata\n");
    cout << "foo sonlandi\n";
}

void func()
{
    cout << "func basladi\n";

    auto p = new int[10000];
    //
    //

//bunu kullanmayınız

    try {
       foo();
    }  catch (std::exception &ex) {
       delete [] p;
       cout << "hata yakalnadi " << ex.what() << "\n";
    }

    delete [] p; //hata yakalanmadıgı icin alına  yer geri verilmedi

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    func();

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;

void foo()
{
    cout << "foo basladi\n";
    throw std::runtime_error("hata hata hata\n");
    cout << "foo sonlandi\n";
}

class ResourceUser{
public:
    ResourceUser() : mp{new int[10000]}{}

    ~ResourceUser(){
        cout<< "dtor ResourceUser\n";
        delete [] mp;
    }

private:
    int *mp;
};

void func()
{
    cout << "func basladi\n";

    ResourceUser rsx;

    try {
        foo();
    }  catch (std::exception &ex) {
        cout << "hata yakalandi.... " << ex.what() << "\n";
    }


    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    func();

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;


void func()
{
    cout << "func basladi\n";
    string str(20000, 'A');
    throw 1;
    //str RAII nesnesi

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    func();

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>
#include "car.hpp"

using namespace std;

void foo()
{
    throw  std::logic_error{"hata\n"};
}

void func()
{
    cout << "func basladi\n";

    //dinamik omur lu nesne
    Car *p = create_random_car();
    foo();

    //dinamik omurlu nesnelerde smart pointer kullanmalıyız

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    try {
        func();
    }  catch (std::exception &ex) {
        std::cout << " hata yakalandi ..." << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>
#include "car.hpp"

using namespace std;

void foo()
{
    throw  std::logic_error{"hata\n"};
}

void func()
{
    cout << "func basladi\n";

    //dtor cagrılacak
    Mercedes ms;
    foo();

    //dinamik omurlu nesnelerde smart pointer kullanmalıyız

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    try {
        func();
    }  catch (std::exception &ex) {
        std::cout << " hata yakalandi ..." << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>
#include "car.hpp"
#include <memory>

using namespace std;

void foo()
{
    throw  std::logic_error{"hata\n"};
}

void func()
{
    cout << "func basladi\n";

    //dinamik omur lu nesne
    std::unique_ptr<Car> uptr{create_random_car()}; //artık dtor cagrılacak
    foo();

    //dinamik omurlu nesnelerde smart pointer kullanmalıyız

    cout << "func sonlandi\n";
}



int main()
{

    cout << "main baslad\n";

    try {
        func();
    }  catch (std::exception &ex) {
        std::cout << " hata yakalandi ..." << ex.what() << "\n";
    }

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <cstdlib>
#include <string>
#include <stdexcept>
#include "car.hpp"
#include <memory>

using namespace std;


class File{
public:
    File(const char *p);
    ~File();
};


int main()
{

    cout << "main baslad\n";


    File f{"orhn.txt"};

    //artık kapanacak thwo edildiginde

    cout << "main sona eriyor\n";
}

/***************************************************/
/***************************************************/


rethrow statement
revisiting RAII idiom

throw;



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void foo()
{
    vector<int> ivec;

    ++ivec.at(20);
}

void func()
{
    try {
        foo();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
        throw ex; //this is not rethrow statement
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    func();

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void foo()
{
    vector<int> ivec;

    ++ivec.at(20);
}

void func()
{
    try {
        foo();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
        throw ex; //this is not rethrow statement
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
    }
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void foo()
{
    vector<int> ivec;

    ++ivec.at(20);
}

void func()
{
    try {
        foo();
    }  catch (std::exception &ex) {//artık tür bilgisi kaybıldu
        cout << "hata yakalandi... " << ex.what() << "\n";
        throw ex; //this is not rethrow statement
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
    }
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void foo()
{
    vector<int> ivec;

    ++ivec.at(20);
}

void func()
{
    try {
        foo();
    }  catch (std::exception &ex) {//artık tür bilgisi kaybıldu
        cout << "hata yakalandi... " << ex.what() << "\n";
        throw; // rethrow statement
        //burada out_of_range godneririlir
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
    }
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myexception{
public:
    ~Myexception()
    {
        cout << "Myexception destructor\n";
    }
};


void foo()
{
    Myexception exp;
    throw exp;
}

void func()
{
    try {
        foo();
    }  catch (Myexception &ex) {//artık tür bilgisi kaybıldu
        cout << "hata yakalandi... \n";
        throw ex;
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (Myexception &ex) {
        cout << "hata yakalandi... << \n";
    }
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myexception{
public:
    ~Myexception()
    {
        cout << "Myexception destructor\n";
    }
};


void foo()
{
    Myexception exp;
    throw exp;
}

void func()
{
    try {
        foo();
    }  catch (Myexception &ex) {//artık tür bilgisi kaybıldu
        cout << "hata yakalandi... \n";
        throw;
    }
}


int main()
{
    set_terminate(&myabort);
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (Myexception &ex) {
        cout << "hata yakalandi... << \n";
    }
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void foo()
{
    cout << "foo cagrildi  ve foo hata nesnesini tekrar gonderiyor\n";
    throw;
}

void func()
{
    try {
        throw out_of_range{"out_of_range"};
    }  catch (std::exception &ex) {
        foo();
    }
}


int main()
{
    std::cout << "main baslsadiii...\n";

    try {
        func();
    }  catch (std::out_of_range &ex) {
        cout << "hata yakalandi... " << ex.what() << "\n";
    }
}

/***************************************************/
/***************************************************/

exception safety -- hata gücenliği

1- temel garanti

2- Sıkı garanti

3- Hata göndermeme garantisi



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{
public:
    Myclass()
    {
        cout << "myclass ctor\n";
    }

    ~Myclass()
    {
        cout << "myclass dtor\n";
    }
};

void func()
{
    Myclass mc;
    throw  std::exception{};
}


int main()
{
    try {
        func();
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{
    char buffer[1024];
public:
    Myclass()
    {
        cout << "myclass ctor\n";
        throw  std::exception{};
    }

    ~Myclass()
    {
        cout << "myclass dtor\n";
    }
};


int main()
{
    try {
        Myclass *p = new Myclass;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Member{
public:
    Member()
    {
        cout << "member default ctor\n";
        throw  std::exception{};
    }
    ~Member()
    {
        cout << "Member default dtor\n";
    }
};

class Myclass{
public:
    Myclass()
    {
        cout << "myclass ctor\n";
    }

    ~Myclass()
    {
        cout << "myclass dtor\n";
    }
private:
    Member mx;
};


int main()
{
    try {
        Myclass mx; //myclass nesnesi hayata gelmez
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Member{
public:
    Member()
    {
        static int cnt = 0;
        cout << "member default ctor\n";

        if(cnt++)
            throw  std::exception{};
    }
    ~Member()
    {
        cout << "Member default dtor\n";
    }
};

class Myclass{
public:
    Myclass()
    {
        cout << "myclass ctor\n";
    }

    ~Myclass()
    {
        cout << "myclass dtor\n";
    }
private:
    Member mx, my;
};


int main()
{
    try {
        Myclass mx;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Member{
public:
    Member()
    {
        cout << "member default ctor\n";
    }
    ~Member()
    {
        cout << "Member default dtor\n";
    }
};

class Myclass{
public:
    Myclass()
    {
        cout << "myclass ctor\n";
        throw  exception{};
    }

    ~Myclass()
    {
        cout << "myclass dtor\n";
    }
private:
    Member mx, my;
};


int main()
{
    try {
        Myclass mx;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Orhn{
public:
    Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari edindi\n";
    }
    ~Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari verdi\n";
    }
};

class Myclass{
public:
    Myclass()
    {
        Orhn oz;
        throw std::exception{};
    }

};


int main()
{
    try {
        Myclass mx;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Orhn{
public:
    Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari edindi\n";
    }
    ~Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari verdi\n";
    }
};

class Myclass{
private:
    Orhn *oz;
public:
    Myclass() : oz{new Orhn}
    {
        throw std::exception{};
    }

    ~Myclass()
    {
        delete oz;
    }

};


int main()
{
    try {
        Myclass mx;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Orhn{
public:
    Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari edindi\n";
    }
    ~Orhn()
    {
        cout << this << " adresindeki Orhn nesnesi kaynaklari verdi\n";
    }
};

class Myclass{
private:
    std::unique_ptr<Orhn> oz;
public:
    Myclass() : oz{new Orhn}
    {
        throw std::exception{};
    }

};


int main()
{
    try {
        Myclass mx;
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/





#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;


class Myclass{
public:
    Myclass()
    {
       cout << "Myclass ctor\n";
    }


    ~Myclass()
    {
       cout << "Myclass dtor\n";
       throw std::exception{};
    }

};

void func()
{
    Myclass mx;

    throw  exception{};
}

int main()
{
    set_terminate(&myabort);

    try {
        func();
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;


class Myclass{
public:
    Myclass()
    {
       cout << "Myclass ctor\n";
    }


    ~Myclass()
    {
       cout << "Myclass dtor\n";

       try {
           throw std::exception{};
       }  catch (...) {
           cout << "hata... dtor icinde yakalandi\n";
       }

    }

};

void func()
{
    Myclass mx;

    throw  exception{};
}

int main()
{
    set_terminate(&myabort);

    try {
        func();
    }  catch (std::exception &ex) {
        cout << "hat yakalandi " << ex.what() << "\n";
    }

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

//bu fonksiyonun exception gondemryecek garantisi var
void func()noexcept;



int main()
{


}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

//bu fonksiyonun exception gondemryecek garantisi var
void func()noexcept;

void foo()
{
    if(rand() % 4 == 3)
        throw 5;
}

void func()noexcept
{
    foo();
}



int main()
{
  set_terminate(&myabort);

  try {
      for (int i = 0; i < 10; ++i) {
          func();
      }
  }  catch (...) {
      cout << "hata yakalandi\n";
  }

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{
public:
    ~Myclass(); //noexcepted olarka kabul edilirz

};



int main()
{


}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

//eskiye uyum
void func() throw(bad_alloc);



int main()
{


}

/***************************************************/
/***************************************************/

kalıtımda
final class





#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base{
public:
    virtual ~Base() = default;
};

class Der final : public Base{

};

//der sınıfında türeme yazpılamaz dedik final keywordu ile
class Sder : public Der{

};


int main()
{


}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base{
public:
    virtual void func();
};

class Der : public Base{
public:
    void func()override final;
};

class Sder : public Der{
public:
    void func()override; //verrirde edemeyiz final keyword ten
};


int main()
{


}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base{
public:
    virtual void func();
};

class Der : public Base{
public:
    void func()override final;
};


//final yazılmaz tanımında
void Der::func() final
{

}

int main()
{


}

/***************************************************/
/***************************************************/

runtime type identification
runtime type indormation


programın çalışma zamanında bir nesneinn dinamik türünün ne olduhunun anlaşılması


dynamic_cast operatür

typeid operatürü
  typeinfo sınıfıı


bu araçları inceleyecegiz


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void car_game(Car *p)
{
    p->start();
    p->run();

    //mercedes oldugun cam tavan acildsin
    Mercedes *ms = dynamic_cast<Mercedes *>(p); //işlem yapılmıyorsa nullptr
    if(ms){
        ms->open_sunroof();
    }
    p->stop();
}

int main()
{
    for (; ; ) {
        auto p = create_random_car();
        car_game(p);
        delete p;
        getchar();
    }

}

/***************************************************/
/***************************************************/


static_cast
const_cast
reinterpret_cast

dynamic_cast


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void car_game(Car *p)
{
    p->start();
    p->run();

    if(Mercedes *ms = dynamic_cast<Mercedes *>(p)){
        ms->open_sunroof();
    }
    p->stop();
}

int main()
{
    for (; ; ) {
        auto p = create_random_car();
        car_game(p);
        delete p;
        getchar();
    }
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void car_game(Car *p)
{
    p->start();
    p->run();

    if(Audi *as = dynamic_cast<Audi *>(p)){
        as->open_sunroof();
    }
    p->stop();
}

int main()
{
    for (; ; ) {
        auto p = create_random_car();
        car_game(p);
        delete p;
        getchar();
    }
}

/***************************************************/
/***************************************************/


dynamic_cast operatorunun operandı olan ifade polimorfik bir türe ilşikin olmalı yoksa kod gecersiz


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base
{
public:
    void func();
};

class Der : public Base{

};


void foo(Base *p)
{
    Der *derptr = dynamic_cast<Der*>(p);//gecersiz
}

int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base
{
public:
    virtual void func();
};

class Der : public Base{

};


void foo(Base *p)
{
    Der *derptr = dynamic_cast<Der*>(p);//gecerli
}

int main()
{

}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;


void car_game(Car &rc)
{
    rc.start();
    Audi &ar = dynamic_cast<Audi &>(rc);
    ar.open_sunroof();
    rc.run();
    rc.stop();
}



int main()
{
    car_game(*new Audi);
    car_game(*new Audi8);


    car_game(*new Volvo);


}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;


void car_game(Car &rc)
{
    rc.start();
    Audi &ar = dynamic_cast<Audi &>(rc);
    ar.open_sunroof();
    rc.run();
    rc.stop();
}



int main()
{
    set_terminate(&myabort);

    try {
       car_game(*new Volvo);
    }  catch (std::bad_cast &ex) {
        std::cout << "hata yakalandi .... " << ex.what() << "\n";
    }
}

/***************************************************/
/***************************************************/


typeid operatoru

typeid(expr) --> bu ifade derleyici tarafından typeinfo türüdnen bir nesne referansına
runtime identification


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    typeid (Myclass).name();//typeinfo sınıfı memberı
}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    auto tx{typeid (Myclass)}; //typeinfo sınıfının copy ctor delete edilmiş
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    Myclass mx;
    int ival{};
    int *iptr = nullptr;

    cout << typeid (mx).name() << "\n";
    cout << typeid (ival).name() << "\n";
    cout << typeid (iptr).name() << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    cout << typeid (10).name() << "\n";
    cout << typeid (10u).name() << "\n";
    cout << typeid ('A').name() << "\n";
    cout << typeid (10ull).name() << "\n";
    cout << typeid (10.).name() << "\n";
    cout << typeid (10.f).name() << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    int x = 10;
    cout << typeid (x++).name() << "\n";
    cout << sizeof(x++) << "\n";
    cout << "x =  " << x << "\n";
}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Myclass{

};

int main()
{
    int x = 10;
    typeid (x) == typeid (int);
    //typeid (x).operator==(typeid (int));

    cout << boolalpha << (typeid (x) == typeid (int)) << "\n";
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base{
public:
};

class Der : public Base{

};


int main()
{

    Base *ptr = new Der;

    cout << typeid (*ptr).name() << "\n";
    cout << boolalpha << (typeid (*ptr) == typeid (Der)) << "\n";
    //eşit değil
    //polimormif olamayan türler için typeie operatoru
    //compile time da static türlere ilişşkin degerler üretir
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class Base{
public:
    virtual ~Base() = default;
};

class Der : public Base{

};


int main()
{

    Base *ptr = new Der;

    cout << typeid (*ptr).name() << "\n";
    cout << boolalpha << (typeid (*ptr) == typeid (Der)) << "\n";
    //eşit değil
    //polimormif olamayan türler için typeie operatoru
    //artık dynamik türlere ilişkin ifade oldugu için runtime da dogru degeeri elde ederiz
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void car_game(Car *carptr)
{
    carptr->start();
    carptr->run();

    if(typeid (*carptr) == typeid (Audi)){
        Audi *ap = static_cast<Audi *>(carptr);
        ap->open_sunroof();
    }

    carptr->stop();

            getchar();
}


int main()
{
    for (; ; ) {
        Car*p = create_random_car();
        car_game(p);
        delete p;
    }
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class A{

};

class B{

};


int main()
{
    A ax;
    B *ptr = static_cast<B*>(&ax);//ilişki olmaıdıg için static_cat ile cast edemeyiz
    //reinterpret_cat yada C tarzı  cast etmeliyiz
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

class A{

};

class B : public A{

};


int main()
{
    A ax;
    B *ptr = static_cast<B*>(&ax);//ilişkili oldugu için artık gecer
}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>

using namespace std;

void car_game(Car *carptr)
{

    if(typeid (*carptr) == typeid (Audi)){
        Audi *ap = static_cast<Audi *>(carptr);
        ap->open_sunroof();
    }

    carptr->start();
    carptr->run();
    carptr->stop();

   getchar();
}


int main()
{
    try {
        car_game(nullptr);
    }  catch (const exception &ex) { //bad_typeid
        cout << "hata yakalndi  : " << ex.what() <<"\n";
    }
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>
#include "mint.hpp"

using namespace std;




int main()
{
   set_terminate(&myabort);
   Mint x{13}, y{};

   cout << x << ", " << y << "\n";

   try {
      auto z = x / y;
   }  catch (const exception &ex) {
       cout << "hata yakalnadi.. : " << ex.what() << "\n";
   }

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>
#include "mint.hpp"

using namespace std;




int main()
{
   set_terminate(&myabort);
   Mint x{13}, y{};

   cout << x << ", " << y << "\n";

   try {
      auto z = x / y;
   }  catch (const runtime_error &ex) {
       cout << "hata yakalnadi.. : " << ex.what() << "\n";
   }

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>
#include "mint.hpp"

using namespace std;




int main()
{
   set_terminate(&myabort);
   Mint x{13}, y{};

   cout << x << ", " << y << "\n";

   try {
      auto z = x / y;
   }  catch (const BadMintDivision &ex) {
       cout << "hata yakalnadi.. : " << ex.what() << "\n";
   }

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <stdexcept>
#include "car.hpp"
#include <memory>
#include <vector>
#include "mint.hpp"

using namespace std;

std::ostream &operator<<(std::ostream &os, const Car &rcar)
{
    return rcar.print(os);
}


int main()
{
    while (true) {
        Car *p = create_random_car();
        cout << *p << "\n";
        delete p;
        std::cout << "\n\n";
        getchar();
    }

}

/***************************************************/
/***************************************************/

private and protected inheritance

#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};


class Der : public Base{
public:
    void f()
    {
        fpub();
    }
};

class Sder : public Der{
    void fx()
    {
        fpub();
    }
};

int main()
{

}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};


class Der : public Base{
public:
    void f()
    {
        fpro();
    }
};

class Sder : public Der{
    void fx()
    {
        fpro();
    }
};

int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};


class Der : public Base{
public:
    void f()
    {
        fpri();//private nesne oldugu için esntajks hatası
    }
};

class Sder : public Der{
    void fx()
    {
        fpri();
    }
};

int main()
{

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};


class Der : private Base{
public:

};

int main()
{

    Der myder;
    Base *p = &myder; //sentaks hatası upcasting yapamıyoruz

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};


class Der : private Base{
public:
    void func()
    {
        Der myder;
        Base *p = &myder; //upcasting yapabiliyoruz türemiş  sınıfta
        //client kodlar da gecerli degil
    }

};

int main()
{


}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};

class Der : private Base{
public:
    void func()
    {
        Der myder;
        Base *p = &myder; //upcasting yapabiliyoruz türemiş  sınıfta
        //client kodlar da gecerli degil
    }

};

void g()
{
    Der myder;
    Base *p = &myder; //gecersiz
}

int main()
{


}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};

//türemiş sınıf taban sınıfın public kısmı artık benim private kısmım
//türemiş sınıf taban sınıfın protected kısmı artık benim private kısmım
//türemiş sınıf taban sınıfın private kısmı artık beni ilgilendirmiyor

class Der : private Base{
public:
    void func()
    {
        fpub();
        fpro();
        //fpri(); //gecersiz
    }

};



int main()
{

    Der myder;
    myder.fpub(); //gecersiz

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    void fpri();
protected:
    void fpro();
public:
    void fpub();

};

//türemiş sınıf taban sınıfın public kısmı artık benim private kısmım
//türemiş sınıf taban sınıfın protected kısmı artık benim private kısmım
//türemiş sınıf taban sınıfın private kısmı artık beni ilgilendirmiyor

class Der : private Base{
public:
    void func()
    {
        fpub();
        fpro();
        //fpri(); //gecersiz
    }

};



int main()
{
    //clientlar artık kulanamaz base sınıfın elemanlarını
    Der myder;
    myder.fpub(); //gecersiz

}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
    virtual void fpri();
protected:
    virtual void fpro();
public:
    virtual void fpub();

};


class Der : private Base{
public:
    void fpri()override;
    void fpro()override;
    void fpub()override;
};



int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
private:
     void fpri();
protected:
     void fpro();
public:
     void fpub();

};


class Der : private Base{
public:
    using Base::fpub;
    using Base::fpro;

};

class A{
public:
    void fpub()
    {
        bx.fpub();
    }

    void fpro()
    {
        //bx.fpro(); //gecersiz
    }

private:
    Base bx;
};



int main()
{
    A ax;
    Der der;

    ax.fpub();
    der.fpub();
}

/***************************************************/
/***************************************************/




#include <iostream>
#include "utility.hpp"


using namespace std;

//RAII
//IIFE
//RVO
//NRVO
//SBO
//ADL
//SFINAE
//RTTI
//EBO --> bos sınıf akronomisi -- empty base optimization

class Empty{
    //no non static data member;
};

class Orhn{
private:
    int mx;
};

int main()
{
    cout << "size Empty : " << sizeof (Empty) << "\n";
    cout << "size Orhn : " << sizeof (Orhn) << "\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

//RAII
//IIFE
//RVO
//NRVO
//SBO
//ADL
//SFINAE
//RTTI
//EBO --> bos sınıf akronomisi -- empty base optimization

class Empty{
    //no non static data member;
};

class Orhn{
private:
    int mx;
    Empty ex;
};

int main()
{
    cout << "size Empty : " << sizeof (Empty) << "\n";
    cout << "size Orhn : " << sizeof (Orhn) << "\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

//RAII
//IIFE
//RVO
//NRVO
//SBO
//ADL
//SFINAE
//RTTI
//EBO --> bos sınıf akronomisi -- empty base optimization

class Empty{
    //no non static data member;
};

class Orhn : public Empty{
private:
    int mx;
};

int main()
{
    cout << "size Empty : " << sizeof (Empty) << "\n";
    cout << "size Orhn : " << sizeof (Orhn) << "\n";
}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
public:
    virtual void func();
};

class Der : private Base{
public:
    void func()override;
};

void gf1(Base &r)
{
    r.func();
}


void gf2(Base &r)
{
    r.func();
}


void gf3(Base &r)
{
    r.func();
}


int main()
{
    Der myder;

    gf1(myder);// sentaks hatası private türeme oldugu için

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

class Base{
public:
    virtual void func();
};

class Der : private Base{
public:
    void func()override;
    friend void gf1(); //friend lik is-a ilişki var
};

void gf1()
{
    Der myder;
    Base &rbase = myder;
}


void gf2()
{
    Der myder;
    Base &rbase = myder;
}


void gf3()
{
    Der myder;
    Base &rbase = myder;
}


int main()
{


}

/***************************************************/
/***************************************************/

Generic Programlama

türden bagımsız Programlama
Derleme zamaınına baglıdır

template
1- class template
2- function template
3- member template
4- member function template
5- alias template - C++11 --> typedef ve using eş isim verebiliyoruz
                              typedef bildirimleri türden bagımsız hale getirelemiyor
                              using bildirimi türden bagımsız haline getirebiliypr buna alias template denir
6- variable template C++14





#include <iostream>
#include "utility.hpp"


using namespace std;

template<class T> //t burada bir türü temsil eder

template<typename T> // t burada türü temsil eder

//class ve typename aynı anlmadadır


int main()
{


}

/***************************************************/
/***************************************************/

tür çıkarımı -- type deduction
C++17 ile beraber class templatelere tür çıkarımı eklendi
CTAD denir


template argument deduction



#include <iostream>
#include "utility.hpp"


using namespace std;

template<typename T>
void func(T x)
{

}


template<typename T>
void func1(T *x)
{

}


template<typename T>
void func2(T **x)
{

}


int main()
{


}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

template<typename T>
void func(T x)
{

}


int main()
{
    func<int>(12);

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"


using namespace std;

template<typename T>
void func(T *x)
{

}


int main()
{
    int x = 10;
    func<int>(&x);

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

template<typename T>
void func(T **x)
{

}


int main()
{
    int x = 10;
    int *ptr = &x;
    func<int>(&ptr);

}

/***************************************************/
/***************************************************/


template argument deduction

auto ile yapılan tür  cıkarımı ile template argument deduction ile yapılan tür çıkarımı tamamen aynıdır
sadece 1-2 farklılık mevcut

auto z = expr;
auto &z = expr;
auto &&z = expr;

#include <iostream>
#include "utility.hpp"


using namespace std;

template<typename T>
void func(T x)
{

}

int main()
{
    auto x = 12;
    //func<int>(12);
    func(12); //tempalte argument deduction

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller;

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{
    //tür cıkıramında const luk gaz ardı edilir
    const int a = 23;
    func(a); //T nin türü int

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{
    //tür cıkıramında referanslıkda göz ardı edilir
    int a = 23;
    int &r = a;
    func(r); //T nin türü int

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{
    //tür cıkıramında cosntluk ve referanslık göz ardı edilir
    int a = 23;
    const int &r = a;
    func(r); //T nin türü int

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{
    int a[10]{};
    func(a); //T nin tür int *

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{
    const int a[10]{};
    func(a); //T nin tür const int *

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int main()
{

    func("orhan"); //T nin tür const char*

}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"


using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}

int foo(int); //int (*)(int)

int main()
{

    func(foo); //T nin tür int (*)(int)

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x)
{
   TypeTeller<T> y;
}


int main()
{
    //fark auto ile template type deduction
    auto x = {1, 2, 3, 4, 5}; //int[] türü


    func({1, 2, 3, 4, 5}); //tür cıkarımı yapılamıyor


}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T x, T y)
{

}


int main()
{
    func(12, 15);
    func(12, 15.5); //celişkili durum bu yuzden tür çıkarımı yapılamaz

}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x)
{
   TypeTeller<T> y;
}


int main()
{

    //auto ile farklılıklardan biri
    const int a = 20;
    func(a); //t türü const int


}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x)
{
   TypeTeller<T> y;
}


int main()
{

    int a[10]{};
    func(a); //t türü int[10]


}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x)
{
   TypeTeller<T> y;
}


int main()
{

    func("orhan"); //const char[6]


}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x, T y)
{
    TypeTeller<T> c;
}


int main()
{
    int a[5]{};
    int b[10]{};

    func(a, b); //int *
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x, T &y)
{
    TypeTeller<T> c;
}


int main()
{
    int a[5]{}; //int [5]
    int b[10]{}; // int [10]

    func(a, b); // sentask hatsı dizi boyutları aynı olmadıgı için
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T x, T y)
{
    TypeTeller<T> c;
}


int main()
{


    func("orhan", "can"); //const cahr *
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x, T &y)
{
    TypeTeller<T> c;
}


int main()
{


    func("orhan", "can"); // sentaks hatası string boyutları aynı olmadıgı için
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x, T &y)
{
    TypeTeller<T> c;
}


int main()
{
    func("orhan", "orhan"); //gecerli

    func("orhan", "can"); // sentaks hatası string boyutları aynı olmadıgı için
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template <typename T>
class TypeTeller; //amac sadecce hangi türü anlamak için kullanılmıstır

template<typename T>
void func(T &x, T &y)
{
    TypeTeller<T> c;
}


int main()
{
    func("orhan", "kemal"); //gecerli

    func("orhan", "can"); // sentaks hatası string boyutları aynı olmadıgı için
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

void func(string &&str); //Rvalue referans
//taşıma için kullanırız
//move fonksiyonuna arguman olarak verilir


int main()
{
    string &&x = "orhan";
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


//forwarding referans
//universal referans

template<typename T>
void func(T &&x) //buna sag traf referansı Rvaleu denmez
{

}


int main()
{
    auto &&x = 12;//sag taraf referansı Rvalue denir

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template< typename T>
class TypeTeller;

//forwarding referans
//universal referans

template<typename T>
void func(T &&x) //buna sag traf referansı Rvaleu denmez
{
   TypeTeller<T> y;

   T val = y; // val int türü

}


int main()
{
    func(12); //T tür int

}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template< typename T>
class TypeTeller;

//forwarding referans
//universal referans

template<typename T>
void func(T &&x)
{
    int a = 23;
    T r = a; //r referasn

   TypeTeller<T> y;
}


int main()
{
    int a = 20;
    func(a); //Lvalue T tür int &

}

/***************************************************/
/***************************************************/


referansa referans ortaya çıkar ise


T&   &x  --> T& x elde ederiz
T&   &&x  --> T& x elde ederiz
T&&  &x ---> T& x elde ederiz
T&&  &&x ---> T&& x elde ederiz




#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template< typename T>
class TypeTeller;

template<typename T>
void func(T &&x)
{
   TypeTeller<T> y;
}


int main()
{
    int a = 20;
    func(a); //Lvalue T tür int &

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template< typename T>
class TypeTeller;

template<typename T>
void func(T &&x)
{
   TypeTeller<T> y;
}


int main()
{
    func<int &&>(12);
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

//eger func işlevi sag taraf degeri ile cagrılırsa
//T türü referans türü değil yani int , string , Myclass vs.
//ve işlev parametresi sag taraf referansı

//eger func işlevi sol taraf degeri ile cagrılırsa
//T türü referans türü  yani int & , string& , Myclass& vs.
//ve işlev parametresi sol taraf referansı



/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T *x)
{

}


int main()
{
    int ival = 10;
    func(&ival); //T türü ne olur
    //T türü int
    //x int türü int *
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T *x)
{

}


int main()
{
    int ival = 10;
    int *p = &ival;

    func(&p); //T türü ne olur
    //T türü int *
    //x int türü int **
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T **x)
{

}


int main()
{
    int ival = 10;
    int *p = &ival;

    //int **
    func(&p); //T türü ne olur
    //T türü int
    //x int türü int **
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T (*fp)(T))
{

}

int foo(int);

int main()
{
   func(&foo); //T nin türü
   //T türü int
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
void func(T (*fp)(T))
{

}

int foo(double);

int main()
{
    func(&foo); //T türü
    //sentask hatası
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T, typename U>
void func(T (*fp)(U))
{

}

int foo(double);

int main()
{
    func(&foo); //T türü int
    //U türü double

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

int main()
{

    int a[] = {2, 5, 6, 7, 8, 4};

    auto constexpr val = sizeof (a) / sizeof (a[0]);
    val;

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T, int val>
constexpr int asize(T (&)[val])
{
    return val;
}

int main()
{

    int a[] = {2, 5, 6, 7, 8, 4};

    int x = asize(a);

    cout << "x = " << x <<"\n";

    int b[asize(a)];

}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TypeTeller;

template<typename T>
void func(T f) //void (*)()
{
    TypeTeller<T> x;
    f();
}

void f()
{
    cout << "f cagrildi\n";
}

int main()
{
    func(f);
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TypeTeller;

template<typename T>
void func(T f) //void (*)()
{
    TypeTeller<T> x;
    f();
}

class Functor{
public:
    void operator()(){
        cout << "Functor::operator cagrildi\n";
    }
};

int main()
{
    Functor f;

    func(f);//f türü function pointer olarak cagrımı yaptı
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TypeTeller;

template<typename T>
void func(T x)
{

}



int main()
{
    //explicit type argument acık tur agumanı
    func<int>(12);
    func<int>(1.2); // int cast ederim

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TypeTeller;

template<typename T, typename U>
void func(T x, U y)
{

}



int main()
{
    //explicit type argument acık tur agumanı
    func<int, double>(12, 4.4);
    func<int>(12, 4.4); // ikikncş argumaınn cıkarımını yaparım double olacak

}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T>
T sum(T x, T y)
{
    return x + y;
}


int main()
{
    auto val = sum(12, 5.6); //sentask hatası ambiguiti
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


template<typename T, typename U>
U sum(T x, U y)
{
    return x + y;
}


int main()
{
    auto val = sum(1.2, 56);
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

//eski çözüm
template<typename R, typename T, typename U>
R sum(T x, U y)
{
    return x + y;
}

int main()
{
    auto val = sum<double>(1.2, 56);
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

//dile eklenen arclar ile daha kolay hale getirilidi
//traling return type

template<typename T, typename U>
auto sum(T x, U y) -> decltype (x + y)
{
    return x + y;
}

int main()
{
    cout << sum(12, 5.6) << "\n";
    cout << sum(1.2, 56) << "\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

//dile eklenen arclar ile daha kolay hale getirilidi
//auto return type
template<typename T, typename U>
auto sum(T x, U y)
{
    return x + y;
}

int main()
{
    cout << sum(12, 5.6) << "\n";
    cout << sum(1.2, 56) << "\n";
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
void func(T x)
{
    cout << "type T is : " << typeid (T).name() << "\n";
}

int main()
{
    func('A');
    func(12.L);
    func(12);
    func(12u);
    func(12.f);
    func(12.);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

//overloading
template<typename T>
void func(T x)
{
    cout << "type T is : " << typeid (T).name() << "\n";
}

void func(int x)
{
    cout << "void func(int) cagrildi " << "\n";
}

void func(long double x)
{
    cout << "void func(long double) cagrildi " << "\n";
}

int main()
{

    func(12.L);
    func(12);
    func(12u);

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


//mulakat sorusu
//sadece istenilen arguman türleri ile cagrılsın func fonksiyonu

//overloading
template<typename T>
void func(T x) = delete;

void func(int x)
{
    cout << "void func(int) cagrildi " << "\n";
}


int main()
{
    func(12.L);
    func(12);
    func(12u);
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;


//mulakat sorusu

//overloading
template<typename T>
void func(T x)
{
    cout << "template void func(T x) cagrildi \n";
}

template<typename T>
void func(T x, T y)
{
    cout << "template void func(T x, T y) cagrildi \n";
}


int main()
{
    func(12.L);
    func(12);
    func(12, 45);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;

template<typename T>
void func(T a) //int *
{
    TellerClass<T> y;
    cout << "template void func(T x) cagrildi \n";
}

int main()
{
    int x = 10;
    func(&x);
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;

/*
template<typename T>
void func(T a) //int *
{
    TellerClass<T> y;
    cout << "template void func(T x) cagrildi \n";
}
*/

template<typename T>
void func(T *a)
{
    //TellerClass<T> y;
    cout << "template void func(T x) cagrildi \n";
}

int main()
{
    int x = 10;
    func(&x);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;


//kural seti
//partial order denir
//derleyici biraz daha sepecific olanı tercih eder

template<typename T>
void func(T a)
{
    //TellerClass<T> y;
    cout << "template void func(T x) cagrildi \n";
}

template<typename T>
void func(T *a)
{
    //TellerClass<T> y;
    cout << "template void func(T *x) cagrildi \n";
}

int main()
{
    int x = 10;
    func(&x);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;


//kural seti
//partial order denir
//derleyici biraz daha sepecific olanı tercih eder

template<typename T>
void func(T a)
{
    //TellerClass<T> y;
    cout << "template void func(T x) cagrildi \n";
}

template<typename T>
void func(T *a)
{
    //TellerClass<T> y;
    cout << "template void func(T *x) cagrildi \n";
}

template<typename T>
void func(T **a)
{
    //TellerClass<T> y;
    cout << "template void func(T **x) cagrildi \n";
}

int main()
{
    int x = 10;
    func(&x);//int *
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;


//kural seti
//partial order denir
//derleyici biraz daha sepecific olanı tercih eder

template<typename T>
void func(const T *a)
{
    //TellerClass<T> y;
    cout << "template void func(const T *x) cagrildi \n";
}

template<typename T>
void func(T *a)
{
    //TellerClass<T> y;
    cout << "template void func(T *x) cagrildi \n";
}


int main()
{
    int x = 10;
    func(&x);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"
#include <initializer_list>

using namespace std;

template<typename T>
class TellerClass;


template<typename T>
void func(T a)
{
    //TellerClass<T> y;
    cout << "template void func(T *x) cagrildi \n";
}

void func(int)
{
    //TellerClass<T> y;
    cout << "void func(int) cagrildi \n";
}


int main()
{
    func<int>(12);
    func(12);
}

/***************************************************/
/***************************************************/

sınıf şablonları template


baslık dosyasında olmak zorunda


#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename T>
class Orhn{
public:
    Orhn() = default;
    Orhn(T x);
    T get()const;
    void set(const T &t);

private:
    T mx{};
};


int main()
{
    Orhn<int> x;
    Orhn<double> y;
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename T>
class Orhn{
public:
    Orhn() = default;
    Orhn(T x);
    T get()const;
    void set(const T &t);
    void func(T x)
    {
        x(); //taki func ı cagırana kadar bu sentask hatası ortaya cıkmaycaktı
    }

private:
    T mx{};
};


int main()
{
    Orhn<int> x;
    //x.func(12);
}

/***************************************************/
/***************************************************/

#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename T>
class Orhn{
public:
    Orhn(T &&);
    void func(T (*f)(T));

private:
    T a[10];
};


int main()
{
    Orhn<int> x;//
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"

using namespace std;


//inline tanım
template<typename T>
class Orhn{
public:
    void func(T x);

private:
};

//bu sekilde tanımlayabiliriz
template<typename T>
void Orhn<T>::func(T x)
{

}


int main()
{
    Orhn<int> x;//
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"

using namespace std;

//kemal candan bakıp ögrecek bize
template<size_t>
class Orhn{
public:


private:
};

int main()
{
    Orhn<10> x;// Orhn<10> acilimi
    Orhn<1000> y;// Orhn<1000> acilimi
}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"

using namespace std;

//kemal candan bakıp ögrecek bize
template<size_t>
class Orhn{
public:


private:
};

int main()
{
    Orhn<10> x;// Orhn<10> acilimi //10 elelnalı x
    Orhn<1000> y;// Orhn<1000> acilimi // 1000 ellmanlı y
}

/***************************************************/
/***************************************************/
#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename  T>
class Myclass{
public:

};

template<typename T>
void func(T x);


int main()
{
   Myclass<int> x;

   func(x);
}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename T, size_t size>
class Myclass{
public:

private:
    T a[size]; //10 elemanlı bir dizi

};


int main()
{
   Myclass<int, 10> x;

   Myclass<int, 20> y;


}

/***************************************************/
/***************************************************/


#include <iostream>
#include "utility.hpp"

using namespace std;

template<typename T>
class Myclass{
public:
    template<typename T>
    void func(T x)
    {
        //böyle template funclar yazabiliriz
    }


};


int main()
{
   Myclass<int> x;

   x.func(11);
   x.func("orhn");
   x.func(1.2);

}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"

using namespace std;

class Myclass{
public:
    template<typename T>
    Myclass(T x); //ctor da sınıf sablonları olabilir

};


int main()
{
   Myclass x(12);


}

/***************************************************/
/***************************************************/



#include <iostream>
#include "utility.hpp"

using namespace std;

//std::pair basit interface yapısının gösterimi

template<typename T, typename U>
struct Pair{

    T first;
    U second;

    Pair() : first(), second(){};
    Pair(const T &t, const U &u) : first(t), second(u){};

};

template<typename T, typename U>
bool operator<(const Pair<T,U> &p1, const Pair<T,U> &p2)
{
    return p1.first < p2.first || !(p2.first < p1.first && p1.second < p2.second);
}


int main()
{
    //Pair<string, double> px;
    Pair<int, double> py;

    cout << py.first << ", " << py.second << "\n";



    Pair<int, double> p1{123, 2.1};
    Pair<int, double> p2{3, 2.3};

    auto b =  p1 < p2;


}

/***************************************************/
/***************************************************/




























































































































































































































































































































































































































































































































































































































































































































